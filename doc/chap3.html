<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
         "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<title>GAP (Algebroids) - Chapter 3: Examples</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
<meta name="generator" content="GAPDoc2HTML" />
<link rel="stylesheet" type="text/css" href="manual.css" />
<script src="manual.js" type="text/javascript"></script>
<script type="text/javascript">overwriteStyle();</script>
</head>
<body class="chap3"  onload="jscontent()">


<div class="chlinktop"><span class="chlink1">Goto Chapter: </span><a href="chap0.html">Top</a>  <a href="chap1.html">1</a>  <a href="chap2.html">2</a>  <a href="chap3.html">3</a>  <a href="chap4.html">4</a>  <a href="chapInd.html">Ind</a>  </div>

<div class="chlinkprevnexttop">&nbsp;<a href="chap0.html">[Top of Book]</a>&nbsp;  <a href="chap0.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap2.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap4.html">[Next Chapter]</a>&nbsp;  </div>

<p id="mathjaxlink" class="pcenter"><a href="chap3_mj.html">[MathJax on]</a></p>
<p><a id="X7A489A5D79DA9E5C" name="X7A489A5D79DA9E5C"></a></p>
<div class="ChapSects"><a href="chap3.html#X7A489A5D79DA9E5C">3 <span class="Heading">Examples</span></a>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap3.html#X7B8327EC7AC3E634">3.1 <span class="Heading">Algebroids</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap3.html#X813B1A1C7E283B80">3.2 <span class="Heading">Bialgebroids</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap3.html#X868B56CD7EE75283">3.3 <span class="Heading">Hopf algebra generated by group-like elements</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap3.html#X7B04AAC77CDF3568">3.4 <span class="Heading">Hopf algebra generated by a primitive element</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap3.html#X8193250583CB118F">3.5 <span class="Heading">A non-counitary coalgebra</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap3.html#X7B9F1F17869C5429">3.6 <span class="Heading">Sweedlers 4-dimensional Hopf algebra</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap3.html#X86A2AE6E7C297595">3.7 <span class="Heading">Homomorphism structure</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap3.html#X7C0C87E4856062AF">3.8 <span class="Heading">Algebroids over the integers</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap3.html#X7C0BEF04853A376E">3.9 <span class="Heading">Unitors</span></a>
</span>
</div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap3.html#X7B34D0E6854E90C8">3.10 <span class="Heading">Associators</span></a>
</span>
</div>
</div>

<h3>3 <span class="Heading">Examples</span></h3>

<p><a id="X7B8327EC7AC3E634" name="X7B8327EC7AC3E634"></a></p>

<h4>3.1 <span class="Heading">Algebroids</span></h4>

<p>Create a left quiver <span class="Math">ql</span> with 3 vertices u,v,w and 4 edges a,b,c,d.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ql := LeftQuiver( "ql(u,v,w)[a:u-&gt;v,b:v-&gt;u,c:v-&gt;u,d:v-&gt;w]" );</span>
ql(u,v,w)[a:u-&gt;v,b:v-&gt;u,c:v-&gt;u,d:v-&gt;w]
</pre></div>

<p>Create a right quiver <span class="Math">qr</span> with 3 vertices u,v,w and 4 edges a,b,c,d.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">qr := RightQuiver( "qr(u,v,w)[a:u-&gt;v,b:v-&gt;u,c:v-&gt;u,d:v-&gt;w]" );</span>
qr(u,v,w)[a:u-&gt;v,b:v-&gt;u,c:v-&gt;u,d:v-&gt;w]
</pre></div>

<p>Create algebroids from these quivers over <span class="Math">\mathbb{Q}</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LoadPackage( "MatricesForHomalg" );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Q := HomalgFieldOfRationals( );</span>
Q
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Al := Algebroid( Q, ql );</span>
Algebroid generated by the left quiver ql(u,v,w)[a:u-&gt;v,b:v-&gt;u,c:v-&gt;u,d:v-&gt;w]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">algebra_Al := UnderlyingQuiverAlgebra( Al );</span>
Q * ql
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Ar := Algebroid( Q, qr );</span>
Algebroid generated by the right quiver qr(u,v,w)[a:u-&gt;v,b:v-&gt;u,c:v-&gt;u,d:v-&gt;w]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">algebra_Ar := UnderlyingQuiverAlgebra( Ar );</span>
Q * qr
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Al.u;</span>
&lt;(u)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Ar.u;</span>
&lt;(u)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Al.a;</span>
(v)&lt;-[1*(a)]-(u)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Ar.a;</span>
(u)-[1*(a)]-&gt;(v)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SetOfObjects( Al );</span>
[ &lt;(u)&gt;, &lt;(v)&gt;, &lt;(w)&gt; ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SetOfGeneratingMorphisms( Al );</span>
[ (v)&lt;-[1*(a)]-(u), (u)&lt;-[1*(b)]-(v), (u)&lt;-[1*(c)]-(v), (w)&lt;-[1*(d)]-(v) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SetOfGeneratingMorphisms( Al, Al.u, Al.v );</span>
[ (v)&lt;-[1*(a)]-(u) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SetOfObjects( Ar );</span>
[ &lt;(u)&gt;, &lt;(v)&gt;, &lt;(w)&gt; ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SetOfGeneratingMorphisms( Ar );</span>
[ (u)-[1*(a)]-&gt;(v), (v)-[1*(b)]-&gt;(u), (v)-[1*(c)]-&gt;(u), (v)-[1*(d)]-&gt;(w) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SetOfGeneratingMorphisms( Ar, Ar.u, Ar.v );</span>
[ (u)-[1*(a)]-&gt;(v) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">CommutativeRingOfLinearCategory(Al) = Q;</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ObjectInAlgebroid(Al, ql.u) = Al.u;</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Al.u = ql.u / Al;</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">MorphismInAlgebroid( Al, algebra_Al.a ) = Al.a;</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Al.a = algebra_Al.a / Al;</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IdentityMorphism( Al.u ) = algebra_Al.u / Al;</span>
true
</pre></div>

<p>We can compute in the algebroids. For instance we can form compositions.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PreCompose( Al.a, Al.d );</span>
(w)&lt;-[1*(d*a)]-(u)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PreCompose( Ar.a, Ar.d );</span>
(u)-[1*(a*d)]-&gt;(w)
</pre></div>

<p>We also have addition and subtraction of morphisms and scalar multiplication with elements from the ground ring <span class="Math">\mathbb{Q}</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Al.b+Al.c;</span>
(u)&lt;-[1*(c) + 1*(b)]-(v)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Ar.b+Ar.c;</span>
(v)-[1*(c) + 1*(b)]-&gt;(u)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Al.b-Al.c;</span>
(u)&lt;-[-1*(c) + 1*(b)]-(v)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Ar.b-Ar.c;</span>
(v)-[-1*(c) + 1*(b)]-&gt;(u)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Al.d - Al.d;</span>
(w)&lt;-[0]-(v)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Ar.d - Ar.d;</span>
(v)-[0]-&gt;(w)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">1/2 * Al.d;</span>
(w)&lt;-[1/2*(d)]-(v)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">1/2 * Ar.d;</span>
(v)-[1/2*(d)]-&gt;(w)
</pre></div>

<p><a id="X813B1A1C7E283B80" name="X813B1A1C7E283B80"></a></p>

<h4>3.2 <span class="Heading">Bialgebroids</span></h4>

<p>Create a right quiver <span class="Math">q</span> with two vertices <span class="Math">u</span> and <span class="Math">v</span> and two edges <span class="Math">a</span> and <span class="Math">b</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">q := RightQuiver( "q(u,v)[a:u-&gt;v,b:v-&gt;u]" );</span>
q(u,v)[a:u-&gt;v,b:v-&gt;u]
</pre></div>

<p>Create the path algebra <span class="Math">\mathbb{Q}q</span> of <span class="Math">q</span> over <span class="Math">\mathbb{Q}</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">q := RightQuiver( "q(u,v)[a:u-&gt;v,b:v-&gt;u]" );</span>
q(u,v)[a:u-&gt;v,b:v-&gt;u]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Q := HomalgFieldOfRationals( );</span>
Q
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Qq := PathAlgebra( Q, q );</span>
Q * q
</pre></div>

<p>Form a quotient of <span class="Math">\mathbb{Q}q</span> by the relations <span class="Math">ab - u</span> and <span class="Math">ba - v</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">B := Algebroid( Qq, [ Qq.a * Qq.b - Qq.u, Qq.b * Qq.a - Qq.v ] );</span>
Algebroid generated by the right quiver q(u,v)[a:u-&gt;v,b:v-&gt;u]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RelationsOfAlgebroid( B );</span>
[ (u)-[1*(a*b) - 1*(u)]-&gt;(u), (v)-[1*(b*a) - 1*(v)]-&gt;(v) ]
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCommutative(B);</span>
false
</pre></div>

<p>Next we want to define a counit and a comultiplication on <span class="Math">B</span> to make it a bialgebroid. The following record will be used to define the counit of <span class="Math">B</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">counit := rec( a := 1, b := 1 );</span>
rec( a := 1, b := 1 )
</pre></div>

<p>We compute the tensor product <span class="Math">B \otimes_\mathbb{Q} B</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">B2 := B^2;</span>
Algebroid generated by the right quiver qxq(uu,uv,vu,vv)[\
ua:uu-&gt;uv,ub:uv-&gt;uu,va:vu-&gt;vv,vb:vv-&gt;vu,\
au:uu-&gt;vu,av:uv-&gt;vv,bu:vu-&gt;uu,bv:vv-&gt;uv]
</pre></div>

<p>The following record will be used to define the comultiplication <span class="Math">B \to B \otimes_{\mathbb{Q}} B</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">comult:= rec( a := PreCompose(B2.au, B2.va), b:= PreCompose(B2.bv, B2.ub) );</span>
rec( a := (uu)-[{ 1*(ua*av) }]-&gt;(vv), b := (vv)-[{ 1*(vb*bu) }]-&gt;(uu) )
</pre></div>

<p>We use the records counit and comult to equip <span class="Math">B</span> with the induced morphisms <span class="Math">B \to \mathbb{Q}</span> and <span class="Math">B \to B \otimes_{\mathbb{Q}} B</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AddBialgebroidStructure( B, counit, comult );</span>
Bialgebroid generated by the right quiver q(u,v)[a:u-&gt;v,b:v-&gt;u]
</pre></div>

<p>We extract comultiplication and counit from <span class="Math">B</span>. They are now functors.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">counit := Counit( B );</span>
Functor from finitely presented Bialgebroid generated by the right quiver
q(u,v)[a:u-&gt;v,b:v-&gt;u] -&gt; Algebra generated by the right quiver *(1)[]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">comult := Comultiplication( B );</span>
Functor from finitely presented Bialgebroid generated by the right quiver
q(u,v)[a:u-&gt;v,b:v-&gt;u] -&gt; Algebroid generated by the right quiver
qxq(uu,uv,vu,vv)[ua:uu-&gt;uv,ub:uv-&gt;uu,va:vu-&gt;vv,vb:vv-&gt;vu,\
au:uu-&gt;vu,av:uv-&gt;vv,bu:vu-&gt;uu,bv:vv-&gt;uv]
</pre></div>

<p>Apply comultiplication and counit.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ApplyFunctor( counit, B.u );</span>
&lt;(1)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ApplyFunctor( counit, B.v );</span>
&lt;(1)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ApplyFunctor( counit, IdentityMorphism( B.u ) );</span>
(1)-[1*(1)]-&gt;(1)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ApplyFunctor( counit, IdentityMorphism( B.v ) );</span>
(1)-[1*(1)]-&gt;(1)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ApplyFunctor( counit, B.a );</span>
(1)-[1*(1)]-&gt;(1)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ApplyFunctor( counit, B.b );</span>
(1)-[1*(1)]-&gt;(1)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ApplyFunctor( comult, B.u );</span>
&lt;(uu)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ApplyFunctor( comult, B.v );</span>
&lt;(vv)&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ApplyFunctor( comult, IdentityMorphism( B.u ) );</span>
(uu)-[{ 1*(uu) }]-&gt;(uu)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ApplyFunctor( comult, IdentityMorphism( B.v ) );</span>
(vv)-[{ 1*(vv) }]-&gt;(vv)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ApplyFunctor( comult, B.a );</span>
(uu)-[{ 1*(ua*av) }]-&gt;(vv)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ApplyFunctor( comult, B.b );</span>
(vv)-[{ 1*(vb*bu) }]-&gt;(uu)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCoassociative(B);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCocommutative(B);</span>
true
</pre></div>

<p><a id="X868B56CD7EE75283" name="X868B56CD7EE75283"></a></p>

<h4>3.3 <span class="Heading">Hopf algebra generated by group-like elements</span></h4>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">q := RightQuiver( "q(1)[g:1-&gt;1,h:1-&gt;1]" );</span>
q(1)[g:1-&gt;1,h:1-&gt;1]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Q := HomalgFieldOfRationals( );</span>
Q
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Qq := PathAlgebra( Q, q );</span>
Q * q
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">B := Algebroid( Qq, [ Qq.h * Qq.g - Qq.1, Qq.g * Qq.h - Qq.1 ] );</span>
Algebra generated by the right quiver q(1)[g:1-&gt;1,h:1-&gt;1]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">B2 := B^2;</span>
Algebra generated by the right quiver qxq(1x1)[1xg:1x1-&gt;1x1,
1xh:1x1-&gt;1x1,gx1:1x1-&gt;1x1,hx1:1x1-&gt;1x1]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">counit_rec := rec( g := 1, h := 1 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">comult_rec := rec( g := PreCompose( B2.1xg, B2.gx1 ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                   h := PreCompose( B2.1xh, B2.hx1 ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AddBialgebroidStructure( B, counit_rec, comult_rec );</span>
Bialgebra generated by the right quiver q(1)[g:1-&gt;1,h:1-&gt;1]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">counit := Counit( B );</span>
Functor from finitely presented Bialgebra generated by the right quiver
q(1)[g:1-&gt;1,h:1-&gt;1] -&gt; Algebra generated by the right quiver *(1)[]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">comult := Comultiplication( B );</span>
Functor from finitely presented Bialgebra generated by the right quiver
q(1)[g:1-&gt;1,h:1-&gt;1] -&gt; Algebra generated by the right quiver
qxq(1x1)[1xg:1x1-&gt;1x1,1xh:1x1-&gt;1x1,gx1:1x1-&gt;1x1,hx1:1x1-&gt;1x1]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">antipode_rec := rec( g := B.h, h := B.g );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AddAntipode(B, antipode_rec );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">B;</span>
Hopf algebra generated by the right quiver q(1)[g:1-&gt;1,h:1-&gt;1]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Antipode(B);</span>
Contravariant functor from finitely presented Hopf algebra generated by the
right quiver q(1)[g:1-&gt;1,h:1-&gt;1] -&gt; Hopf algebra generated by the
right quiver q(1)[g:1-&gt;1,h:1-&gt;1]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ApplyFunctor( counit, B.g );</span>
(1)-[1*(1)]-&gt;(1)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCommutative(B);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCounitary(B);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCocommutative(B);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsHopfAlgebroid(B);</span>
true
</pre></div>

<p><a id="X7B04AAC77CDF3568" name="X7B04AAC77CDF3568"></a></p>

<h4>3.4 <span class="Heading">Hopf algebra generated by a primitive element</span></h4>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"># Hopf algebra generated by a primitive element</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">q := RightQuiver( "q(1)[t:1-&gt;1]" );</span>
q(1)[t:1-&gt;1]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Q := HomalgFieldOfRationals( );</span>
Q
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Qq := PathAlgebra( Q, q );</span>
Q * q
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">B := Algebroid( Qq );</span>
Algebra generated by the right quiver q(1)[t:1-&gt;1]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Q = UnderlyingAlgebra( B );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">B2 := B^2;</span>
Algebra generated by the right quiver qxq(1x1)[1xt:1x1-&gt;1x1,tx1:1x1-&gt;1x1]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">B0 := B^0;</span>
Algebra generated by the right quiver *(1)[]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">counit_rec := rec( t := 0 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">comult_rec := rec( t := B2.1xt + B2.tx1 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AddBialgebroidStructure( B, counit_rec, comult_rec );</span>
Bialgebra generated by the right quiver q(1)[t:1-&gt;1]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">antipode_rec := rec( t:= -B.t );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AddAntipode(B, antipode_rec );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">counit := Counit( B );</span>
Functor from finitely presented Bialgebra generated by the right quiver
q(1)[t:1-&gt;1] -&gt; Algebra generated by the right quiver *(1)[]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">comult := Comultiplication( B );</span>
Functor from finitely presented Bialgebra generated by the right quiver
q(1)[t:1-&gt;1] -&gt;
Algebra generated by the right quiver qxq(1x1)[1xt:1x1-&gt;1x1,tx1:1x1-&gt;1x1]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">idB := IdentityFunctor(B);</span>
Identity functor of Algebra generated by the right quiver q(1)[t:1-&gt;1]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ApplyFunctor( comult, B.t );</span>
(1x1)-[{ 1*(tx1) + 1*(1xt) }]-&gt;(1x1)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ApplyFunctor( counit, B.t );</span>
(1)-[0]-&gt;(1)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCommutative(B);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCounitary(B);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCocommutative(B);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsHopfAlgebroid(B);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">BB := CategoryOfAlgebroidsObject(B);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCoassociative( BB );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCounitary( BB );</span>
true
</pre></div>

<p><a id="X8193250583CB118F" name="X8193250583CB118F"></a></p>

<h4>3.5 <span class="Heading">A non-counitary coalgebra</span></h4>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">q := RightQuiver( "q(1)[t:1-&gt;1]" );</span>
q(1)[t:1-&gt;1]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Q := HomalgFieldOfRationals( );</span>
Q
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Qq := PathAlgebra( Q, q );</span>
Q * q
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">B := Algebroid( Qq );</span>
Algebra generated by the right quiver q(1)[t:1-&gt;1]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">B2 := B^2;</span>
Algebra generated by the right quiver qxq(1x1)[1xt:1x1-&gt;1x1,tx1:1x1-&gt;1x1]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">B0 := B^0;</span>
Algebra generated by the right quiver *(1)[]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">counit_rec := rec( t := 0 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">comult_rec := rec( t := B2.1xt );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AddBialgebroidStructure( B, counit_rec, comult_rec );</span>
Bialgebra generated by the right quiver q(1)[t:1-&gt;1]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">antipode_rec := rec( t:= -B.t );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AddAntipode(B, antipode_rec );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">counit := Counit( B );</span>
Functor from finitely presented Bialgebra generated by the right quiver
q(1)[t:1-&gt;1] -&gt; Algebra generated by the right quiver *(1)[]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">comult := Comultiplication( B );</span>
Functor from finitely presented Bialgebra generated by the right quiver
q(1)[t:1-&gt;1] -&gt; Algebra generated by the right quiver
qxq(1x1)[1xt:1x1-&gt;1x1,tx1:1x1-&gt;1x1]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCommutative(B);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCoassociative(B);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCounitary(B);</span>
false
</pre></div>

<p><a id="X7B9F1F17869C5429" name="X7B9F1F17869C5429"></a></p>

<h4>3.6 <span class="Heading">Sweedlers 4-dimensional Hopf algebra</span></h4>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">q := RightQuiver( "q(1)[x:1-&gt;1,g:1-&gt;1]" );</span>
q(1)[x:1-&gt;1,g:1-&gt;1]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Q := HomalgFieldOfRationals( );</span>
Q
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Qq := PathAlgebra( Q, q );</span>
Q * q
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">H := Algebroid( Qq, [ Qq.g * Qq.g - Qq.1,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                    Qq.x * Qq.x,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                    Qq.x * Qq.g + Qq.g * Qq.x,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                    ] );</span>
Algebra generated by the right quiver q(1)[x:1-&gt;1,g:1-&gt;1]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">H2 := H^2;</span>
Algebra generated by the right quiver
qxq(1x1)[1xx:1x1-&gt;1x1,1xg:1x1-&gt;1x1,xx1:1x1-&gt;1x1,gx1:1x1-&gt;1x1]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">counit_rec := rec( x := 0,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                   g := 1</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">comult_rec := rec( g := PreCompose(H2.gx1, H2.1xg),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                   x := H2.1xx + PreCompose(H2.xx1, H2.1xg)</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AddBialgebroidStructure( H, counit_rec, comult_rec );</span>
Bialgebra generated by the right quiver q(1)[x:1-&gt;1,g:1-&gt;1]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">counit := Counit( H );</span>
Functor from finitely presented Bialgebra generated by the right quiver
q(1)[x:1-&gt;1,g:1-&gt;1] -&gt; Algebra generated by the right quiver *(1)[]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">comult := Comultiplication( H );</span>
Functor from finitely presented Bialgebra generated by the right quiver
q(1)[x:1-&gt;1,g:1-&gt;1] -&gt; Algebra generated by the right quiver
qxq(1x1)[1xx:1x1-&gt;1x1,1xg:1x1-&gt;1x1,xx1:1x1-&gt;1x1,gx1:1x1-&gt;1x1]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">antipode_rec := rec( g:= H.g,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                     x := - PreCompose( H.x, H.g )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                   );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AddAntipode(H, antipode_rec );</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">antipode := Antipode( H );</span>
Contravariant functor from finitely presented Hopf algebra generated
by the right quiver q(1)[x:1-&gt;1,g:1-&gt;1] -&gt; Hopf algebra generated
by the right quiver q(1)[x:1-&gt;1,g:1-&gt;1]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCommutative(H);</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ApplyFunctor(antipode, H.g);</span>
(1)-[{ 1*(g) }]-&gt;(1)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ApplyFunctor(antipode, H.x);</span>
(1)-[{ -1*(x*g) }]-&gt;(1)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsEqualForMorphisms(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        ApplyFunctor( antipode, H.x ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        -PreCompose( H.x, H.g ) );</span>
true
</pre></div>

<p>Verify that the antipode of <span class="Math">H</span> has order 4.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsEqualForMorphisms( ApplyFunctor( antipode, H.g ), H.g );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsEqualForMorphisms( ApplyFunctor( antipode, H.x ), H.x );</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsEqualForMorphisms( ApplyFunctor(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    PreCompose( [ antipode, antipode ] ), H.x ), H.x );</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsEqualForMorphisms( ApplyFunctor(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    PreCompose( [ antipode, antipode, antipode ] ), H.x ), H.x );</span>
false
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsEqualForMorphisms( ApplyFunctor(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    PreCompose( [ antipode, antipode, antipode, antipode ] ), H.x ), H.x );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCocommutative(H);</span>
false
</pre></div>

<p><a id="X86A2AE6E7C297595" name="X86A2AE6E7C297595"></a></p>

<h4>3.7 <span class="Heading">Homomorphism structure</span></h4>

<p>We perform simple computations with the Homomorphism structure of the Beilison quiver of the projective space of dimension 3.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">q := RightQuiver( "q(4)[\</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">x0:1-&gt;2,x1:1-&gt;2,x2:1-&gt;2,x3:1-&gt;2,\</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">y0:2-&gt;3,y1:2-&gt;3,y2:2-&gt;3,y3:2-&gt;3,\</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">z0:3-&gt;4,z1:3-&gt;4,z2:3-&gt;4,z3:3-&gt;4]" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Q := HomalgFieldOfRationals( );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Qq := PathAlgebra( Q, q );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Beilinson_P3 := Algebroid( Qq, </span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  [ Qq.x0 * Qq.y1 - Qq.x1 * Qq.y0,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    Qq.x0 * Qq.y2 - Qq.x2 * Qq.y0,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    Qq.x0 * Qq.y3 - Qq.x3 * Qq.y0,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    Qq.x1 * Qq.y2 - Qq.x2 * Qq.y1,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    Qq.x1 * Qq.y3 - Qq.x3 * Qq.y1,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    Qq.x2 * Qq.y3 - Qq.x3 * Qq.y2,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    Qq.y0 * Qq.z1 - Qq.y1 * Qq.z0,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    Qq.y0 * Qq.z2 - Qq.y2 * Qq.z0,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    Qq.y0 * Qq.z3 - Qq.y3 * Qq.z0,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    Qq.y1 * Qq.z2 - Qq.y2 * Qq.z1,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    Qq.y1 * Qq.z3 - Qq.y3 * Qq.z1,</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">    Qq.y2 * Qq.z3 - Qq.y3 * Qq.z2</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">  ]</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">objs := SetOfObjects( Beilinson_P3 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Length( objs ) = 4;</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">maps := SetOfGeneratingMorphisms( Beilinson_P3.1, Beilinson_P3.2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">maps = SetOfGeneratingMorphisms( Beilinson_P3, 1, 2 );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Length( maps ) = 4;</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ForAll( [ 0 .. 3 ], k -&gt;</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        Dimension( HomomorphismStructureOnObjects( objs[1], objs[1 + k] ) )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        = Binomial( 4 + k - 1, k )</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">alpha := Beilinson_P3.x0;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">beta := ( Beilinson_P3.z1 + Beilinson_P3.z2 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gamma := PreCompose( [ alpha, (Beilinson_P3.y1 - Beilinson_P3.y3), beta ] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">sol := SolveLinearSystemInAbCategory(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">               [ [ alpha ] ], [ [ beta ] ], [ gamma ] )[1];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCongruentForMorphisms( PreCompose( [ alpha, sol, beta ] ), gamma );</span>
true
</pre></div>

<p><a id="X7C0C87E4856062AF" name="X7C0C87E4856062AF"></a></p>

<h4>3.8 <span class="Heading">Algebroids over the integers</span></h4>

<p>We create an algebroid over <span class="Math">\mathbb{Q}</span> and its descent to <span class="Math">\mathbb{Z}</span> defined by basis paths.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">q := RightQuiver( "q(4)[a:1-&gt;2,b:1-&gt;3,c:3-&gt;4,d:2-&gt;4]" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Q := HomalgFieldOfRationals( );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Qq := PathAlgebra( Q, q );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Qq := Qq / [ Qq.a * Qq.d - Qq.b * Qq.c];;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">A_Q := Algebroid( Qq );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">A_Z := DescentToZDefinedByBasisPaths( A_Q );;</span>
</pre></div>

<p>We demonstrate the practical difference between the two algebroids by trying to solve one and the same linear system.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">alpha := 2 * A_Q.a;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">id := IdentityMorphism( A_Q.4 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gamma := PreCompose( A_Q.b, A_Q.c );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">sol := SolveLinearSystemInAbCategory( [ [ alpha ] ], [ [ id ] ], [ gamma ] );</span>
[ (2)-[{ 1/2*(d) }]-&gt;(4) ]
</pre></div>

<p>Thus, a solution exists over the rationals.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">alpha := 2 * A_Z.a;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">id := IdentityMorphism( A_Z.4 );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">gamma := PreCompose( A_Z.b, A_Z.c );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">sol := SolveLinearSystemInAbCategory( [ [ alpha ] ], [ [ id ] ], [ gamma ] );</span>
fail
</pre></div>

<p>No solution exists over the integers.</p>

<p><a id="X7C0BEF04853A376E" name="X7C0BEF04853A376E"></a></p>

<h4>3.9 <span class="Heading">Unitors</span></h4>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">q := LeftQuiver( "ql(u,v,w)[a:u-&gt;v,b:v-&gt;u,c:v-&gt;u,d:v-&gt;w]" );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Q := HomalgFieldOfRationals( );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">B := Algebroid( Q, q );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">B0 := B^0;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">lu := LeftUnitorAsFunctor(B);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ru := RightUnitorAsFunctor(B);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">lui := LeftUnitorInverseAsFunctor(B);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">rui := RightUnitorInverseAsFunctor(B);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AsCapCategory(Range(lu)) = B;</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AsCapCategory(Range(ru)) = B;</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AsCapCategory(Source(lu)) = TensorProductOnObjects( B0, B );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AsCapCategory(Source(ru)) = TensorProductOnObjects( B, B0 );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AsCapCategory(Source(lui)) = B;</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AsCapCategory(Source(rui)) = B;</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AsCapCategory(Range(lui)) = TensorProductOnObjects( B0, B );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AsCapCategory(Range(rui)) = TensorProductOnObjects( B, B0 );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">l := Concatenation( [</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">             List( SetOfObjects(B),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                   o -&gt; ApplyFunctor( PreCompose(lui, lu), o) = o and</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                   ApplyFunctor( PreCompose(rui, ru), o) = o ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">             List( SetOfGeneratingMorphisms(B),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                   m -&gt; ApplyFunctor( PreCompose(lui, lu), m) = m and</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                   ApplyFunctor( PreCompose(rui, ru), m) = m ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">             List( SetOfObjects(B^0 * B),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                   o -&gt; ApplyFunctor( PreCompose(lu, lui), o) = o ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">             List( SetOfGeneratingMorphisms(B^0 * B),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                   m -&gt; ApplyFunctor( PreCompose(lu, lui), m) = m)</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput"> ] );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">and_function := function(x,y) return x and y; end;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Iterated( l, and_function );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"># Consider B as an object in the category of algebroids over Q</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">BB := CategoryOfAlgebroidsObject(B);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">BB2 := TensorProductOnObjects(BB, BB);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">BB0 := TensorUnit( CapCategory( BB ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ru_as_functor := RightUnitor( BB );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">lu_as_functor := LeftUnitor( BB );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">rui_as_functor := RightUnitorInverse( BB );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">lui_as_functor := LeftUnitorInverse( BB );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCongruentForMorphisms( PreCompose( ru_as_functor, rui_as_functor ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        IdentityMorphism( TensorProductOnObjects( BB,  BB0 ) ) );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCongruentForMorphisms( PreCompose( lu_as_functor, lui_as_functor ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        IdentityMorphism( TensorProductOnObjects( BB0,  BB ) ) );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCongruentForMorphisms( PreCompose( rui_as_functor, ru_as_functor ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        IdentityMorphism( BB ) );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCongruentForMorphisms( PreCompose( lui_as_functor, lu_as_functor ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        IdentityMorphism( BB ) );</span>
true
</pre></div>

<p><a id="X7B34D0E6854E90C8" name="X7B34D0E6854E90C8"></a></p>

<h4>3.10 <span class="Heading">Associators</span></h4>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">q := RightQuiver( "q(1)[t:1-&gt;1]" );</span>
q(1)[t:1-&gt;1]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Q := HomalgFieldOfRationals( );</span>
Q
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Qq := PathAlgebra( Q, q );</span>
Q * q
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">B := Algebroid( Qq );</span>
Algebra generated by the right quiver q(1)[t:1-&gt;1]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ass_ltr := AssociatorLeftToRightWithGivenTensorProductsAsFunctor(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                   (B*B)*B, B, B, B, B*(B*B) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ass_rtl := AssociatorRightToLeftWithGivenTensorProductsAsFunctor(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">                   B*(B*B), B, B, B, (B*B)*B );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Source(ass_ltr) = Range(ass_rtl);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Range(ass_ltr) = Source(ass_rtl);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"># Consider B as an object in the category of algebroids over Q</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">BB := CategoryOfAlgebroidsObject(B);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">BB2 := TensorProductOnObjects(BB, BB);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">BB0 := TensorUnit( CapCategory( BB ) );;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ass_ltr_as_morphism := AssociatorLeftToRight(BB,BB,BB);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ass_rtl_as_morphism := AssociatorRightToLeft(BB,BB,BB);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCongruentForMorphisms(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        PreCompose( ass_ltr_as_morphism, ass_rtl_as_morphism ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        IdentityMorphism( Source( ass_ltr_as_morphism ) ) );</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsCongruentForMorphisms(</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        PreCompose( ass_rtl_as_morphism, ass_ltr_as_morphism ),</span>
<span class="GAPprompt">&gt;</span> <span class="GAPinput">        IdentityMorphism( Source( ass_rtl_as_morphism ) ) );</span>
true
</pre></div>


<div class="chlinkprevnextbot">&nbsp;<a href="chap0.html">[Top of Book]</a>&nbsp;  <a href="chap0.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap2.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap4.html">[Next Chapter]</a>&nbsp;  </div>


<div class="chlinkbot"><span class="chlink1">Goto Chapter: </span><a href="chap0.html">Top</a>  <a href="chap1.html">1</a>  <a href="chap2.html">2</a>  <a href="chap3.html">3</a>  <a href="chap4.html">4</a>  <a href="chapInd.html">Ind</a>  </div>

<hr />
<p class="foot">generated by <a href="http://www.math.rwth-aachen.de/~Frank.Luebeck/GAPDoc">GAPDoc2HTML</a></p>
</body>
</html>
