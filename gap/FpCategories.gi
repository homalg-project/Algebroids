# SPDX-License-Identifier: GPL-2.0-or-later
# Algebroids: Algebroids and bialgebroids as preadditive categories generated by enhanced quivers
#
# Implementations
#

####################################
#
# methods for attributes:
#
####################################

##
InstallMethod( Size,
        "for a f.p. category",
        [ IsFpCategory ],
        
  function( B )
    local kq;
    
    kq := UnderlyingQuiverAlgebra( B );
    
    if not IsFiniteDimensional( kq ) then
        return infinity;
    fi;
    
    return Dimension( kq );
    
end );

##
InstallMethod( AssignSetOfObjects,
        [ IsFpCategory, IsString ],
        
  function( A, label )
    local names, objects, func;
    
    names := List( Vertices( UnderlyingQuiver( A ) ), String );
    
    objects := SetOfObjects( A );
    
    func := function( name, o )
              
              if Int( name ) <> fail and label = "" then
                  Error( "The second argument should be a non-empty string" );
              fi;
              
              name := Concatenation( label, ReplacedString( name, "-", "m" ) );
              
              MakeReadWriteGlobal( name );
              
              DeclareSynonym( name, o );
              
              return 1;
              
            end;
            
    ListN( names, objects, func );
    
end );

##
InstallOtherMethod( AssignSetOfObjects,
        [ IsFpCategory and HasUnderlyingQuiver ],
  function( A )
  
    AssignSetOfObjects( A, "" );
    
end );

##
InstallMethodWithCache( SetOfGeneratingMorphisms,
        "for a f.p. category and two objects",
        [ IsFpCategory and HasUnderlyingQuiver, IsObjectInFpCategory, IsObjectInFpCategory ],
        
  { A, obj_1, obj_2 } -> Filtered( SetOfGeneratingMorphisms( A ), m -> IsEqualForObjects( obj_1, Source( m ) ) and IsEqualForObjects( obj_2, Target( m ) ) )
);

##
InstallMethod( SetOfGeneratingMorphisms,
        "for two objects in a f.p. category",
         [ IsObjectInFpCategory, IsObjectInFpCategory ],
         
  { obj_1, obj_2 } -> SetOfGeneratingMorphisms( CapCategory( obj_1 ), obj_1, obj_2 )
);

##
InstallMethodWithCache( SetOfGeneratingMorphisms,
        "for a f.p. category and two integers",
        [ IsFpCategory and HasUnderlyingQuiver, IsInt, IsInt ],
        
  { A, i, j } -> SetOfGeneratingMorphisms( A, SetOfObjects( A )[ i ], SetOfObjects( A )[ j ] )
);

##
InstallMethod( AssignSetOfGeneratingMorphisms,
        [ IsFpCategory, IsString ],
  function( A, label )
    local names, morphisms, func;
    
    names := List( Arrows( UnderlyingQuiver( A ) ), String );
    
    morphisms := SetOfGeneratingMorphisms( A );
    
    func := function( name, m )
              
              if Int( name ) <> fail and label = "" then
                  Error( "The second argument should be a non-empty string" );
              fi;
              
              name := Concatenation( label, ReplacedString( name, "-", "m" ) );
              
              MakeReadWriteGlobal( name );
              
              DeclareSynonym( name, m );
              
              return 1;
              
            end;
            
    ListN( names, morphisms, func );
    
end );

##
InstallOtherMethod( AssignSetOfGeneratingMorphisms,
        [ IsFpCategory and HasUnderlyingQuiver ],
  function( A )
    
    AssignSetOfGeneratingMorphisms( A, "" );
    
end );

##
InstallMethod( RelationsAmongGeneratingMorphisms,
        "for a f.p. category",
        [ IsFpCategory ],
        
  function( C )
    local relations, objs, mors, func;
    
    relations := RelationsOfFpCategory( C );
    
    if IsEmpty( relations ) then
        return [ ];
    fi;
    
    Assert( 0, IsQuotientOfPathAlgebra( UnderlyingQuiverAlgebra( C ) ) );
    
    objs := List( SetOfObjects( C ), UnderlyingVertex );
    
    mors := List( SetOfGeneratingMorphisms( C ), p -> BasisPathOfPathAlgebraBasisElement( UnderlyingQuiverAlgebraElement( p ) ) );
    
    func :=
      function( path )
        if IsQuiverVertex( path ) then
            return [ ];
        fi;
        
        return List( ArrowList( path ), g -> -1 + SafePosition( mors, g ) );
    end;
    
    return List( relations, pair -> Pair( func( pair[1] ), func( pair[2] ) ) );
    
end );

##
InstallMethod( IndicesOfGeneratingMorphisms,
        "for a f.p. category",
        [ IsFpCategory ],
        
  IndicesOfGeneratingMorphismsFromHomStructure );

##
InstallOtherMethodForCompilerForCAP( DecompositionIndicesOfMorphism,
        "for a f.p. category and a morphism therein",
        [ IsFpCategory, IsMorphismInFpCategory ],
        
  function( C, mor )
    local cmp, gmors;
    
    #% CAP_JIT_DROP_NEXT_STATEMENT
    if not IsIdenticalObj( C, CapCategory( mor ) ) then
        Error( "`mor` is not a morphism in the category `C`\n" );
    fi;
    
    if IsEqualToIdentityMorphism( C, mor ) then
        return CapJitTypedExpression( [ ], { } -> CapJitDataTypeOfListOf( IsInt ) );
    fi;
    
    cmp := DecomposeQuiverAlgebraElement( UnderlyingQuiverAlgebraElement( mor ) );
    
    #% CAP_JIT_DROP_NEXT_STATEMENT
    Assert( 0, ForAll( cmp[1], IsOne ) );
    
    #% CAP_JIT_DROP_NEXT_STATEMENT
    Assert( 0, Length( cmp[2] ) = 1 );
    
    #% CAP_JIT_DROP_NEXT_STATEMENT
    if ForAny( cmp[2][1], IsCapCategoryObject ) then
        Error( "one of the generating morphisms is an identity morphism\n" );
    fi;
    
    gmors := List( SetOfGeneratingMorphisms( C ), p -> BasisPathOfPathAlgebraBasisElement( UnderlyingQuiverAlgebraElement( p ) ) );
    
    return List( cmp[2][1], g -> -1 + SafePosition( gmors, g ) );
    
end );

##
InstallMethod( DecompositionIndicesOfMorphism,
        "for a morphism in a f.p. category",
        [ IsMorphismInFpCategory ],
        
  function( mor )
    
    return DecompositionIndicesOfMorphism( CapCategory( mor ), mor );
    
end );

##
InstallMethod( DecompositionOfMorphismInCategory,
        "for a morphism in a f.p. category",
        [ IsMorphismInFpCategory ],
        
  function( mor )
    local C;
    
    C := CapCategory( mor );
    
    return SetOfGeneratingMorphisms( C ){1 + DecompositionIndicesOfMorphism( mor )};
    
end );

##
InstallMethod( DecompositionIndicesOfAllMorphismsFromHomStructure,
        "for a f.p. category",
        [ IsFpCategory and IsFiniteCategory ],
        
  function( C )
    local objs;
    
    objs := SetOfObjects( C );
    
    return List( objs, t ->
                 List( objs, s ->
                       List( MorphismsOfExternalHom( C, s, t ), mor -> DecompositionIndicesOfMorphism( C, mor ) ) ) );
    
end );

##
InstallMethod( DecompositionIndicesOfAllMorphisms,
        "for a f.p. category",
        [ IsFpCategory and IsFiniteCategory ],
        
  DecompositionIndicesOfAllMorphismsFromHomStructure  );

##
InstallMethod( DataTablesOfCategory,
        "for a f.p. category",
        [ IsFpCategory ],
        
  function( C )
    
    return DataTablesOfCategory( CategoryFromNerveData( C : FinalizeCategory := true ) );
    
end );

####################################
#
# methods for constructors:
#
####################################

##
InstallGlobalFunction( ADD_FUNCTIONS_FOR_FP_CATEGORY,
  
  function( category )
    local quiver;
    
    ##
    AddObjectConstructor( category,
      function( category, v )
        
        return ObjectInFpCategory( category, v );
        
    end );
    
    ##
    AddObjectDatum( category,
      function( category, o )
        
        return UnderlyingVertex( o );
        
    end );
    
    ##
    AddMorphismConstructor( category,
      function( category, source, m, range )
        
        return MorphismInFpCategory( category, source, m, range );
        
    end );
    
    ##
    AddMorphismDatum( category,
      function( category, m )
        
        return UnderlyingQuiverAlgebraElement( m );
        
    end );
    
    ##
    AddSetOfObjectsOfCategory( category,
      function( category )
        
        return List( Vertices( UnderlyingQuiver( category ) ), o -> category.( String( o ) ) );

    end );
    
    ##
    AddSetOfGeneratingMorphismsOfCategory( category,
      function( category )
        
        return List( Arrows( UnderlyingQuiver( category ) ), o -> category.(String( o ) ) );
        
    end );
    
    ##
    AddIsWellDefinedForObjects( category,
      function( category, o )
        
        o := UnderlyingVertex( o );
        
        return IsQuiverVertex( o ) and IsIdenticalObj( QuiverOfPath( o ), UnderlyingQuiver( category ) );
        
    end );
    
    ##
    AddIsWellDefinedForMorphisms( category,
      function( category, alpha )
        local m, v, w;
        
        m := UnderlyingQuiverAlgebraElement( alpha );
        
        if not IsIdenticalObj( AlgebraOfElement( m ), UnderlyingQuiverAlgebra( category ) ) then
            
            return false;
            
        fi;
        
        if not IsUniform( m ) then
            
            return false;
            
        fi;
        
        if IsQuotientOfPathAlgebraElement( m ) then
            
            m := Representative( m );
            
        fi;
        
        if not Coefficients( m ) = [ 1 ] then
            
            return false;
            
        fi;
        
        v := Source( LeadingPath( m ) );
        
        if not ( UnderlyingVertex( Source( alpha ) ) = v ) then
            
            return false;
            
        fi;
        
        w := Target( LeadingPath( m ) );
        
        if not ( UnderlyingVertex( Target( alpha ) ) = w ) then
            
            return false;
            
        fi;
        
        # all tests passed, so it is well-defined
        return true;
        
    end );
    
    ##
    AddIsEqualForObjects( category,
      function( category, object_1, object_2 )
        
        return UnderlyingVertex( object_1 ) = UnderlyingVertex( object_2 );
        
    end );
    
    ##
    AddIsEqualForMorphisms( category,
      function( category, morphism_1, morphism_2 )
        
        return UnderlyingQuiverAlgebraElement( morphism_1 ) = UnderlyingQuiverAlgebraElement( morphism_2 );
        
    end );
    
    ##
    AddIsCongruentForMorphisms( category,
      function( category, morphism_1, morphism_2 )
        
        return UnderlyingQuiverAlgebraElement( morphism_1 ) = UnderlyingQuiverAlgebraElement( morphism_2 );
        
    end );
    
    ##
    AddIdentityMorphism( category,
      function( category, object )
        local quiver_algebra, id;
        
        quiver_algebra := UnderlyingQuiverAlgebra( category );
        
        id := PathAsAlgebraElement( quiver_algebra, QuiverVertexAsIdentityPath( UnderlyingVertex( object ) ) );
        
        return MorphismInFpCategory( category,
                       object,
                       id,
                       object );
        
    end );
    
    quiver := UnderlyingQuiver( category );
    
    if IsRightQuiver( quiver ) then
        
        ##
        AddPreCompose( category,
          function( category, morphism_1, morphism_2 )
            
            return MorphismInFpCategory( category,
                           Source( morphism_1 ),
                           UnderlyingQuiverAlgebraElement( morphism_1 ) * UnderlyingQuiverAlgebraElement( morphism_2 ),
                           Target( morphism_2 ) );
        end );
        
    else
        
        ##
        AddPreCompose( category,
          function( category, morphism_1, morphism_2 )
            
            return MorphismInFpCategory( category,
                           Source( morphism_1 ),
                           UnderlyingQuiverAlgebraElement( morphism_2 ) * UnderlyingQuiverAlgebraElement( morphism_1 ),
                           Target( morphism_2 ) );
            
        end );
        
    fi;
    
    ## only create the Hom-structure for finite dimensional quiver algebras
    if IsFiniteDimensional( UnderlyingQuiverAlgebra( category ) ) then
        
        ADD_FUNCTIONS_FOR_HOM_STRUCTURE_OF_FP_CATEGORY( category );
        
        #ADD_FUNCTIONS_FOR_RANDOM_METHODS_OF_FP_CATEGORY( category );
        
    fi;
    
    Finalize( category );
    
    return category;
    
end );

##
InstallMethodForCompilerForCAP( SetOfObjects,
        "for a f.p. category",
        [ IsFpCategory ],
        
  function( cat )
    
    return SetOfObjectsAsUnresolvableAttribute( cat );
    
end );

##
InstallMethodForCompilerForCAP( SetOfGeneratingMorphisms,
        "for a f.p. category",
        [ IsFpCategory ],
        
  function( cat )
    
    return SetOfGeneratingMorphismsAsUnresolvableAttribute( cat );
    
end );

##
InstallMethod( BasisPathOfPathAlgebraBasisElement,
        "for a quiver algebra element",
        [ IsQuiverAlgebraElement ],
        
  function( basis_element )
    local paths;
    
    paths := Paths( basis_element );
    
    Assert( 0, Length( paths ) = 1 and Coefficients( basis_element ) = [ 1 ] );
    
    return paths[1];
    
end );

##
InstallMethod( BasisPathOfPathAlgebraBasisElement,
        "for an element in a quotient of a path algebra",
        [ IsQuotientOfPathAlgebraElement ],
        
  function( basis_element )
    
    return BasisPathOfPathAlgebraBasisElement( Representative( basis_element ) );
    
end );

##
InstallGlobalFunction( ADD_FUNCTIONS_FOR_HOM_STRUCTURE_OF_FP_CATEGORY,
  function( fpcategory )
    local quiver_algebra, quiver, vertices, basis, basis_paths_by_vertex_index,
          basis_morphisms_by_vertex_index, path,
          MATRIX_FOR_HOMSTRUCTURE, hom_structure_on_basis_paths;
    
    quiver_algebra := UnderlyingQuiverAlgebra( fpcategory );
    
    ## Prepare quick access to basis elements
    quiver := QuiverOfAlgebra( quiver_algebra );
    
    vertices := Vertices( quiver );
    
    basis := BasisPaths( CanonicalBasis( quiver_algebra ) );
    
    ## prepare the homomorphism structure
    
    ## storing the basis paths
    ## basis_paths_by_vertex_index[ v_index ][ w_index ] = [ p_1:v -> w, p_2:v -> w, ... ]
    
    basis_paths_by_vertex_index := List( vertices, i -> List( vertices, i -> [ ] ) );
    
    basis_morphisms_by_vertex_index := List( vertices, i -> List( vertices, i -> [ ] ) );
    
    for path in basis do
        
        Add( basis_paths_by_vertex_index[ VertexIndex( Source( path ) ) ][ VertexIndex( Target( path ) ) ], path );
        
        Add( basis_morphisms_by_vertex_index[ VertexIndex( Source( path ) ) ][ VertexIndex( Target( path ) ) ], MorphismInFpCategory( fpcategory, PathAsAlgebraElement( quiver_algebra, path ) ) );
        
    od;
    
    # if `basis_paths_by_vertex_index` would be mutable, setting the attribute below would create an (immuatable) copy,
    # which would not be identical to `basis_paths_by_vertex_index` anymore
    MakeImmutable( basis_paths_by_vertex_index );
    
    SetBasisPathsByVertexIndex( fpcategory, basis_paths_by_vertex_index );
    
    Assert( 0, IsIdenticalObj( basis_paths_by_vertex_index, BasisPathsByVertexIndex( fpcategory ) ) );
    
    MakeImmutable( basis_morphisms_by_vertex_index );
    
    SetBasisMorphismsByVertexIndex( fpcategory, basis_morphisms_by_vertex_index );
    
    Assert( 0, IsIdenticalObj( basis_morphisms_by_vertex_index, BasisMorphismsByVertexIndex( fpcategory ) ) );
    
    ## precomputing matrices for the hom structure
    ## hom_structure_on_basis_paths[ v_index ][ w_index ][ v'_index ][ w'_index ][ basis_path_1_index ][ basis_path_2_index ] =
    ## [ Hom(v,w) -> Hom(v',w'): x -> basis_path_1 * x * basis_path_2 ]
    ## for basis_path_1: v' -> v and basis_path_2: w -> w'
    
    MATRIX_FOR_HOMSTRUCTURE := function( v, w, vp, wp, path_1, path_2 )
        local hom_v_w, hom_vp_wp, alpha, beta;
        
        hom_v_w := basis_paths_by_vertex_index[ VertexIndex( v ) ][ VertexIndex( w ) ];
        
        if IsEmpty( hom_v_w ) then
            
            return [  ];
            
        fi;
        
        hom_vp_wp := basis_paths_by_vertex_index[ VertexIndex( vp ) ][ VertexIndex( wp ) ];
        
        if IsEmpty( hom_vp_wp ) then
            
            return [  ];
            
        fi;
        
        alpha := PathAsAlgebraElement( quiver_algebra, path_1 );
        
        beta := PathAsAlgebraElement( quiver_algebra, path_2 );
        
        return List( hom_v_w, path -> -1 + SafePosition( hom_vp_wp, BasisPathOfPathAlgebraBasisElement( alpha * PathAsAlgebraElement( quiver_algebra, path ) * beta ) ) );
        
    end;
    
    hom_structure_on_basis_paths :=
        List( vertices, v ->
            List( vertices, w ->
                List( vertices, vp ->
                    List( vertices, wp ->
                        List( basis_paths_by_vertex_index[ VertexIndex( vp ) ][ VertexIndex( v ) ], basis_path_1 ->
                            List( basis_paths_by_vertex_index[ VertexIndex( w ) ][ VertexIndex( wp ) ], basis_path_2 ->
                                MATRIX_FOR_HOMSTRUCTURE( v, w, vp, wp, basis_path_1, basis_path_2 )
                            )
                        )
                    )
                )
            )
        );
    
    # if `hom_structure_on_basis_paths` would be mutable, setting the attribute below would create an (immuatable) copy, which would not be identical to `hom_structure_on_basis_paths` anymore
    MakeImmutable( hom_structure_on_basis_paths );
    
    SetHomStructureOnBasisPaths( fpcategory, hom_structure_on_basis_paths );
    
    Assert( 0, IsIdenticalObj( hom_structure_on_basis_paths, HomStructureOnBasisPaths( fpcategory ) ) );
    
    if IsSkeletalCategoryOfFiniteSets( RangeCategoryOfHomomorphismStructure( fpcategory ) ) then
        
        ##
        AddHomomorphismStructureOnObjects( fpcategory,
          function( fpcategory, object_1, object_2 )
            local nr_source, nr_range, basis_elements;
            
            nr_source := VertexIndex( UnderlyingVertex( object_1 ) );
            
            nr_range := VertexIndex( UnderlyingVertex( object_2 ) );
            
            basis_elements := BasisPathsByVertexIndex( fpcategory )[nr_source][nr_range];
            
            return ObjectConstructor( RangeCategoryOfHomomorphismStructure( fpcategory ), Length( basis_elements ) );
            
        end );
        
        ##
        AddHomomorphismStructureOnMorphismsWithGivenObjects( fpcategory,
          function( fpcategory, source, alpha, beta, range )
            local elem_alpha, elem_beta, a, b, ap, bp, basis_paths_by_vertex_index,
                  basis_ap_a, basis_b_bp, alpha_index, beta_index, hom_structure_on_basis_paths, map;
            
            elem_alpha := UnderlyingQuiverAlgebraElement( alpha );
            
            elem_beta := UnderlyingQuiverAlgebraElement( beta );
            
            a := VertexIndex( UnderlyingVertex( Target( alpha ) ) );
            
            b := VertexIndex( UnderlyingVertex( Source( beta ) ) );
            
            ap := VertexIndex( UnderlyingVertex( Source( alpha ) ) );
            
            bp := VertexIndex( UnderlyingVertex( Target( beta ) ) );
            
            basis_paths_by_vertex_index := BasisPathsByVertexIndex( fpcategory );
            
            basis_ap_a := basis_paths_by_vertex_index[ap][a];
            
            basis_b_bp := basis_paths_by_vertex_index[b][bp];
            
            alpha_index := SafePosition( basis_ap_a, BasisPathOfPathAlgebraBasisElement( elem_alpha ) );
            
            beta_index := SafePosition( basis_b_bp, BasisPathOfPathAlgebraBasisElement( elem_beta ) );
            
            ## hom_structure_on_basis_paths[ v_index ][ w_index ][ v'_index ][ w'_index ][ basis_path_1_index ][ basis_path_2_index ] =
            ## [ Hom(v,w) -> Hom(v',w'): x -> basis_path_1 * x * basis_path_2 ]
            ## for basis_path_1: v' -> v and basis_path_2: w -> w'
            hom_structure_on_basis_paths := HomStructureOnBasisPaths( fpcategory );
            
            map := List( [ 1 .. Length( basis_paths_by_vertex_index[a][b] ) ], phi_index ->
                         hom_structure_on_basis_paths[a][b][ap][bp][alpha_index][beta_index][phi_index] );
            
            return MorphismConstructor( RangeCategoryOfHomomorphismStructure( fpcategory ), source, map, range );
            
        end );
        
        ##
        AddDistinguishedObjectOfHomomorphismStructure( fpcategory,
          function( fpcategory )
            
            return TerminalObject( RangeCategoryOfHomomorphismStructure( fpcategory ) );
            
        end );
        
        ##
        AddInterpretMorphismAsMorphismFromDistinguishedObjectToHomomorphismStructure( fpcategory,
          function( fpcategory, alpha )
            local source, range, element, a, b, basis_elements;
            
            source := DistinguishedObjectOfHomomorphismStructure( fpcategory );
            range := HomomorphismStructureOnObjects( fpcategory, Source( alpha ), Target( alpha ) );
            
            element := UnderlyingQuiverAlgebraElement( alpha );
            
            a := VertexIndex( UnderlyingVertex( Source( alpha ) ) );
            
            b := VertexIndex( UnderlyingVertex( Target( alpha ) ) );
            
            basis_elements := BasisPathsByVertexIndex( fpcategory )[a][b];
            
            return MorphismConstructor( RangeCategoryOfHomomorphismStructure( fpcategory ),
                           source,
                           [ -1 + SafePosition( basis_elements, BasisPathOfPathAlgebraBasisElement( element ) ) ],
                           range );
            
        end );
        
        ##
        AddInterpretMorphismFromDistinguishedObjectToHomomorphismStructureAsMorphism( fpcategory,
          function( fpcategory, a, b, morphism )
            local basis, element;
            
            basis := BasisPathsByVertexIndex( fpcategory )[VertexIndex( UnderlyingVertex( a ) )][VertexIndex( UnderlyingVertex( b ) )];
            
            element := QuiverAlgebraElement( quiver_algebra, [ 1 ], basis{[ 1 + AsList( morphism )[1] ]} );
            
            return MorphismInFpCategory( fpcategory, a, element, b );
            
        end );
        
    fi;
    
end );

##
InstallMethodWithCache( Category,
        "for a QPA quiver algebra and a CAP category",
        [ IsQuiverAlgebra, IsCapCategory ],
        
  function( A, range_category_of_HomStructure )
    local domain, parity, quiver, C, relations, rels;
    
    domain := LeftActingDomain( A );
    
    if IsRightQuiverAlgebra( A ) then
        parity := "Right";
    else
        parity := "Left";
    fi;
    
    quiver := QuiverOfAlgebra( A );
    
    C := "FreeCategory( ";
    
    C := Concatenation( C, parity, "Quiver( \"", String( quiver ), "\" ) )" );
    
    relations := CAP_INTERNAL_RETURN_OPTION_OR_DEFAULT( "relations", [ ] );
    
    if not relations = [ ] then
        
        if Length( relations ) < 6 then
            
            rels := Concatenation(
                            " [",
                            JoinStringsWithSeparator( List( relations, a -> Concatenation( " ", String( a[1] ), " = ", String( a[2] ) ) ) ),
                            " ]" );
            
            C := Concatenation( C, " /", rels );
            
        else
            
            C := Concatenation( C, " / relations" );
            
        fi;
        
    elif not IsPathAlgebra( A ) then
        
        C := Concatenation( C, " / relations" );
        
    fi;
    
    C := CreateCapCategoryWithDataTypes( C,
                 IsFpCategory,
                 IsObjectInFpCategory,
                 IsMorphismInFpCategory,
                 IsCapCategoryTwoCell,
                 IsQuiverVertex,
                 IsQuiverAlgebraElement,
                 fail );
    
    C!.relations := relations;
    
    SetDefiningTripleOfUnderlyingQuiver( C, DefiningTripleOfAQuiver( quiver ) );
    
    DeactivateCachingOfCategory( C );
    CapCategorySwitchLogicOff( C );
    DisableSanityChecks( C );
    
    SetIsFinitelyPresentedCategory( C, true );
    SetUnderlyingQuiver( C, quiver );
    SetUnderlyingAlgebra( C, domain );
    SetParity( C, parity );
    
    SetUnderlyingQuiverAlgebra( C, A );
    if Length( Vertices( quiver ) ) = 1 then
        SetFilterObj( C, IsMonoidAsCategory );
        if Length( Arrows( quiver ) ) <= 1 then
            SetIsCommutative( C, true );
        fi;
    fi;
    
    SetIsFiniteCategory( C, IsFiniteDimensional( A ) );
    
    if IsFiniteCategory( C ) then
        SET_RANGE_CATEGORY_Of_HOMOMORPHISM_STRUCTURE( C, range_category_of_HomStructure );
    fi;
    
    C!.Vertices := rec( );
    C!.Arrows := rec( );
    
    C!.compiler_hints :=
      rec( category_attribute_names :=
           [ "SetOfObjectsAsUnresolvableAttribute",
             "SetOfGeneratingMorphismsAsUnresolvableAttribute",
             "UnderlyingQuiver",
             "UnderlyingQuiverAlgebra",
             "BasisPathsByVertexIndex",
             "BasisMorphismsByVertexIndex",
             "HomStructureOnBasisPaths",
             "DefiningTripleOfUnderlyingQuiver",
             ],
           );
    
    return ADD_FUNCTIONS_FOR_FP_CATEGORY( C );
    
end );

##
InstallMethod( Category,
        "for a QPA quiver algebra",
        [ IsQuiverAlgebra ],
        
  function( A )
    
    return Category( A, CAP_INTERNAL_RETURN_OPTION_OR_DEFAULT( "range_of_HomStructure", SkeletalFinSets ) );
    
end );

##
InstallMethod( Category,
        "for a QPA path algebra and a list",
        [ IsPathAlgebra, IsList ],
        
  function( Qq, L )
    local relations, A, C;
    
    if not ( IsList( L ) and
             ForAll( L, IsList ) and
             ForAll( L, a -> Length( a ) = 2 ) and
             ForAll( L, a -> ForAll( a, IsPath ) ) ) then
        
        Error( "the relations should be given as a list of pairs of paths\n" );
        
    fi;
    
    relations := List( L, a -> PathAsAlgebraElement( Qq, a[1] ) - PathAsAlgebraElement( Qq, a[2] ) );
    
    A := Qq / Ideal( Qq, relations );
    
    A := Qq / GroebnerBasis( IdealOfQuotient( A ) );
    
    C := Category( A : relations := L );
    
    SetRelationsOfFpCategory( C, L );
    
    return C;
    
end );

##
InstallMethod( Category,
        "for a QPA quiver",
        [ IsQuiver, IsList ],
        
  function( quiver, L )
    local A;
    
    A := PathAlgebra( ALGEBROIDS.ring, quiver );
    
    SetRingFilter( A, IsQuiverAlgebra );
    SetRingElementFilter( A, IsQuiverAlgebraElement );
    
    return Category( A, L );
    
end );

##
InstallMethod( QuotientCategory,
        "for a f.p. category and a list",
        [ IsFpCategory and HasUnderlyingQuiver, IsList ],
        
  function( C, L )
    local relations, f;
    
    if HasRelationsOfFpCategory( C ) then
        relations := ShallowCopy( RelationsOfFpCategory( C ) );
    else
        relations := [ ];
    fi;
    
    f :=
      function( p )
        if IsObjectInFpCategory( p ) then
            return UnderlyingVertex( p );
        fi;
        return BasisPathOfPathAlgebraBasisElement( UnderlyingQuiverAlgebraElement( p ) );
    end;
    
    Append( relations, List( L, a -> List( a, f ) ) );
    
    return Category( UnderlyingQuiver( C ), relations );
    
end );

##
InstallMethod( \/,
        "for a f.p. category and a list",
        [ IsFpCategory and HasUnderlyingQuiver, IsList ],
        
  function( C, L )
    
    return QuotientCategory( C, L );
    
end );

##
InstallMethod( FreeCategory,
        "for a QPA quiver",
        [ IsQuiver ],
        
  function( quiver )
    
    return Category( quiver, [ ] );
    
end );

##
InstallMethod( Multiplication,
        "for a commutative algebra as cateogry",
        [ IsMonoidAsCategory and IsCommutative ],
        
  function( A )
    local unique_object_in_A, unique_object_in_A_string,
          morphisms_in_A, A2, unique_object_in_A2, unique_object_in_A2_string,
          mult_functor_images_of_objects, mult_functor_images_of_generating_morphisms,
          a, b, axg, axg_string, fxb, fxb_string, mult_functor, g, f;

    unique_object_in_A := SetOfObjects( A )[1];
    unique_object_in_A_string := String( UnderlyingVertex( unique_object_in_A ) );
    morphisms_in_A := SetOfGeneratingMorphisms(A);

    A2 := A*A;
    
    unique_object_in_A2 := SetOfObjects( A2 )[1];
    unique_object_in_A2_string := String( UnderlyingVertex( unique_object_in_A2 ) );
    
    mult_functor_images_of_objects := rec( );
    mult_functor_images_of_objects.(unique_object_in_A2_string) := unique_object_in_A;

    mult_functor_images_of_generating_morphisms := rec(); # FIXME

    a := unique_object_in_A;
    b := unique_object_in_A;

    for g in morphisms_in_A do

        axg := ElementaryTensor( a, g, A2 );
        axg_string := String( LeadingPath( Representative( UnderlyingQuiverAlgebraElement( axg ) ) ) );

        mult_functor_images_of_generating_morphisms.(axg_string) := g;

    od;

    for f in morphisms_in_A do

        fxb := ElementaryTensor( f, b, A2 );
        fxb_string := String( LeadingPath( Representative( UnderlyingQuiverAlgebraElement( fxb ) ) ) );

        mult_functor_images_of_generating_morphisms.(fxb_string) := f;

    od;
    
    mult_functor := CapFunctor( A2, mult_functor_images_of_objects, mult_functor_images_of_generating_morphisms );
    
    return mult_functor;

end );

##
InstallMethod( Unit,
        "for algebra as category",
        [ IsMonoidAsCategory ],
        
  function( A )
    
    local unique_object_in_A, unique_object_in_A_string,
          unique_object_in_A0, unique_object_in_A0_string,
          unit_functor_images_of_objects, unit_functor_images_of_generating_morphisms, A0;
    
    unique_object_in_A := SetOfObjects( A )[1];
    unique_object_in_A_string := String( UnderlyingVertex( unique_object_in_A ) );
    
    A0 := A^0;
    
    unique_object_in_A0 := SetOfObjects( A0 )[1];
    unique_object_in_A0_string := String( UnderlyingVertex( unique_object_in_A0 ) );
    
    unit_functor_images_of_objects := rec( );
    unit_functor_images_of_objects.(unique_object_in_A0_string) := unique_object_in_A;
    
    unit_functor_images_of_generating_morphisms := rec( );
    
    return CapFunctor( A0, unit_functor_images_of_objects, unit_functor_images_of_generating_morphisms );
    
end );

##
InstallMethodForCompilerForCAP( ObjectInFpCategory,
         "for a f.p. category and a vertex of a quiver",
        [ IsFpCategory, IsQuiverVertex ],
        
  function( C, v )
    local name, o;
    
    #% CAP_JIT_DROP_NEXT_STATEMENT
    Assert( 0, IsIdenticalObj( UnderlyingQuiver( C ), QuiverOfPath( v ) ) );
    
    #% CAP_JIT_DROP_NEXT_STATEMENT
    name := String( v );
    
    #% CAP_JIT_DROP_NEXT_STATEMENT
    if IsBound( C!.Vertices.(name) ) then
        return C!.Vertices.(name);
    fi;
    
    o := CreateCapCategoryObjectWithAttributes( C,
                 UnderlyingVertex, v );
    
    #% CAP_JIT_DROP_NEXT_STATEMENT
    SetLabel( o, name );
    
    #% CAP_JIT_DROP_NEXT_STATEMENT
    C!.Vertices.(name) := o;
    
    return o;
    
end );

##
InstallOtherMethod( \/,
        [ IsQuiverVertex, IsFpCategory ],
        
  { v, C } -> ObjectInFpCategory( C, v )
);

##
InstallOtherMethodForCompilerForCAP( MorphismInFpCategory,
        "for a f.p. category, two objects in a f.p. category, and an element of the quiver algebra",
        [ IsFpCategory, IsObjectInFpCategory, IsQuiverAlgebraElement, IsObjectInFpCategory ],
        
  function( B, S, path, T )
    local l;
    
    #% CAP_JIT_DROP_NEXT_STATEMENT
    Assert( 0, IsIdenticalObj( UnderlyingQuiver( B ), QuiverOfAlgebra( AlgebraOfElement( path ) ) ) );
    
    if IsZero( path ) then
        Error( "the quiver algebra element ", path, " is zero\n" );
    fi;
        
    if not IsUniform( path ) then
        Error( "the quiver algebra element ", path, " is neither zero nor uniform\n" );
    fi;
    
    #% CAP_JIT_DROP_NEXT_STATEMENT
    if IsPathAlgebraElement( path ) then
        l := LeadingPath( path );
        
        if not ( Source( l ) = UnderlyingVertex( S ) ) and not ( Target( l ) = UnderlyingVertex( T ) ) then
            Error( "the path algebra element ", path, " does not match the given source S and it does not match the given target T\n" );
        elif not ( Source( l ) = UnderlyingVertex( S ) ) then
            Error( "the path algebra element ", path, " does not match the given source S\n" );
        elif not ( Target( l ) = UnderlyingVertex( T ) ) then
            Error( "the path algebra element ", path, " does not match the given target T\n" );
        fi;
    fi;
    
    if not IsIdenticalObj( CapCategory(S), CapCategory(T) ) then
        Error( "source and target do not belong to the same category");
    fi;
    
    return CreateCapCategoryMorphismWithAttributes( B,
                   S,
                   T,
                   UnderlyingQuiverAlgebraElement, path );
    
end );

##
InstallMethod( MorphismInFpCategory,
        "for two objects in a f.p. category and an element of the quiver algebra",
        [ IsObjectInFpCategory, IsQuiverAlgebraElement, IsObjectInFpCategory ],
        
  function( S, path, T )
    
    return MorphismInFpCategory( CapCategory( S ), S, path, T );
    
end );

##
InstallMethod( MorphismInFpCategory,
        "for a f.p. category and an element of a path algebra",
        [ IsFpCategory, IsPathAlgebraElement ],
        
  function( C, path )
    local l, S, T;
    
    if IsZero( path ) then
        Error( "the path algebra element ", path, " is a zero path\n" );
    elif not IsUniform( path ) then
        Error( "the path algebra element ", path, " is not uniform\n" );
    elif not Coefficients( path ) = [ 1 ] then
        Error( "the path algebra element ", path, " is not a path\n" );
    fi;
    
    l := LeadingPath( path );
    
    S := String( Source( l ) );
    T := String( Target( l ) );
    
    return MorphismInFpCategory( C, C.(S), path, C.(T) );
    
end );

##
InstallMethod( \.,
        "for a f.p. category and a positive integer",
        [ IsFpCategory, IsPosInt ],
        
  function( C, string_as_int )
    local name, q, a, b;
    
    name := NameRNam( string_as_int );
    
    q := UnderlyingQuiver( C );
    
    a := q.(name);
    
    if IsQuiverVertex( a ) then
        if IsBound( C!.Vertices.(name) ) then
            return C!.Vertices.(name);
        fi;
        b := ObjectInFpCategory( C, a );
    elif IsArrow( a ) or IsCompositePath( a ) then
        if IsBound( C!.Arrows.(name) ) then
            return C!.Arrows.(name);
        fi;
        b := MorphismInFpCategory(
                     C.(String( Source( a ) ) ),
                     PathAsAlgebraElement( UnderlyingQuiverAlgebra( C ), a ),
                     C.(String( Target( a ) ) ) );
        SetLabel( b, name );
        C!.Arrows.(name) := b;
    else
        Error( "the given component ", name, " is neither a vertex nor an arrow of the quiver q = ", q, "\n" );
    fi;
    
    return b;
    
end );

##
InstallMethod( MorphismInFpCategory,
        "for a f.p. category and an element of a quotient of a path algebra",
        [ IsFpCategory, IsQuotientOfPathAlgebraElement ],
        
  function( A, path )
    local l, S, T;
    
    if IsZero( path ) then
        Error( "source and target of the zero path is ambiguous\n" );
    elif not IsUniform( path ) then
        Error( "the quiver algebra element ", path, " is not uniform\n" );
    fi;
    
    l := LeadingPath( Representative( path ) );
    
    S := String( Source( l ) );
    T := String( Target( l ) );
    
    return MorphismInFpCategory( A, A.(S), path, A.(T) );
    
end );

##
InstallMethod( MorphismInFpCategory,
        "for a f.p. category and a path",
        [ IsFpCategory, IsPath ],
        
  function( C, path )
    
    path := PathAsAlgebraElement( UnderlyingQuiverAlgebra( C ), path );
    
    return MorphismInFpCategory( C, path );
    
end );

##
InstallOtherMethod( \/,
        [ IsPath, IsFpCategory ],
        
  function( path, C )
    
    return MorphismInFpCategory( C, path );
    
end );

##
InstallMethod( POW,
        "for a f.p. category and an integer",
        [ IsFpCategory and HasUnderlyingQuiverAlgebra, IsInt ],
        
  function( C, n )
    local Qq, R, parity;
    
    if n < 0 then
        Error( "the only admissible values for n are non-negative integers\n" );
    elif n = 1 then
        return C;
    elif not IsBound( C!.powers ) then
        C!.powers := rec( );
    fi;
    
    Qq := UnderlyingQuiverAlgebra( C );
    
    R := LeftActingDomain( Qq );
    
    if n = 0 then
        
        if not IsBound( C!.powers.0 ) then
            
            if IsRightQuiverAlgebra( Qq ) then
                parity := "Right";
            else
                parity := "Reft";
            fi;
            
            C!.powers.0 := TrivialCategory( parity );
            
        fi;
        
        return C!.powers.0;
        
    fi;
    
    C!.powers.1 := C;
    
    if not IsBound( C!.powers.(n) ) then
        if not IsBound( C!.powers.(n-1) ) then
            C!.powers.(n-1) := C^(n-1);
        fi;
        
        C!.powers.(n) := C!.powers.(n-1) * C;
        
        C!.powers.(n)!.PowerOf := C;
        
    fi;
    
    return C!.powers.(n);
    
end );

##
InstallMethod( TrivialCategory,
        "for a string",
        [ IsString ],
        
  function( parity )
    local trivial_quiver;
   
    if parity = "Right" then
        trivial_quiver := RightQuiver( "*(1)[]" );
    elif parity = "Left" then
        trivial_quiver := LeftQuiver( "*(1)[]" );
    else
        Error( "parity must be either \"Left\" or \"Right\"" );
    fi;
    
    return FreeCategory( trivial_quiver );
end );

##
InstallMethod( ElementaryTensor,
        "for objects in categorys",
        [ IsObjectInFpCategory, IsObjectInFpCategory, IsFpCategory ],
        
  function( a, b, T )
      
    local product_string, a_string, b_string, product_vertex;
  
    product_vertex := PathInProductQuiver( QuiverOfAlgebra( UnderlyingQuiverAlgebra( T ) ), [ UnderlyingVertex( a ), UnderlyingVertex( b ) ] );
    product_string := String(product_vertex);
  
    return T.(product_string);

end );

##
InstallMethod( ElementaryTensor,
        "for object and morphism in categorys",
        [ IsObjectInFpCategory, IsMorphismInFpCategory, IsFpCategory ],
        
  function( object, morphism, T )
    local source, range, morphism_as_quiver_algebra_element, path,
          object_underlying_vertex, object_string, mors, o;
    
    source := ElementaryTensor( object, Source( morphism ), T );
    range := ElementaryTensor( object, Target( morphism ), T );
    
    morphism_as_quiver_algebra_element := UnderlyingQuiverAlgebraElement( morphism );
    
    path := BasisPathOfPathAlgebraBasisElement( morphism_as_quiver_algebra_element );
    
    object_underlying_vertex := UnderlyingVertex( object );
    object_string := String( object_underlying_vertex );
    
    mors := List( List( ArrowList( path ),
                    b -> PathInProductQuiver( QuiverOfAlgebra( UnderlyingQuiverAlgebra( T ) ), [ object_underlying_vertex, b ] ) ),
                  b -> MorphismInFpCategory(
                          ObjectInFpCategory( T, Source( b ) ),
                          QuiverAlgebraElement( UnderlyingQuiverAlgebra( T ), [ 1 ], [ b ] ),
                          ObjectInFpCategory( T, Target( b ) ) ) );
    
    if Length( mors ) = 0 then
        
        Assert( 3, IsQuiverVertex( path ) );
        
        o := ObjectInFpCategory( CapCategory( morphism ), path );
        
        Assert( 3, o = Source( morphism ) and o = Target( morphism ) );
        
        return IdentityMorphism( ElementaryTensor( object, o, T ) );
        
    fi;
    
    return PreCompose( mors );
    
end );

##
InstallMethod( ElementaryTensor,
        "for morphism and object in categorys",
        [ IsMorphismInFpCategory, IsObjectInFpCategory, IsFpCategory ],
        
  function( morphism, object, T )
    local source, range, morphism_as_quiver_algebra_element, path,
          object_underlying_vertex, object_string, mors, o;
    
    source := ElementaryTensor( Source( morphism ), object, T );
    range := ElementaryTensor( Target( morphism ), object, T );
    
    morphism_as_quiver_algebra_element := UnderlyingQuiverAlgebraElement( morphism );
    
    path := BasisPathOfPathAlgebraBasisElement( morphism_as_quiver_algebra_element );
    
    object_underlying_vertex := UnderlyingVertex( object );
    object_string := String( object_underlying_vertex );
    
    mors := List( List( ArrowList( path ),
                    a -> PathInProductQuiver( QuiverOfAlgebra( UnderlyingQuiverAlgebra( T ) ), [ a, object_underlying_vertex ] ) ),
                  a -> MorphismInFpCategory(
                          ObjectInFpCategory( T, Source( a ) ),
                          QuiverAlgebraElement( UnderlyingQuiverAlgebra( T ), [ 1 ], [ a ] ),
                          ObjectInFpCategory( T, Target( a ) ) ) );
    
    if Length( mors ) = 0 then
        
        Assert( 3, IsQuiverVertex( path ) );
        
        o := ObjectInFpCategory( CapCategory( morphism ), path );
        
        Assert( 3, o = Source( morphism ) and o = Target( morphism ) );
        
        return IdentityMorphism( ElementaryTensor( o, object, T ) );
        
    fi;
    
    return PreCompose( mors );
    
end );

##
InstallMethod( QuiverVertexAsIdentityPath,
        [ IsQuiverVertex ],
        
  function( vertex )
    
    # interpreted as its identity path
    return vertex;
    
end );

##
InstallMethod( \*,
        "for two categorys",
        [ IsFpCategory and HasUnderlyingQuiverAlgebra, IsFpCategory and HasUnderlyingQuiverAlgebra ],
        
  function( A, B )

    return Category( TensorProductOfAlgebras( UnderlyingQuiverAlgebra( A ), UnderlyingQuiverAlgebra( B ) ) );
    
end );

##
InstallMethod( CapFunctor,
        "for a f.p. category, two lists, a CAP Category, and a boolean",
        [ IsFpCategory, IsList, IsList, IsCapCategory, IsBool ],
        
  function( A, images_of_objects, images_of_generating_morphisms, B, covariant )
    local kq, vertices, arrows, functor, func_obj, func_mor;
    
    kq := QuiverOfAlgebra( UnderlyingQuiverAlgebra( A ) );
    
    vertices := Vertices( kq );
    arrows := Arrows( kq );
    
    functor := Concatenation( "Functor from ", Name( A ), " -> ", Name( B ) );
    
    functor := CapFunctor( functor, A, B );
    
    functor!.ValuesOnAllObjects := images_of_objects;
    functor!.ValuesOnAllGeneratingMorphisms := images_of_generating_morphisms;
    
    functor!.IsContravariant := not covariant;
    
    DeactivateCachingObject( ObjectCache( functor ) );
    DeactivateCachingObject( MorphismCache( functor ) );
    
    AddObjectFunction( functor,
      function( obj )
        local i;
        
        i := SafePosition( vertices, UnderlyingVertex( obj ) );
        
        if IsInt( i ) then
            return images_of_objects[i];
        fi;
        
        Error( "vertex UnderlyingVertex( obj ) = ", UnderlyingVertex( obj ), " not found in the list ", vertices, " of vertices\n" );
        
    end );

    func_obj := o -> images_of_objects[SafePosition( vertices, o )];
    func_mor := a -> images_of_generating_morphisms[SafePosition( arrows, a )];
    
    if covariant then
        
        AddMorphismFunction( functor,
          function( new_source, mor, new_range )
            local i;
            
            mor := UnderlyingQuiverAlgebraElement( mor );
            
            i := Position( arrows, mor );
            
            if IsInt( i ) then
                return images_of_generating_morphisms[i];
            fi;
            
            return ApplyToQuiverAlgebraElement( func_obj, func_mor, B, mor, true );
            
        end );
        
    else
        
        AddMorphismFunction( functor,
          function( new_source, mor, new_range )
            local i;
            
            mor := UnderlyingQuiverAlgebraElement( mor );
            
            i := Position( arrows, mor );
            
            if IsInt( i ) then
                return images_of_objects[i];
            fi;
            
            return ApplyToQuiverAlgebraElement( func_obj, func_mor, B, mor, false );
            
        end );
        
    fi;
    
    return functor;
    
end );

##
InstallMethod( CapFunctor,
        "for a f.p. category, two lists, and a CAP category",
        [ IsFpCategory, IsList, IsList, IsCapCategory ],
        
  function( A, images_of_objects, images_of_generating_morphisms, B )
    
    return CapFunctor( A, images_of_objects, images_of_generating_morphisms, B, true );
    
end );

## this a convenience method
InstallMethod( CapFunctor,
        "for a f.p. category, two records, and a boolean",
        [ IsFpCategory, IsRecord, IsRecord, IsBool ],
        
  function( A, rec_images_of_objects, rec_images_of_generating_morphisms, covariant )
    local kq, vertices, images_of_objects, arrows, images_of_generating_morphisms,
          mor, Qq, B;
    
    kq := QuiverOfAlgebra( UnderlyingQuiverAlgebra( A ) );
    
    vertices := Vertices( kq );
    
    images_of_objects := List( vertices, v -> rec_images_of_objects.(String( v ) ) );
    
    if images_of_objects = [ ] then
        Error( "the record rec_images_of_objects does not contain a named image of an object in the source category A\n" );
    fi;
    
    arrows := Arrows( kq );
    
    images_of_generating_morphisms := List( arrows, a -> rec_images_of_generating_morphisms.(String( a ) ) );
    
    # Construct the target category B
    if not IsEmpty( images_of_generating_morphisms ) then
        for mor in images_of_generating_morphisms do
            if IsQuiverAlgebraElement( mor ) then
                Qq := AlgebraOfElement( mor );
                B := Category( Qq );
                break;
            elif IsCapCategoryCell( mor ) then
                if not IsCapCategoryMorphism( mor ) then
                    Error( Concatenation( "the image ", mor, " is not a morphism"));
                fi;
                B := CapCategory( mor );
                break;
            fi;
        od;
    else
        B := CapCategory( images_of_objects[1] );
    fi;
    
    if not IsBound( B ) then
        Error( "unable to extract target category from the records of images\n" );
    fi;
    
    return CapFunctor( A, images_of_objects, images_of_generating_morphisms, B, covariant );
    
end );

## this a convenience method
InstallMethod( CapFunctor,
        "for a f.p. category and two records",
        [ IsFpCategory, IsRecord, IsRecord ],
        
  function( A, rec_images_of_objects, rec_images_of_generating_morphisms )
    
    return CapFunctor( A, rec_images_of_objects, rec_images_of_generating_morphisms, true );
    
end );

##
InstallMethod( CapFunctor,
        "for a f.p. category and a CAP category object",
        [ IsFpCategory, IsCapCategoryObject ],
        
  function( A, object )
    
    return CapFunctor(
                   A,
                   ListWithIdenticalEntries( Length( SetOfObjects( A ) ), object ),
                   ListWithIdenticalEntries( Length( SetOfGeneratingMorphisms( A ) ), IdentityMorphism( object ) ),
                   CapCategory( object ) );
    
end );

##
InstallMethod( OppositeFpCategory,
        "for a f.p. category",
        [ IsFpCategory and HasRelationsOfFpCategory ],
        
  function( C )
    local relations, range_category, C_op;
    
    relations := RelationsOfFpCategory( C );
    
    relations := List( relations, a -> List( a, OppositePath ) );
    
    if HasRangeCategoryOfHomomorphismStructure( C ) then
        range_category := RangeCategoryOfHomomorphismStructure( C );
    else
        range_category := fail;
    fi;
    
    C_op := Category(
                    OppositeQuiver( UnderlyingQuiver( C ) ),
                    relations : range_of_HomStructure := range_category );
    
    SetOppositeFpCategory( C_op, C );
    
    return C_op;
    
end );

##
InstallMethod( CategoryFromNerveData,
        "for a f.p. category",
        [ IsFpCategory ],
        
  function( C )
    
    return CategoryFromNerveData(
                   rec( name := Name( C ),
                        nerve_data := NerveTruncatedInDegree2Data( C ),
                        indices_of_generating_morphisms := IndicesOfGeneratingMorphismsFromHomStructure( C ),
                        decomposition_of_all_morphisms := DecompositionIndicesOfAllMorphismsFromHomStructure( C ),
                        relations := RelationsAmongGeneratingMorphisms( C ),
                        labels := [ List( SetOfObjects( C ), Label ), List( SetOfGeneratingMorphisms( C ), Label ) ],
                        properties := ListKnownCategoricalProperties( C ) ) );
    
end );

##
InstallMethod( SieveFunctor,
        [ IsFpCategory ],
        
  function ( B )
    local Sieves, Bop, sFinSets;
    
    # asserts that IsSkeletalCategoryOfFiniteSets( RangeCategoryOfHomomorphismStructure( B ) )
    Sieves := TruthMorphismOfTrueToSieveFunctorAndEmbedding( B );
    
    Bop := OppositeFpCategory( B );
    
    sFinSets := RangeCategoryOfHomomorphismStructure( B );
    
    return CapFunctor( Bop, Sieves[1][1], Sieves[1][2], sFinSets );
    
end );

##
InstallMethod( TruthMorphismOfTrueToSieveFunctor,
        [ IsFpCategory ],
        
  function ( B )
    local Sieves, Bop, sFinSets, Constant_functor, Sieves_maximal, Sieves_functor;
    
    # asserts that IsSkeletalCategoryOfFiniteSets( RangeCategoryOfHomomorphismStructure( B ) )
    Sieves := TruthMorphismOfTrueToSieveFunctorAndEmbedding( B );
    
    Bop := OppositeFpCategory( B );
    
    sFinSets := RangeCategoryOfHomomorphismStructure( B );
    
    Constant_functor := CapFunctor( Bop, Sieves[2][1], Sieves[2][2], sFinSets );
    Sieves_maximal := Sieves[4];
    Sieves_functor := SieveFunctor( B );
    
    ## T → Sieves, c ↦ ( T(c) = {*} → Sieves(c), * ↦ maximal_sieve(c) := Hom(-, c) )
    return NaturalTransformation(
                   Constant_functor,
                   Sieves_maximal,
                   Sieves_functor );
    
end );

##
InstallMethod( EmbeddingOfSieveFunctor,
        [ IsFpCategory ],
        
  function ( B )
    local Sieves, Bop, sFinSets, Sieves_functor, Sieves_emb, HomHomOmega_functor;
    
    # asserts that IsSkeletalCategoryOfFiniteSets( RangeCategoryOfHomomorphismStructure( B ) )
    Sieves := TruthMorphismOfTrueToSieveFunctorAndEmbedding( B );
    
    Bop := OppositeFpCategory( B );
    
    sFinSets := RangeCategoryOfHomomorphismStructure( B );
    
    Sieves_functor := SieveFunctor( B );
    Sieves_emb := Sieves[5];
    HomHomOmega_functor := CapFunctor( Bop, Sieves[3][1], Sieves[3][2], sFinSets );
    
    ## Sieves → Hom(Hom(-, c), Ω), c ↦ ( Sieves(c) ↪ Hom(Hom(-, c), Ω), s ↦ s )
    return NaturalTransformation(
                   Sieves_functor,
                   Sieves_emb,
                   HomHomOmega_functor );
    
end );

####################################
#
# methods for properties:
#
####################################

##
InstallMethod( IsCommutative,
        "for an FpCategory",
        [ IsFpCategory ],
     
  function( A )
    local arrows, i, j;
    
    arrows := Arrows( UnderlyingQuiverAlgebra( A ) );
    
    for i in [ 1 .. Length( arrows ) ] do
      for j in [ (i+1) .. Length( arrows ) ] do
        if not arrows[i] * arrows[j] = arrows[j] * arrows[i] then
          return false;
        fi;
      od;
    od;
    
    return true;
    
end );

####################################
#
# View, Print, and Display methods:
#
####################################

##
InstallMethod( ViewString,
        "for an object in a f.p. category",
        [ IsObjectInFpCategory ],
        
  function( o )
    
    return Concatenation( "<", StringView( UnderlyingVertex( o ) ), ">" );
    
end );

##
InstallMethod( ViewObj,
        "for a morphism in a f.p. category",
        [ IsMorphismInFpCategory ],
        
  function( m )
    
    if IsRightQuiverAlgebra( UnderlyingQuiverAlgebra( CapCategory( m ) ) ) then
        ViewObj( UnderlyingVertex( Source( m ) ) );
        Print( "-[" );
        ViewObj( BasisPathOfPathAlgebraBasisElement( UnderlyingQuiverAlgebraElement( m ) ) );
        Print( "]->" );
        ViewObj( UnderlyingVertex( Target( m ) ) );
    else
        ViewObj( UnderlyingVertex( Target( m ) ) );
        Print( "<-[" );
        ViewObj( BasisPathOfPathAlgebraBasisElement( UnderlyingQuiverAlgebraElement( m ) ) );
        Print( "]-" );
        ViewObj( UnderlyingVertex( Source( m ) ) );
    fi;
    
end );

##
InstallMethod( PrintObj,
        "for an object in a f.p. category",
        [ IsObjectInFpCategory ],
        
  function( o )
    
    ViewObj( o );
    
end );

##
InstallMethod( PrintObj,
        "for a morphism in a f.p. category",
        [ IsMorphismInFpCategory ],
        
  function( m )
    
    ViewObj( m );
    
end );

##
InstallMethod( Display,
        "for an object in a f.p. category",
        [ IsObjectInFpCategory ],
        
  function( o )
    
    ViewObj( o );
    Print( "\n" );
    
end );

##
InstallMethod( Display,
        "for a morphism in a f.p. category",
        [ IsMorphismInFpCategory ],
        
  function( m )
    
    ViewObj( m );
    Print( "\n" );
    
end );

##
InstallMethod( LaTeXOutput,
          [ IsObjectInFpCategory ],
          
  o -> LaTeXStringForQPA( UnderlyingVertex( o ) )
);

##
InstallMethod( LaTeXOutput,
          [ IsMorphismInFpCategory ],
          
  function( m )
    local s;
    
    s := LaTeXStringForQPA( UnderlyingQuiverAlgebraElement( m ) );
    
    if ValueOption( "OnlyDatum" ) = true then
      
      return s;
      
    else
      
      return Concatenation(
                "{", LaTeXOutput( Source( m ) ), "}-\\left(",
                "{", s, "}\\right)\\rightarrow",
                "{", LaTeXOutput( Target( m ) ), "}"
              );
              
    fi;
    
end );
