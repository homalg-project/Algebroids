# SPDX-License-Identifier: GPL-2.0-or-later
# Algebroids: Algebroids and bialgebroids as preadditive categories generated by enhanced quivers
#
# Implementations
#

####################################
#
# methods for attributes:
#
####################################

##
InstallMethod( Size,
        "for a f.p. category",
        [ IsFpCategory ],
        
  function( B )
    local kq;
    
    kq := UnderlyingQuiverAlgebra( B );
    
    if not IsFiniteDimensional( kq ) then
        return infinity;
    fi;
    
    return Dimension( kq );
    
end );

##
InstallMethod( SetOfObjects,
        "for a f.p. category",
        [ IsFpCategory and HasUnderlyingQuiver ],
        
  A -> List( Vertices( UnderlyingQuiver( A ) ), o -> A.( String( o ) ) ) );

##
InstallOtherMethod( SetOfObjects,
        "for an initial category",
        [ IsCapCategory and IsInitialCategory ],
        
  A -> [ ] );

##
InstallMethod( AssignSetOfObjects,
        [ IsFpCategory and HasUnderlyingQuiver, IsString ],
        
  function( A, label )
    local names, objects, func;
    
    names := List( Vertices( UnderlyingQuiver( A ) ), String );
    
    objects := SetOfObjects( A );
    
    func := function( name, o )
              
              if Int( name ) <> fail and label = "" then
                  Error( "The second argument should be a non-empty string" );
              fi;
              
              name := Concatenation( label, ReplacedString( name, "-", "m" ) );
              
              MakeReadWriteGlobal( name );
              
              DeclareSynonym( name, o );
              
              return 1;
              
            end;
            
    ListN( names, objects, func );
    
end );

##
InstallOtherMethod( AssignSetOfObjects,
        [ IsFpCategory and HasUnderlyingQuiver ],
  function( A )
  
    AssignSetOfObjects( A, "" );
    
end );

##
InstallMethodForCompilerForCAP( SetOfMorphisms,
        "for a category from data tables",
        [ IsFpCategory and IsFinite ],
        
  function( C )
    local objs;
    
    objs := SetOfObjects( C );
    
    ## varying the target (column-index) before varying the source ("row"-index)
    ## in the for-loops below is enforced by SetOfMorphisms for IsCategoryFromNerveData,
    ## which in turn is enforced by our convention for ProjectionInFactorOfDirectProduct in SkeletalFinSets,
    ## which is the "double-reverse" convention of the GAP command Cartesian:
    
    # gap> A := FinSet( 3 );
    # |3|
    # gap> B := FinSet( 4 );
    # |4|
    # gap> data := List( [ A, B ], AsList );
    # [ [ 0 .. 2 ], [ 0 .. 3 ] ]
    # gap> pi1 := ProjectionInFactorOfDirectProduct( [ A, B ], 1 );
    # |12| → |3|
    # gap> pi2 := ProjectionInFactorOfDirectProduct( [ A, B ], 2 );
    # |12| → |4|
    # gap> List( [ 0 .. 11 ], i -> [ pi1(i), pi2(i) ] );
    # [ [ 0, 0 ], [ 1, 0 ], [ 2, 0 ], [ 0, 1 ], [ 1, 1 ], [ 2, 1 ], [ 0, 2 ], [ 1, 2 ], [ 2, 2 ], [ 0, 3 ], [ 1, 3 ], [ 2, 3 ] ]
    # gap> List( Cartesian( Reversed( data ) ), Reversed );
    # [ [ 0, 0 ], [ 1, 0 ], [ 2, 0 ], [ 0, 1 ], [ 1, 1 ], [ 2, 1 ], [ 0, 2 ], [ 1, 2 ], [ 2, 2 ], [ 0, 3 ], [ 1, 3 ], [ 2, 3 ] ]
    # gap> L1 = L2;
    # true
    # gap> Cartesian( data );
    # [ [ 0, 0 ], [ 0, 1 ], [ 0, 2 ], [ 0, 3 ], [ 1, 0 ], [ 1, 1 ], [ 1, 2 ], [ 1, 3 ], [ 2, 0 ], [ 2, 1 ], [ 2, 2 ], [ 2, 3 ] ]
    # gap> L1 = L3;
    # false
    
    return Concatenation( List( objs, t ->
                   Concatenation( List( objs, s ->
                           MorphismsOfExternalHom( C, s, t ) ) ) ) );
    
end );

##
InstallMethod( SetOfGeneratingMorphisms,
        "for a f.p. category",
        [ IsFpCategory and HasUnderlyingQuiver ],
        
  A -> List( Arrows( UnderlyingQuiver( A ) ), o -> A.(String( o ) ) ) );

##
InstallOtherMethod( SetOfGeneratingMorphisms,
        "for an initial category",
        [ IsCapCategory and IsInitialCategory ],
        
  A -> [ ] );

##
InstallMethodWithCache( SetOfGeneratingMorphisms,
        "for a f.p. category and two objects",
        [ IsFpCategory and HasUnderlyingQuiver, IsObjectInFpCategory, IsObjectInFpCategory ],
        
  { A, obj_1, obj_2 } -> Filtered( SetOfGeneratingMorphisms( A ), m -> IsEqualForObjects( obj_1, Source( m ) ) and IsEqualForObjects( obj_2, Range( m ) ) )
);

##
InstallMethod( SetOfGeneratingMorphisms,
        "for two objects in a f.p. category",
         [ IsObjectInFpCategory, IsObjectInFpCategory ],
         
  { obj_1, obj_2 } -> SetOfGeneratingMorphisms( CapCategory( obj_1 ), obj_1, obj_2 )
);

##
InstallMethodWithCache( SetOfGeneratingMorphisms,
        "for a f.p. category and two integers",
        [ IsFpCategory and HasUnderlyingQuiver, IsInt, IsInt ],
        
  { A, i, j } -> SetOfGeneratingMorphisms( A, SetOfObjects( A )[ i ], SetOfObjects( A )[ j ] )
);

##
InstallMethod( AssignSetOfGeneratingMorphisms,
        [ IsFpCategory and HasUnderlyingQuiver, IsString ],
  function( A, label )
    local names, morphisms, func;
    
    names := List( Arrows( UnderlyingQuiver( A ) ), String );
    
    morphisms := SetOfGeneratingMorphisms( A );
    
    func := function( name, m )
              
              if Int( name ) <> fail and label = "" then
                  Error( "The second argument should be a non-empty string" );
              fi;
              
              name := Concatenation( label, ReplacedString( name, "-", "m" ) );
              
              MakeReadWriteGlobal( name );
              
              DeclareSynonym( name, m );
              
              return 1;
              
            end;
            
    ListN( names, morphisms, func );
    
end );

##
InstallOtherMethod( AssignSetOfGeneratingMorphisms,
        [ IsFpCategory and HasUnderlyingQuiver ],
  function( A )
    
    AssignSetOfGeneratingMorphisms( A, "" );
    
end );

##
InstallMethod( RelationsAmongGeneratingMorphisms,
        "for a f.p. category",
        [ IsFpCategory ],
        
  function( C )
    local relations, objs, mors, func;
    
    relations := RelationsOfFpCategory( C );
    
    if IsEmpty( relations ) then
        return [ ];
    fi;
    
    Assert( 0, IsQuotientOfPathAlgebra( UnderlyingQuiverAlgebra( C ) ) );
    
    objs := List( SetOfObjects( C ), UnderlyingVertex );
    
    mors := List( SetOfGeneratingMorphisms( C ), p -> BasisPathOfPathAlgebraBasisElement( UnderlyingQuiverAlgebraElement( p ) ) );
    
    func :=
      function( path )
        if IsQuiverVertex( path ) then
            return [ ];
        fi;
        
        return List( ArrowList( path ), g -> -1 + SafePosition( mors, g ) );
    end;
    
    return List( relations, pair -> Pair( func( pair[1] ), func( pair[2] ) ) );
    
end );

##
InstallMethod( IndicesOfGeneratingMorphisms,
        "for a f.p. category",
        [ IsFpCategory ],
        
  IndicesOfGeneratingMorphismsFromHomStructure );

##
InstallMethod( DecompositionOfMorphismInCategory,
        "for a morphism in a f.p. category",
        [ IsMorphismInFpCategory ],
        
  function( mor )
    local C, gmors;
    
    if IsEqualToIdentityMorphism( mor ) then
        return [ ];
    fi;
    
    C := CapCategory( mor );
    
    mor := UnderlyingQuiverAlgebraElement( mor );
    
    mor := DecomposeQuiverAlgebraElement( mor );
    
    Assert( 0, ForAll( mor[1], IsOne ) );
    
    Assert( 0, Length( mor[2] ) = 1 );
    
    mor := mor[2][1];
    
    if ForAny( mor, IsCapCategoryObject ) then
        Error( "one of the generating morphisms is an identity morphism\n" );
    fi;
    
    gmors := List( SetOfGeneratingMorphisms( C ), p -> BasisPathOfPathAlgebraBasisElement( UnderlyingQuiverAlgebraElement( p ) ) );
    
    return List( mor, g -> -1 + SafePosition( gmors, g ) );
    
end );

##
InstallMethod( DecompositionOfAllMorphismsFromHomStructure,
        "for a f.p. category",
        [ IsFpCategory and IsFinite ],
        
  function( C )
    local objs;
    
    objs := SetOfObjects( C );
    
    return List( objs, t ->
                 List( objs, s ->
                       List( MorphismsOfExternalHom( C, s, t ), DecompositionOfMorphismInCategory ) ) );
    
end );

##
InstallMethod( DecompositionOfAllMorphisms,
        "for a f.p. category",
        [ IsFpCategory and IsFinite ],
        
  DecompositionOfAllMorphismsFromHomStructure  );

##
InstallMethod( DataTablesOfCategory,
        "for a f.p. category",
        [ IsFpCategory ],
        
  function( C )
    
    return DataTablesOfCategory( CategoryFromNerveData( C : FinalizeCategory := true ) );
    
end );

####################################
#
# methods for constructors:
#
####################################

##
InstallGlobalFunction( ADD_FUNCTIONS_FOR_FP_CATEGORY,
  
  function( category )
    local quiver;
    
    ##
    AddObjectConstructor( category,
      function( category, v )
        
        return ObjectInFpCategory( category, v );
        
    end );
    
    ##
    AddObjectDatum( category,
      function( category, o )
        
        return UnderlyingVertex( o );
        
    end );
    
    ##
    AddMorphismConstructor( category,
      function( category, source, m, range )
        
        return MorphismInFpCategory( category, source, m, range );
        
    end );
    
    ##
    AddMorphismDatum( category,
      function( category, m )
        
        return UnderlyingQuiverAlgebraElement( m );
        
    end );
    
    ##
    AddIsWellDefinedForObjects( category,
      function( category, o )
        
        o := UnderlyingVertex( o );
        
        return IsQuiverVertex( o ) and IsIdenticalObj( QuiverOfPath( o ), UnderlyingQuiver( category ) );
        
    end );
    
    ##
    AddIsWellDefinedForMorphisms( category,
      function( category, alpha )
        local m, v, w;
        
        m := UnderlyingQuiverAlgebraElement( alpha );
        
        if not IsIdenticalObj( AlgebraOfElement( m ), UnderlyingQuiverAlgebra( category ) ) then
            
            return false;
            
        fi;
        
        if not IsUniform( m ) then
            
            return false;
            
        fi;
        
        if IsQuotientOfPathAlgebraElement( m ) then
            
            m := Representative( m );
            
        fi;
        
        if not Coefficients( m ) = [ 1 ] then
            
            return false;
            
        fi;
        
        v := Source( LeadingPath( m ) );
        
        if not ( UnderlyingVertex( Source( alpha ) ) = v ) then
            
            return false;
            
        fi;
        
        w := Target( LeadingPath( m ) );
        
        if not ( UnderlyingVertex( Range( alpha ) ) = w ) then
            
            return false;
            
        fi;
        
        # all tests passed, so it is well-defined
        return true;
        
    end );
    
    ##
    AddIsEqualForObjects( category,
      function( category, object_1, object_2 )
        
        return UnderlyingVertex( object_1 ) = UnderlyingVertex( object_2 );
        
    end );
    
    ##
    AddIsEqualForMorphisms( category,
      function( category, morphism_1, morphism_2 )
        
        return UnderlyingQuiverAlgebraElement( morphism_1 ) = UnderlyingQuiverAlgebraElement( morphism_2 );
        
    end );
    
    ##
    AddIsCongruentForMorphisms( category,
      function( category, morphism_1, morphism_2 )
        
        return UnderlyingQuiverAlgebraElement( morphism_1 ) = UnderlyingQuiverAlgebraElement( morphism_2 );
        
    end );
    
    ##
    AddIdentityMorphism( category,
      function( category, object )
        local quiver_algebra, id;
        
        quiver_algebra := UnderlyingQuiverAlgebra( category );
        
        id := PathAsAlgebraElement( quiver_algebra, QuiverVertexAsIdentityPath( UnderlyingVertex( object ) ) );
        
        return MorphismInFpCategory( category,
                       object,
                       id,
                       object );
        
    end );
    
    quiver := UnderlyingQuiver( category );
    
    if IsRightQuiver( quiver ) then
        
        ##
        AddPreCompose( category,
          function( category, morphism_1, morphism_2 )
            
            return MorphismInFpCategory( category,
                           Source( morphism_1 ),
                           UnderlyingQuiverAlgebraElement( morphism_1 ) * UnderlyingQuiverAlgebraElement( morphism_2 ),
                           Range( morphism_2 ) );
        end );
        
    else
        
        ##
        AddPreCompose( category,
          function( category, morphism_1, morphism_2 )
            
            return MorphismInFpCategory( category,
                           Source( morphism_1 ),
                           UnderlyingQuiverAlgebraElement( morphism_2 ) * UnderlyingQuiverAlgebraElement( morphism_1 ),
                           Range( morphism_2 ) );
            
        end );
        
    fi;
    
    ## only create the Hom-structure for finite dimensional quiver algebras
    if IsFiniteDimensional( UnderlyingQuiverAlgebra( category ) ) then
        
        ADD_FUNCTIONS_FOR_HOM_STRUCTURE_OF_FP_CATEGORY( category );
        
        #ADD_FUNCTIONS_FOR_RANDOM_METHODS_OF_FP_CATEGORY( category );
        
    fi;
    
    Finalize( category );
    
    return category;
    
end );

##
InstallMethod( BasisPathOfPathAlgebraBasisElement,
        "for a quiver algebra element",
        [ IsQuiverAlgebraElement ],
        
  function( basis_element )
    local paths;
    
    paths := Paths( basis_element );
    
    Assert( 0, Length( paths ) = 1 and Coefficients( basis_element ) = [ 1 ] );
    
    return paths[1];
    
end );

##
InstallMethod( BasisPathOfPathAlgebraBasisElement,
        "for an element in a quotient of a path algebra",
        [ IsQuotientOfPathAlgebraElement ],
        
  function( basis_element )
    
    return BasisPathOfPathAlgebraBasisElement( Representative( basis_element ) );
    
end );

##
InstallGlobalFunction( ADD_FUNCTIONS_FOR_HOM_STRUCTURE_OF_FP_CATEGORY,
  function( fpcategory )
    local quiver_algebra, quiver, vertices, basis, basis_paths_by_vertex_index,
          basis_morphisms_by_vertex_index, path,
          MATRIX_FOR_HOMSTRUCTURE, hom_structure_on_basis_paths;
    
    quiver_algebra := UnderlyingQuiverAlgebra( fpcategory );
    
    ## Prepare quick access to basis elements
    quiver := QuiverOfAlgebra( quiver_algebra );
    
    vertices := Vertices( quiver );
    
    basis := BasisPaths( CanonicalBasis( quiver_algebra ) );
    
    ## prepare the homomorphism structure
    
    ## storing the basis paths
    ## basis_paths_by_vertex_index[ v_index ][ w_index ] = [ p_1:v -> w, p_2:v -> w, ... ]
    
    basis_paths_by_vertex_index := List( vertices, i -> List( vertices, i -> [ ] ) );
    
    basis_morphisms_by_vertex_index := List( vertices, i -> List( vertices, i -> [ ] ) );
    
    for path in basis do
        
        Add( basis_paths_by_vertex_index[ VertexIndex( Source( path ) ) ][ VertexIndex( Target( path ) ) ], path );
        
        Add( basis_morphisms_by_vertex_index[ VertexIndex( Source( path ) ) ][ VertexIndex( Target( path ) ) ], MorphismInFpCategory( fpcategory, PathAsAlgebraElement( quiver_algebra, path ) ) );
        
    od;
    
    # if `basis_paths_by_vertex_index` would be mutable, setting the attribute below would create an (immuatable) copy,
    # which would not be identical to `basis_paths_by_vertex_index` anymore
    MakeImmutable( basis_paths_by_vertex_index );
    
    SetBasisPathsByVertexIndex( fpcategory, basis_paths_by_vertex_index );
    
    Assert( 0, IsIdenticalObj( basis_paths_by_vertex_index, BasisPathsByVertexIndex( fpcategory ) ) );
    
    MakeImmutable( basis_morphisms_by_vertex_index );
    
    SetBasisMorphismsByVertexIndex( fpcategory, basis_morphisms_by_vertex_index );
    
    Assert( 0, IsIdenticalObj( basis_morphisms_by_vertex_index, BasisMorphismsByVertexIndex( fpcategory ) ) );
    
    ## precomputing matrices for the hom structure
    ## hom_structure_on_basis_paths[ v_index ][ w_index ][ v'_index ][ w'_index ][ basis_path_1_index ][ basis_path_2_index ] =
    ## [ Hom(v,w) -> Hom(v',w'): x -> basis_path_1 * x * basis_path_2 ]
    ## for basis_path_1: v' -> v and basis_path_2: w -> w'
    
    MATRIX_FOR_HOMSTRUCTURE := function( v, w, vp, wp, path_1, path_2 )
        local hom_v_w, hom_vp_wp, alpha, beta;
        
        hom_v_w := basis_paths_by_vertex_index[ VertexIndex( v ) ][ VertexIndex( w ) ];
        
        if IsEmpty( hom_v_w ) then
            
            return [  ];
            
        fi;
        
        hom_vp_wp := basis_paths_by_vertex_index[ VertexIndex( vp ) ][ VertexIndex( wp ) ];
        
        if IsEmpty( hom_vp_wp ) then
            
            return [  ];
            
        fi;
        
        alpha := PathAsAlgebraElement( quiver_algebra, path_1 );
        
        beta := PathAsAlgebraElement( quiver_algebra, path_2 );
        
        return List( hom_v_w, path -> -1 + SafePosition( hom_vp_wp, BasisPathOfPathAlgebraBasisElement( alpha * PathAsAlgebraElement( quiver_algebra, path ) * beta ) ) );
        
    end;
    
    hom_structure_on_basis_paths :=
        List( vertices, v ->
            List( vertices, w ->
                List( vertices, vp ->
                    List( vertices, wp ->
                        List( basis_paths_by_vertex_index[ VertexIndex( vp ) ][ VertexIndex( v ) ], basis_path_1 ->
                            List( basis_paths_by_vertex_index[ VertexIndex( w ) ][ VertexIndex( wp ) ], basis_path_2 ->
                                MATRIX_FOR_HOMSTRUCTURE( v, w, vp, wp, basis_path_1, basis_path_2 )
                            )
                        )
                    )
                )
            )
        );
    
    # if `hom_structure_on_basis_paths` would be mutable, setting the attribute below would create an (immuatable) copy, which would not be identical to `hom_structure_on_basis_paths` anymore
    MakeImmutable( hom_structure_on_basis_paths );
    
    SetHomStructureOnBasisPaths( fpcategory, hom_structure_on_basis_paths );
    
    Assert( 0, IsIdenticalObj( hom_structure_on_basis_paths, HomStructureOnBasisPaths( fpcategory ) ) );
    
    if IsCategoryOfSkeletalFinSets( RangeCategoryOfHomomorphismStructure( fpcategory ) ) then
        
        ##
        AddHomomorphismStructureOnObjects( fpcategory,
          function( fpcategory, object_1, object_2 )
            local nr_source, nr_range, basis_elements;
            
            nr_source := VertexIndex( UnderlyingVertex( object_1 ) );
            
            nr_range := VertexIndex( UnderlyingVertex( object_2 ) );
            
            basis_elements := BasisPathsByVertexIndex( fpcategory )[nr_source][nr_range];
            
            return ObjectConstructor( RangeCategoryOfHomomorphismStructure( fpcategory ), Length( basis_elements ) );
            
        end );
        
        ##
        AddHomomorphismStructureOnMorphismsWithGivenObjects( fpcategory,
          function( fpcategory, source, alpha, beta, range )
            local elem_alpha, elem_beta, a, b, ap, bp, basis_paths_by_vertex_index,
                  basis_ap_a, basis_b_bp, alpha_index, beta_index, hom_structure_on_basis_paths, map;
            
            elem_alpha := UnderlyingQuiverAlgebraElement( alpha );
            
            elem_beta := UnderlyingQuiverAlgebraElement( beta );
            
            a := VertexIndex( UnderlyingVertex( Range( alpha ) ) );
            
            b := VertexIndex( UnderlyingVertex( Source( beta ) ) );
            
            ap := VertexIndex( UnderlyingVertex( Source( alpha ) ) );
            
            bp := VertexIndex( UnderlyingVertex( Range( beta ) ) );
            
            basis_paths_by_vertex_index := BasisPathsByVertexIndex( fpcategory );
            
            basis_ap_a := basis_paths_by_vertex_index[ap][a];
            
            basis_b_bp := basis_paths_by_vertex_index[b][bp];
            
            alpha_index := SafePosition( basis_ap_a, BasisPathOfPathAlgebraBasisElement( elem_alpha ) );
            
            beta_index := SafePosition( basis_b_bp, BasisPathOfPathAlgebraBasisElement( elem_beta ) );
            
            ## hom_structure_on_basis_paths[ v_index ][ w_index ][ v'_index ][ w'_index ][ basis_path_1_index ][ basis_path_2_index ] =
            ## [ Hom(v,w) -> Hom(v',w'): x -> basis_path_1 * x * basis_path_2 ]
            ## for basis_path_1: v' -> v and basis_path_2: w -> w'
            hom_structure_on_basis_paths := HomStructureOnBasisPaths( fpcategory );
            
            map := List( [ 1 .. Length( basis_paths_by_vertex_index[a][b] ) ], phi_index ->
                         hom_structure_on_basis_paths[a][b][ap][bp][alpha_index][beta_index][phi_index] );
            
            return MorphismConstructor( RangeCategoryOfHomomorphismStructure( fpcategory ), source, map, range );
            
        end );
        
        ##
        AddDistinguishedObjectOfHomomorphismStructure( fpcategory,
          function( fpcategory )
            
            return TerminalObject( RangeCategoryOfHomomorphismStructure( fpcategory ) );
            
        end );
        
        ##
        AddInterpretMorphismAsMorphismFromDistinguishedObjectToHomomorphismStructure( fpcategory,
          function( fpcategory, alpha )
            local source, range, element, a, b, basis_elements;
            
            source := DistinguishedObjectOfHomomorphismStructure( fpcategory );
            range := HomomorphismStructureOnObjects( fpcategory, Source( alpha ), Range( alpha ) );
            
            element := UnderlyingQuiverAlgebraElement( alpha );
            
            a := VertexIndex( UnderlyingVertex( Source( alpha ) ) );
            
            b := VertexIndex( UnderlyingVertex( Range( alpha ) ) );
            
            basis_elements := BasisPathsByVertexIndex( fpcategory )[a][b];
            
            return MorphismConstructor( RangeCategoryOfHomomorphismStructure( fpcategory ),
                           source,
                           [ -1 + SafePosition( basis_elements, BasisPathOfPathAlgebraBasisElement( element ) ) ],
                           range );
            
        end );
        
        ##
        AddInterpretMorphismFromDistinguishedObjectToHomomorphismStructureAsMorphism( fpcategory,
          function( fpcategory, a, b, morphism )
            local basis, element;
            
            basis := BasisPathsByVertexIndex( fpcategory )[VertexIndex( UnderlyingVertex( a ) )][VertexIndex( UnderlyingVertex( b ) )];
            
            element := QuiverAlgebraElement( quiver_algebra, [ 1 ], basis{[ 1 + AsList( morphism )[1] ]} );
            
            return MorphismInFpCategory( fpcategory, a, element, b );
            
        end );
        
        SetIsEquippedWithHomomorphismStructure( fpcategory, true );
        
    fi;
    
end );

##
InstallMethodWithCache( Category,
        "for a QPA quiver algebra and a CAP category",
        [ IsQuiverAlgebra, IsCapCategory ],
        
  function( A, range_category_of_HomStructure )
    local domain, parity, quiver, C, relations, rels;
    
    domain := LeftActingDomain( A );
    
    if IsRightQuiverAlgebra( A ) then
        parity := "Right";
    else
        parity := "Left";
    fi;
    
    quiver := QuiverOfAlgebra( A );
    
    C := "FreeCategory( ";
    
    C := Concatenation( C, parity, "Quiver( \"", String( quiver ), "\" ) )" );
    
    relations := CAP_INTERNAL_RETURN_OPTION_OR_DEFAULT( "relations", [ ] );
    
    if not relations = [ ] then
        
        if Length( relations ) < 6 then
            
            rels := Concatenation(
                            " [",
                            JoinStringsWithSeparator( List( relations, a -> Concatenation( " ", String( a[1] ), " = ", String( a[2] ) ) ) ),
                            " ]" );
            
            C := Concatenation( C, " /", rels );
            
        else
            
            C := Concatenation( C, " / relations" );
            
        fi;
        
    elif not IsPathAlgebra( A ) then
        
        C := Concatenation( C, " / relations" );
        
    fi;
    
    C := CreateCapCategoryWithDataTypes( C,
                 IsFpCategory,
                 IsObjectInFpCategory,
                 IsMorphismInFpCategory,
                 IsCapCategoryTwoCell,
                 IsQuiverVertex,
                 IsQuiverAlgebraElement,
                 fail );
    
    C!.relations := relations;
    
    SetDefiningTripleOfUnderlyingQuiver( C, DefiningTripleOfAQuiver( quiver ) );
    
    DeactivateCachingOfCategory( C );
    CapCategorySwitchLogicOff( C );
    DisableSanityChecks( C );
    
    SetIsFinitelyPresentedCategory( C, true );
    SetUnderlyingQuiver( C, quiver );
    SetUnderlyingAlgebra( C, domain );
    SetParity( C, parity );
    
    SetUnderlyingQuiverAlgebra( C, A );
    if Length( Vertices( quiver ) ) = 1 then
        SetFilterObj( C, IsMonoidAsCategory );
        if Length( Arrows( quiver ) ) <= 1 then
            SetIsCommutative( C, true );
        fi;
    fi;
    
    SetIsFinite( C, IsFiniteDimensional( A ) );
    
    if IsFinite( C ) then
        SetRangeCategoryOfHomomorphismStructure( C, range_category_of_HomStructure );
    fi;
    
    C!.Vertices := rec( );
    C!.Arrows := rec( );
    
    C!.compiler_hints :=
      rec( category_attribute_names :=
           [ "SetOfObjects",
             "SetOfGeneratingMorphisms",
             "UnderlyingQuiver",
             "UnderlyingQuiverAlgebra",
             "BasisPathsByVertexIndex",
             "BasisMorphismsByVertexIndex",
             "HomStructureOnBasisPaths",
             "DefiningTripleOfUnderlyingQuiver",
             ],
           );
    
    return ADD_FUNCTIONS_FOR_FP_CATEGORY( C );
    
end );

##
InstallMethod( Category,
        "for a QPA quiver algebra",
        [ IsQuiverAlgebra ],
        
  function( A )
    
    return Category( A, CAP_INTERNAL_RETURN_OPTION_OR_DEFAULT( "range_of_HomStructure", SkeletalFinSets ) );
    
end );

##
InstallMethod( Category,
        "for a QPA path algebra and a list",
        [ IsPathAlgebra, IsList ],
        
  function( Qq, L )
    local relations, A, C;
    
    if not ( IsList( L ) and
             ForAll( L, IsList ) and
             ForAll( L, a -> Length( a ) = 2 ) and
             ForAll( L, a -> ForAll( a, IsPath ) ) ) then
        
        Error( "the relations should be given as a list of pairs of paths\n" );
        
    fi;
    
    relations := List( L, a -> PathAsAlgebraElement( Qq, a[1] ) - PathAsAlgebraElement( Qq, a[2] ) );
    
    A := Qq / Ideal( Qq, relations );
    
    A := Qq / GroebnerBasis( IdealOfQuotient( A ) );
    
    C := Category( A : relations := L );
    
    SetRelationsOfFpCategory( C, L );
    
    return C;
    
end );

##
InstallMethod( Category,
        "for a QPA quiver",
        [ IsQuiver, IsList ],
        
  function( quiver, L )
    
    return Category( PathAlgebra( ALGEBROIDS.ring, quiver ), L );
    
end );

##
InstallMethod( QuotientCategory,
        "for a f.p. category and a list",
        [ IsFpCategory and HasUnderlyingQuiver, IsList ],
        
  function( C, L )
    local relations, f;
    
    if HasRelationsOfFpCategory( C ) then
        relations := ShallowCopy( RelationsOfFpCategory( C ) );
    else
        relations := [ ];
    fi;
    
    f :=
      function( p )
        if IsObjectInFpCategory( p ) then
            return UnderlyingVertex( p );
        fi;
        return BasisPathOfPathAlgebraBasisElement( UnderlyingQuiverAlgebraElement( p ) );
    end;
    
    Append( relations, List( L, a -> List( a, f ) ) );
    
    return Category( UnderlyingQuiver( C ), relations );
    
end );

##
InstallMethod( \/,
        "for a f.p. category and a list",
        [ IsFpCategory and HasUnderlyingQuiver, IsList ],
        
  function( C, L )
    
    return QuotientCategory( C, L );
    
end );

##
InstallMethod( FreeCategory,
        "for a QPA quiver",
        [ IsQuiver ],
        
  function( quiver )
    
    return Category( quiver, [ ] );
    
end );

##
InstallMethod( Multiplication,
        "for a commutative algebra as cateogry",
        [ IsMonoidAsCategory and IsCommutative ],
        
  function( A )
    local unique_object_in_A, unique_object_in_A_string,
          morphisms_in_A, A2, unique_object_in_A2, unique_object_in_A2_string,
          mult_functor_images_of_objects, mult_functor_images_of_generating_morphisms,
          a, b, axg, axg_string, fxb, fxb_string, mult_functor, g, f;

    unique_object_in_A := SetOfObjects( A )[1];
    unique_object_in_A_string := String( UnderlyingVertex( unique_object_in_A ) );
    morphisms_in_A := SetOfGeneratingMorphisms(A);

    A2 := A*A;
    
    unique_object_in_A2 := SetOfObjects( A2 )[1];
    unique_object_in_A2_string := String( UnderlyingVertex( unique_object_in_A2 ) );
    
    mult_functor_images_of_objects := rec( );
    mult_functor_images_of_objects.(unique_object_in_A2_string) := unique_object_in_A;

    mult_functor_images_of_generating_morphisms := rec(); # FIXME

    a := unique_object_in_A;
    b := unique_object_in_A;

    for g in morphisms_in_A do

        axg := ElementaryTensor( a, g, A2 );
        axg_string := String( LeadingPath( Representative( UnderlyingQuiverAlgebraElement( axg ) ) ) );

        mult_functor_images_of_generating_morphisms.(axg_string) := g;

    od;

    for f in morphisms_in_A do

        fxb := ElementaryTensor( f, b, A2 );
        fxb_string := String( LeadingPath( Representative( UnderlyingQuiverAlgebraElement( fxb ) ) ) );

        mult_functor_images_of_generating_morphisms.(fxb_string) := f;

    od;
    
    mult_functor := CapFunctor( A2, mult_functor_images_of_objects, mult_functor_images_of_generating_morphisms );
    
    return mult_functor;

end );

##
InstallMethod( Unit,
        "for algebra as category",
        [ IsMonoidAsCategory ],
        
  function( A )
    
    local unique_object_in_A, unique_object_in_A_string,
          unique_object_in_A0, unique_object_in_A0_string,
          unit_functor_images_of_objects, unit_functor_images_of_generating_morphisms, A0;
    
    unique_object_in_A := SetOfObjects( A )[1];
    unique_object_in_A_string := String( UnderlyingVertex( unique_object_in_A ) );
    
    A0 := A^0;
    
    unique_object_in_A0 := SetOfObjects( A0 )[1];
    unique_object_in_A0_string := String( UnderlyingVertex( unique_object_in_A0 ) );
    
    unit_functor_images_of_objects := rec( );
    unit_functor_images_of_objects.(unique_object_in_A0_string) := unique_object_in_A;
    
    unit_functor_images_of_generating_morphisms := rec( );
    
    return CapFunctor( A0, unit_functor_images_of_objects, unit_functor_images_of_generating_morphisms );
    
end );

##
InstallMethodForCompilerForCAP( ObjectInFpCategory,
         "for a f.p. category and a vertex of a quiver",
        [ IsFpCategory, IsQuiverVertex ],
        
  function( C, v )
    local name, o;
    
    #% CAP_JIT_DROP_NEXT_STATEMENT
    Assert( 0, IsIdenticalObj( UnderlyingQuiver( C ), QuiverOfPath( v ) ) );
    
    #% CAP_JIT_DROP_NEXT_STATEMENT
    name := String( v );
    
    #% CAP_JIT_DROP_NEXT_STATEMENT
    if IsBound( C!.Vertices.(name) ) then
        return C!.Vertices.(name);
    fi;
    
    o := CreateCapCategoryObjectWithAttributes( C,
                 UnderlyingVertex, v );
    
    #% CAP_JIT_DROP_NEXT_STATEMENT
    SetLabel( o, name );
    
    #% CAP_JIT_DROP_NEXT_STATEMENT
    C!.Vertices.(name) := o;
    
    return o;
    
end );

##
InstallOtherMethod( \/,
        [ IsQuiverVertex, IsFpCategory ],
        
  { v, C } -> ObjectInFpCategory( C, v )
);

##
InstallOtherMethodForCompilerForCAP( MorphismInFpCategory,
        "for a f.p. category, two objects in a f.p. category, and an element of the quiver algebra",
        [ IsFpCategory, IsObjectInFpCategory, IsQuiverAlgebraElement, IsObjectInFpCategory ],
        
  function( B, S, path, T )
    local l;
    
    #% CAP_JIT_DROP_NEXT_STATEMENT
    Assert( 0, IsIdenticalObj( UnderlyingQuiver( B ), QuiverOfAlgebra( AlgebraOfElement( path ) ) ) );
    
    if IsZero( path ) then
        Error( "the quiver algebra element ", path, " is zero\n" );
    fi;
        
    if not IsUniform( path ) then
        Error( "the quiver algebra element ", path, " is neither zero nor uniform\n" );
    fi;
    
    #% CAP_JIT_DROP_NEXT_STATEMENT
    if IsPathAlgebraElement( path ) then
        l := LeadingPath( path );
        
        if not ( Source( l ) = UnderlyingVertex( S ) ) and not ( Target( l ) = UnderlyingVertex( T ) ) then
            Error( "the path algebra element ", path, " does not match the given source S and it does not match the given target T\n" );
        elif not ( Source( l ) = UnderlyingVertex( S ) ) then
            Error( "the path algebra element ", path, " does not match the given source S\n" );
        elif not ( Target( l ) = UnderlyingVertex( T ) ) then
            Error( "the path algebra element ", path, " does not match the given target T\n" );
        fi;
    fi;
    
    if not IsIdenticalObj( CapCategory(S), CapCategory(T) ) then
        Error( "source and target do not belong to the same category");
    fi;
    
    return CreateCapCategoryMorphismWithAttributes( B,
                   S,
                   T,
                   UnderlyingQuiverAlgebraElement, path );
    
end );

##
InstallMethod( MorphismInFpCategory,
        "for two objects in a f.p. category and an element of the quiver algebra",
        [ IsObjectInFpCategory, IsQuiverAlgebraElement, IsObjectInFpCategory ],
        
  function( S, path, T )
    
    return MorphismInFpCategory( CapCategory( S ), S, path, T );
    
end );

##
InstallMethod( MorphismInFpCategory,
        "for a f.p. category and an element of a path algebra",
        [ IsFpCategory, IsPathAlgebraElement ],
        
  function( C, path )
    local l, S, T;
    
    if IsZero( path ) then
        Error( "the path algebra element ", path, " is a zero path\n" );
    elif not IsUniform( path ) then
        Error( "the path algebra element ", path, " is not uniform\n" );
    elif not Coefficients( path ) = [ 1 ] then
        Error( "the path algebra element ", path, " is not a path\n" );
    fi;
    
    l := LeadingPath( path );
    
    S := String( Source( l ) );
    T := String( Target( l ) );
    
    return MorphismInFpCategory( C, C.(S), path, C.(T) );
    
end );

##
InstallMethod( \.,
        "for a f.p. category and a positive integer",
        [ IsFpCategory, IsPosInt ],
        
  function( C, string_as_int )
    local name, q, a, b;
    
    name := NameRNam( string_as_int );
    
    q := UnderlyingQuiver( C );
    
    a := q.(name);
    
    if IsQuiverVertex( a ) then
        if IsBound( C!.Vertices.(name) ) then
            return C!.Vertices.(name);
        fi;
        b := ObjectInFpCategory( C, a );
    elif IsArrow( a ) or IsCompositePath( a ) then
        if IsBound( C!.Arrows.(name) ) then
            return C!.Arrows.(name);
        fi;
        b := MorphismInFpCategory(
                     C.(String( Source( a ) ) ),
                     PathAsAlgebraElement( UnderlyingQuiverAlgebra( C ), a ),
                     C.(String( Target( a ) ) ) );
        SetLabel( b, name );
        C!.Arrows.(name) := b;
    else
        Error( "the given component ", name, " is neither a vertex nor an arrow of the quiver q = ", q, "\n" );
    fi;
    
    return b;
    
end );

##
InstallMethod( MorphismInFpCategory,
        "for a f.p. category and an element of a quotient of a path algebra",
        [ IsFpCategory, IsQuotientOfPathAlgebraElement ],
        
  function( A, path )
    local l, S, T;
    
    if IsZero( path ) then
        Error( "source and target of the zero path is ambiguous\n" );
    elif not IsUniform( path ) then
        Error( "the quiver algebra element ", path, " is not uniform\n" );
    fi;
    
    l := LeadingPath( Representative( path ) );
    
    S := String( Source( l ) );
    T := String( Target( l ) );
    
    return MorphismInFpCategory( A, A.(S), path, A.(T) );
    
end );

##
InstallMethod( MorphismInFpCategory,
        "for a f.p. category and a path",
        [ IsFpCategory, IsPath ],
        
  function( C, path )
    
    path := PathAsAlgebraElement( UnderlyingQuiverAlgebra( C ), path );
    
    return MorphismInFpCategory( C, path );
    
end );

##
InstallOtherMethod( \/,
        [ IsPath, IsFpCategory ],
        
  function( path, C )
    
    return MorphismInFpCategory( C, path );
    
end );

##
InstallMethod( POW,
        "for a f.p. category and an integer",
        [ IsFpCategory and HasUnderlyingQuiverAlgebra, IsInt ],
        
  function( C, n )
    local Qq, R, parity;
    
    if n < 0 then
        Error( "the only admissible values for n are non-negative integers\n" );
    elif n = 1 then
        return C;
    elif not IsBound( C!.powers ) then
        C!.powers := rec( );
    fi;
    
    Qq := UnderlyingQuiverAlgebra( C );
    
    R := LeftActingDomain( Qq );
    
    if n = 0 then
        
        if not IsBound( C!.powers.0 ) then
            
            if IsRightQuiverAlgebra( Qq ) then
                parity := "Right";
            else
                parity := "Reft";
            fi;
            
            C!.powers.0 := TrivialCategory( parity );
            
        fi;
        
        return C!.powers.0;
        
    fi;
    
    C!.powers.1 := C;
    
    if not IsBound( C!.powers.(n) ) then
        if not IsBound( C!.powers.(n-1) ) then
            C!.powers.(n-1) := C^(n-1);
        fi;
        
        C!.powers.(n) := C!.powers.(n-1) * C;
        
        C!.powers.(n)!.PowerOf := C;
        
    fi;
    
    return C!.powers.(n);
    
end );

##
InstallMethod( TrivialCategory,
        "for a string",
        [ IsString ],
        
  function( parity )
    local trivial_quiver;
   
    if parity = "Right" then
        trivial_quiver := RightQuiver( "*(1)[]" );
    elif parity = "Left" then
        trivial_quiver := LeftQuiver( "*(1)[]" );
    else
        Error( "parity must be either \"Left\" or \"Right\"" );
    fi;
    
    return FreeCategory( trivial_quiver );
end );

##
InstallMethod( ElementaryTensor,
        "for objects in categorys",
        [ IsObjectInFpCategory, IsObjectInFpCategory, IsFpCategory ],
        
  function( a, b, T )
      
    local product_string, a_string, b_string, product_vertex;
  
    product_vertex := PathInProductQuiver( QuiverOfAlgebra( UnderlyingQuiverAlgebra( T ) ), [ UnderlyingVertex( a ), UnderlyingVertex( b ) ] );
    product_string := String(product_vertex);
  
    return T.(product_string);

end );

##
InstallMethod( ElementaryTensor,
        "for object and morphism in categorys",
        [ IsObjectInFpCategory, IsMorphismInFpCategory, IsFpCategory ],
        
  function( object, morphism, T )
    local source, range, morphism_as_quiver_algebra_element, path,
          object_underlying_vertex, object_string, mors, o;
    
    source := ElementaryTensor( object, Source( morphism ), T );
    range := ElementaryTensor( object, Range( morphism ), T );
    
    morphism_as_quiver_algebra_element := UnderlyingQuiverAlgebraElement( morphism );
    
    path := BasisPathOfPathAlgebraBasisElement( morphism_as_quiver_algebra_element );
    
    object_underlying_vertex := UnderlyingVertex( object );
    object_string := String( object_underlying_vertex );
    
    mors := List( List( ArrowList( path ),
                    b -> PathInProductQuiver( QuiverOfAlgebra( UnderlyingQuiverAlgebra( T ) ), [ object_underlying_vertex, b ] ) ),
                  b -> MorphismInFpCategory(
                          ObjectInFpCategory( T, Source( b ) ),
                          QuiverAlgebraElement( UnderlyingQuiverAlgebra( T ), [ 1 ], [ b ] ),
                          ObjectInFpCategory( T, Target( b ) ) ) );
    
    if Length( mors ) = 0 then
        
        Assert( 3, IsQuiverVertex( path ) );
        
        o := ObjectInFpCategory( CapCategory( morphism ), path );
        
        Assert( 3, o = Source( morphism ) and o = Range( morphism ) );
        
        return IdentityMorphism( ElementaryTensor( object, o, T ) );
        
    fi;
    
    return PreCompose( mors );
    
end );

##
InstallMethod( ElementaryTensor,
        "for morphism and object in categorys",
        [ IsMorphismInFpCategory, IsObjectInFpCategory, IsFpCategory ],
        
  function( morphism, object, T )
    local source, range, morphism_as_quiver_algebra_element, path,
          object_underlying_vertex, object_string, mors, o;
    
    source := ElementaryTensor( Source( morphism ), object, T );
    range := ElementaryTensor( Range( morphism ), object, T );
    
    morphism_as_quiver_algebra_element := UnderlyingQuiverAlgebraElement( morphism );
    
    path := BasisPathOfPathAlgebraBasisElement( morphism_as_quiver_algebra_element );
    
    object_underlying_vertex := UnderlyingVertex( object );
    object_string := String( object_underlying_vertex );
    
    mors := List( List( ArrowList( path ),
                    a -> PathInProductQuiver( QuiverOfAlgebra( UnderlyingQuiverAlgebra( T ) ), [ a, object_underlying_vertex ] ) ),
                  a -> MorphismInFpCategory(
                          ObjectInFpCategory( T, Source( a ) ),
                          QuiverAlgebraElement( UnderlyingQuiverAlgebra( T ), [ 1 ], [ a ] ),
                          ObjectInFpCategory( T, Target( a ) ) ) );
    
    if Length( mors ) = 0 then
        
        Assert( 3, IsQuiverVertex( path ) );
        
        o := ObjectInFpCategory( CapCategory( morphism ), path );
        
        Assert( 3, o = Source( morphism ) and o = Range( morphism ) );
        
        return IdentityMorphism( ElementaryTensor( o, object, T ) );
        
    fi;
    
    return PreCompose( mors );
    
end );

##
InstallMethod( QuiverVertexAsIdentityPath,
        [ IsQuiverVertex ],
        
  function( vertex )
    
    # interpreted as its identity path
    return vertex;
    
end );

##
InstallMethod( \*,
        "for two categorys",
        [ IsFpCategory and HasUnderlyingQuiverAlgebra, IsFpCategory and HasUnderlyingQuiverAlgebra ],
        
  function( A, B )

    return Category( TensorProductOfAlgebras( UnderlyingQuiverAlgebra( A ), UnderlyingQuiverAlgebra( B ) ) );
    
end );

##
InstallMethod( CapFunctor,
        "for a f.p. category, two lists, a CAP Category, and a boolean",
        [ IsFpCategory, IsList, IsList, IsCapCategory, IsBool ],
        
  function( A, images_of_objects, images_of_generating_morphisms, B, covariant )
    local kq, vertices, arrows, functor, func_obj, func_mor;
    
    kq := QuiverOfAlgebra( UnderlyingQuiverAlgebra( A ) );
    
    vertices := Vertices( kq );
    arrows := Arrows( kq );
    
    functor := Concatenation( "Functor from ", Name( A ), " -> ", Name( B ) );
    
    functor := CapFunctor( functor, A, B );
    
    functor!.ValuesOnAllObjects := images_of_objects;
    functor!.ValuesOnAllGeneratingMorphisms := images_of_generating_morphisms;
    
    functor!.IsContravariant := not covariant;
    
    DeactivateCachingObject( ObjectCache( functor ) );
    DeactivateCachingObject( MorphismCache( functor ) );
    
    AddObjectFunction( functor,
      function( obj )
        local i;
        
        i := SafePosition( vertices, UnderlyingVertex( obj ) );
        
        if IsInt( i ) then
            return images_of_objects[i];
        fi;
        
        Error( "vertex UnderlyingVertex( obj ) = ", UnderlyingVertex( obj ), " not found in the list ", vertices, " of vertices\n" );
        
    end );

    func_obj := o -> images_of_objects[SafePosition( vertices, o )];
    func_mor := a -> images_of_generating_morphisms[SafePosition( arrows, a )];
    
    if covariant then
        
        AddMorphismFunction( functor,
          function( new_source, mor, new_range )
            local i;
            
            mor := UnderlyingQuiverAlgebraElement( mor );
            
            i := Position( arrows, mor );
            
            if IsInt( i ) then
                return images_of_generating_morphisms[i];
            fi;
            
            return ApplyToQuiverAlgebraElement( func_obj, func_mor, B, mor, true );
            
        end );
        
    else
        
        AddMorphismFunction( functor,
          function( new_source, mor, new_range )
            local i;
            
            mor := UnderlyingQuiverAlgebraElement( mor );
            
            i := Position( arrows, mor );
            
            if IsInt( i ) then
                return images_of_objects[i];
            fi;
            
            return ApplyToQuiverAlgebraElement( func_obj, func_mor, B, mor, false );
            
        end );
        
    fi;
    
    return functor;
    
end );

##
InstallMethod( CapFunctor,
        "for a f.p. category, two lists, and a CAP category",
        [ IsFpCategory, IsList, IsList, IsCapCategory ],
        
  function( A, images_of_objects, images_of_generating_morphisms, B )
    
    return CapFunctor( A, images_of_objects, images_of_generating_morphisms, B, true );
    
end );

## this a convenience method
InstallMethod( CapFunctor,
        "for a f.p. category, two records, and a boolean",
        [ IsFpCategory, IsRecord, IsRecord, IsBool ],
        
  function( A, rec_images_of_objects, rec_images_of_generating_morphisms, covariant )
    local kq, vertices, images_of_objects, arrows, images_of_generating_morphisms,
          mor, Qq, B;
    
    kq := QuiverOfAlgebra( UnderlyingQuiverAlgebra( A ) );
    
    vertices := Vertices( kq );
    
    images_of_objects := List( vertices, v -> rec_images_of_objects.(String( v ) ) );
    
    if images_of_objects = [ ] then
        Error( "the record rec_images_of_objects does not contain a named image of an object in the source category A\n" );
    fi;
    
    arrows := Arrows( kq );
    
    images_of_generating_morphisms := List( arrows, a -> rec_images_of_generating_morphisms.(String( a ) ) );
    
    # Construct the target category B
    if not IsEmpty( images_of_generating_morphisms ) then
        for mor in images_of_generating_morphisms do
            if IsQuiverAlgebraElement( mor ) then
                Qq := AlgebraOfElement( mor );
                B := Category( Qq );
                break;
            elif IsCapCategoryCell( mor ) then
                if not IsCapCategoryMorphism( mor ) then
                    Error( Concatenation( "the image ", mor, " is not a morphism"));
                fi;
                B := CapCategory( mor );
                break;
            fi;
        od;
    else
        B := CapCategory( images_of_objects[1] );
    fi;
    
    if not IsBound( B ) then
        Error( "unable to extract target category from the records of images\n" );
    fi;
    
    return CapFunctor( A, images_of_objects, images_of_generating_morphisms, B, covariant );
    
end );

## this a convenience method
InstallMethod( CapFunctor,
        "for a f.p. category and two records",
        [ IsFpCategory, IsRecord, IsRecord ],
        
  function( A, rec_images_of_objects, rec_images_of_generating_morphisms )
    
    return CapFunctor( A, rec_images_of_objects, rec_images_of_generating_morphisms, true );
    
end );

##
InstallMethod( CapFunctor,
        "for a f.p. category and a CAP category object",
        [ IsFpCategory, IsCapCategoryObject ],
        
  function( A, object )
    
    return CapFunctor(
                   A,
                   ListWithIdenticalEntries( Length( SetOfObjects( A ) ), object ),
                   ListWithIdenticalEntries( Length( SetOfGeneratingMorphisms( A ) ), IdentityMorphism( object ) ),
                   CapCategory( object ) );
    
end );

##
InstallMethod( OppositeFpCategory,
        "for a f.p. category",
        [ IsFpCategory and HasRelationsOfFpCategory ],
        
  function( C )
    local relations, range_category, C_op;
    
    relations := RelationsOfFpCategory( C );
    
    relations := List( relations, a -> List( a, OppositePath ) );
    
    if HasRangeCategoryOfHomomorphismStructure( C ) then
        range_category := RangeCategoryOfHomomorphismStructure( C );
    else
        range_category := fail;
    fi;
    
    C_op := Category(
                    OppositeQuiver( UnderlyingQuiver( C ) ),
                    relations : range_of_HomStructure := range_category );
    
    SetOppositeFpCategory( C_op, C );
    
    return C_op;
    
end );

##
InstallMethodForCompilerForCAP( NerveTruncatedInDegree2Data,
        [ IsCapCategory and IsFinite ],
        
  function ( B )
    local A, sFinSets, B0, N0, D00, N0N0, p21, p22, B1, N1, N1_elements, d, id, pi2, s, t,
          D000, N0N0N0, p31, p32, p33, B2, N2, N2_elements, T, ds, is, dt, it,
          p312, p323, p313, pi3, pi312, pi323, pi313, ps, pt, mus, mus1, mus2, mus3, mu;
    
    sFinSets := RangeCategoryOfHomomorphismStructure( B );
    
    ## sFinSets must be the category skeletal finite sets
    Assert( 0, IsCategoryOfSkeletalFinSets( sFinSets ) );
    
    B0 := SetOfObjects( B );
    N0 := ObjectConstructor( sFinSets, Length( B0 ) );
    
    ## N0 × N0
    D00 := [ N0, N0 ];
    N0N0 := DirectProduct( sFinSets, D00 );
    
    ## N0 × N0 -> N0
    p21 := ProjectionInFactorOfDirectProductWithGivenDirectProduct( sFinSets, D00, 1, N0N0 );
    p22 := ProjectionInFactorOfDirectProductWithGivenDirectProduct( sFinSets, D00, 2, N0N0 );
    
    B1 := List( N0N0, i ->
                HomomorphismStructureOnObjects( B,
                        B0[1 + AsList( p21 )[1 + i]],
                        B0[1 + AsList( p22 )[1 + i]] ) );
    
    N1 := Coproduct( sFinSets, B1 );
    
    N1_elements := ExactCoverWithGlobalElements( N1 );
    
    ## N0 -> N0 × N0
    d := EmbeddingOfEqualizerWithGivenEqualizer( sFinSets,
                 N0N0,
                 [ p21, p22 ],
                 N0 );
    
    #% CAP_JIT_DROP_NEXT_STATEMENT
    Assert( 0, d = UniversalMorphismIntoDirectProduct( sFinSets, D00, N0, [ IdentityMorphism( sFinSets, N0 ), IdentityMorphism( sFinSets, N0 ) ] ) );
    
    ## N0 -> N1
    id := MorphismConstructor( sFinSets,
                  N0,
                  List( N0, i ->
                        AsList(
                               PreCompose( sFinSets,
                                       InterpretMorphismAsMorphismFromDistinguishedObjectToHomomorphismStructure( B,
                                               IdentityMorphism( B,
                                                       B0[1 + i] ) ),
                                       InjectionOfCofactorOfCoproductWithGivenCoproduct( sFinSets,
                                               B1,
                                               1 + AsList( d )[1 + i],
                                               N1 ) ) )[1 + 0] ),
                  N1 );
    
    ## N1 -> N0 × N0
    ## this morphism is mixing two levels and is not a CAP operation:
    ## the coproduct N1 in SkeletalFinSets is taken over the index set N0N0 (here also realized as an object in SkeletalFinSets),
    ## so this morphism is a fibration of a coproduct over its "index set" which are both assumed to be objects in the same category:
    pi2 := MorphismConstructor( sFinSets,
                   N1,
                   Concatenation( List( N0N0, i -> ListWithIdenticalEntries( Length( B1[1 + i] ), i ) ) ),
                   N0N0 );
    
    ## N1 -> N0 × N0 -> N0
    s := PreCompose( sFinSets, pi2, p21 );
    
    ## N1 -> N0 × N0 -> N0
    t := PreCompose( sFinSets, pi2, p22 );
    
    ## N0 × N0 × N0
    D000 := [ N0, N0, N0 ];
    N0N0N0 := DirectProduct( sFinSets, D000 );
    
    ## N0 × N0 × N0 -> N0
    p31 := ProjectionInFactorOfDirectProductWithGivenDirectProduct( sFinSets, D000, 1, N0N0N0 );
    p32 := ProjectionInFactorOfDirectProductWithGivenDirectProduct( sFinSets, D000, 2, N0N0N0 );
    p33 := ProjectionInFactorOfDirectProductWithGivenDirectProduct( sFinSets, D000, 3, N0N0N0 );
    
    B2 := List( N0N0N0, i ->
                DirectProduct( sFinSets,
                        [ HomomorphismStructureOnObjects( B,
                                B0[1 + AsList( p31 )[1 + i]],
                                B0[1 + AsList( p32 )[1 + i]] ),
                          HomomorphismStructureOnObjects( B,
                                  B0[1 + AsList( p32 )[1 + i]],
                                  B0[1 + AsList( p33 )[1 + i]] ) ] ) );
    
    N2 := Coproduct( sFinSets, B2 );
    
    N2_elements := ExactCoverWithGlobalElements( N2 );
    
    T := TerminalObject( sFinSets );
    
    ## N1 -> N0 × N0 -> N0 × N0 × N0
    ## this is elegant but needs a justification:
    ds := PreCompose( sFinSets,
                  pi2,
                  EmbeddingOfEqualizerWithGivenEqualizer( sFinSets,
                          N0N0N0,
                          [ p32, p33 ],
                          N0N0 ) );
    
    ## N1 -> N2
    is := MorphismConstructor( sFinSets,
                  N1,
                  List( N1, i ->
                        AsList(
                               PreCompose( sFinSets,
                                       DirectProductFunctorial( sFinSets,
                                               [ LiftAlongMonomorphism( sFinSets,
                                                       InjectionOfCofactorOfCoproductWithGivenCoproduct( sFinSets,
                                                               B1,
                                                               1 + AsList( pi2 )[1 + i],
                                                               N1 ),
                                                       N1_elements[1 + i] ),
                                                 InterpretMorphismAsMorphismFromDistinguishedObjectToHomomorphismStructure( B,
                                                         IdentityMorphism( B,
                                                                 B0[1 + AsList( t )[1 + i]] ) ) ] ),
                                       InjectionOfCofactorOfCoproductWithGivenCoproduct( sFinSets,
                                               B2,
                                               1 + AsList( ds )[1 + i],
                                               N2 ) ) )[1 + 0] ),
                  N2 );
    
    ## N1 -> N0 × N0 -> N0 × N0 × N0
    ## this is elegant but needs a justification:
    dt := PreCompose( sFinSets,
                  pi2,
                  EmbeddingOfEqualizerWithGivenEqualizer( sFinSets,
                          N0N0N0,
                          [ p31, p32 ],
                          N0N0 ) );
    
    ## N1 -> N2
    it := MorphismConstructor( sFinSets,
                  N1,
                  List( N1, i ->
                        AsList(
                               PreCompose( sFinSets,
                                       DirectProductFunctorial( sFinSets,
                                               [ InterpretMorphismAsMorphismFromDistinguishedObjectToHomomorphismStructure( B,
                                                       IdentityMorphism( B,
                                                               B0[1 + AsList( s )[1 + i]] ) ),
                                                 LiftAlongMonomorphism( sFinSets,
                                                         InjectionOfCofactorOfCoproductWithGivenCoproduct( sFinSets,
                                                                 B1,
                                                                 1 + AsList( pi2 )[1 + i],
                                                                 N1 ),
                                                         N1_elements[1 + i] ) ] ),
                                       InjectionOfCofactorOfCoproductWithGivenCoproduct( sFinSets,
                                               B2,
                                               1 + AsList( dt )[1 + i],
                                               N2 ) ) )[1 + 0] ),
                  N2 );
    
    ## N0 × N0 × N0 -> N0 × N0
    p312 := UniversalMorphismIntoDirectProduct( sFinSets, D00, N0N0N0, [ p31, p32 ] );
    p323 := UniversalMorphismIntoDirectProduct( sFinSets, D00, N0N0N0, [ p32, p33 ] );
    p313 := UniversalMorphismIntoDirectProduct( sFinSets, D00, N0N0N0, [ p31, p33 ] );
    
    #% CAP_JIT_DROP_NEXT_STATEMENT
    Assert( 0, p312 = ProjectionInFactorOfDirectProduct( sFinSets, [ N0N0, N0 ], 1 ) );
    
    #% CAP_JIT_DROP_NEXT_STATEMENT
    Assert( 0, p323 = ProjectionInFactorOfDirectProduct( sFinSets, [ N0, N0N0 ], 2 ) );
    
    ## N2 -> N0 × N0 × N0
    ## this morphism is mixing two levels and is not a CAP operation:
    ## the coproduct N2 in SkeletalFinSets is taken over the index set N0N0N0 (here also realized as an object in SkeletalFinSets),
    ## so this morphism is a fibration of a coproduct over its "index set" which are both assumed to objects in the same category:
    pi3 := MorphismConstructor( sFinSets,
                   N2,
                   Concatenation( List( N0N0N0, i -> ListWithIdenticalEntries( Length( B2[1 + i] ), i ) ) ),
                   N0N0N0 );
    
    ## N2 -> N0 × N0 × N0 -> N0 × N0
    pi312 := PreCompose( sFinSets, pi3, p312 );
    pi323 := PreCompose( sFinSets, pi3, p323 );
    pi313 := PreCompose( sFinSets, pi3, p313 );
    
    ## N2 -> N1
    ps := MorphismConstructor( sFinSets,
                  N2,
                  List( N2, i ->
                        AsList(
                               PreComposeList( sFinSets,
                                       T,
                                       [ LiftAlongMonomorphism( sFinSets,
                                               InjectionOfCofactorOfCoproductWithGivenCoproduct( sFinSets,
                                                       B2,
                                                       1 + AsList( pi3 )[1 + i],
                                                       N2 ),
                                               N2_elements[1 + i] ),
                                         ProjectionInFactorOfDirectProduct( sFinSets,
                                                 [ B1[1 + AsList( pi312 )[1 + i]],
                                                   B1[1 + AsList( pi323 )[1 + i]] ],
                                                 1 ),
                                         InjectionOfCofactorOfCoproductWithGivenCoproduct( sFinSets,
                                                 B1,
                                                 1 + AsList( pi312 )[1 + i],
                                                 N1 ) ],
                                       N1 ) )[1 + 0] ),
                  N1 );
    
    ## N2 -> N1
    pt := MorphismConstructor( sFinSets,
                  N2,
                  List( N2, i ->
                        AsList(
                               PreComposeList( sFinSets,
                                       T,
                                       [ LiftAlongMonomorphism( sFinSets,
                                               InjectionOfCofactorOfCoproductWithGivenCoproduct( sFinSets,
                                                       B2,
                                                       1 + AsList( pi3 )[ 1 + i],
                                                       N2 ),
                                               N2_elements[1 + i] ),
                                         ProjectionInFactorOfDirectProduct( sFinSets,
                                                 [ B1[1 + AsList( pi312 )[1 + i]],
                                                   B1[1 + AsList( pi323 )[1 + i]] ],
                                                 2 ),
                                         InjectionOfCofactorOfCoproductWithGivenCoproduct( sFinSets,
                                                 B1,
                                                 1 + AsList( pi323 )[1 + i],
                                                 N1 ) ],
                                       N1 ) )[1 + 0] ),
                  N1 );
    
    mus := List( N0N0N0, i ->
                 List( B2[1 + i], j ->
                       [ MorphismConstructor( sFinSets,
                               T,
                               [ AsList(
                                       ProjectionInFactorOfDirectProduct( sFinSets,
                                               [ B1[1 + AsList( p312 )[1 + i]],
                                                 B1[1 + AsList( p323 )[1 + i]] ],
                                               1 ) )[1 + j] ],
                               B1[1 + AsList( p312 )[1 + i]] ),
                         MorphismConstructor( sFinSets,
                                 T,
                                 [ AsList(
                                         ProjectionInFactorOfDirectProduct( sFinSets,
                                                 [ B1[1 + AsList( p312 )[1 + i]],
                                                   B1[1 + AsList( p323 )[1 + i]] ],
                                                 2 ) )[1 + j] ],
                                 B1[1 + AsList( p323 )[1 + i]] ) ] ) );
    
    #% CAP_JIT_DROP_NEXT_STATEMENT
    Assert( 0, Length( Concatenation( mus ) ) = Length( N2 ) );
    
    #% CAP_JIT_DROP_NEXT_STATEMENT
    Assert( 0, ForAll( mus, mu -> ForAll( mu, m -> IsWellDefined( m[1] ) and IsWellDefined( m[2] ) ) ) );
    
    mus1 := List( N0N0N0, i ->
                  List( B2[1 + i], j ->
                        PreCompose( B,
                                InterpretMorphismFromDistinguishedObjectToHomomorphismStructureAsMorphism( B,
                                        B0[1 + AsList( p31 )[1 + i]],
                                        B0[1 + AsList( p32 )[1 + i]],
                                        mus[1 + i][1 + j][1] ),
                                InterpretMorphismFromDistinguishedObjectToHomomorphismStructureAsMorphism( B,
                                        B0[1 + AsList( p32 )[1 + i]],
                                        B0[1 + AsList( p33 )[1 + i]],
                                        mus[1 + i][1 + j][2] ) ) ) );
    
    mus2 := List( N0N0N0, i ->
                  List( B2[1 + i], j ->
                        InterpretMorphismAsMorphismFromDistinguishedObjectToHomomorphismStructure( B,
                                mus1[1 + i][1 + j] ) ) );
    
    mus3 := List( N0N0N0, i ->
                  UniversalMorphismFromCoproductWithGivenCoproduct( sFinSets,
                          List( mus2[1 + i], Source ),
                          B1[1 + AsList( p313 )[1 + i]],
                          mus2[1 + i],
                          B2[1 + i] ) );
    
    #% CAP_JIT_DROP_NEXT_STATEMENT
    Assert( 0, ForAll( [ 1 .. Length( N0N0N0 ) ], i -> Source( mus3[i] ) = B2[i] ) );
    
    ## N2 -> N1
    mu := MorphismConstructor( sFinSets,
                  N2,
                  List( N2, i ->
                        AsList(
                               PreComposeList( sFinSets,
                                       T,
                                       [ LiftAlongMonomorphism( sFinSets,
                                               InjectionOfCofactorOfCoproductWithGivenCoproduct( sFinSets,
                                                       B2,
                                                       1 + AsList( pi3 )[1 + i],
                                                       N2 ),
                                               N2_elements[1 + i] ),
                                         mus3[1 + AsList( pi3 )[1 + i]],
                                         InjectionOfCofactorOfCoproductWithGivenCoproduct( sFinSets,
                                                 B1,
                                                 1 + AsList( pi313 )[1 + i],
                                                 N1 ) ],
                                       N1 ) )[1 + 0] ),
                  N1 );
    
    return Pair( Triple( N0, N1, N2 ),
                 NTuple( 8, id, s, t, is, it, ps, pt, mu ) );
    
end );

##
InstallMethod( NerveTruncatedInDegree2AsFunctor,
        [ IsCapCategory and IsFinite ],
        
  function ( B )
    local nerve, nerve_ValuesOnAllObjects, nerve_ValuesOnAllGeneratingMorphisms, name, Delta2, Delta2op;
    
    nerve := NerveTruncatedInDegree2Data( B );
    
    nerve_ValuesOnAllObjects := rec( C0 := nerve[1][1], C1 := nerve[1][2], C2 := nerve[1][3] );
    
    nerve_ValuesOnAllGeneratingMorphisms :=
      rec(
          id := nerve[2][1],
          s := nerve[2][2],
          t := nerve[2][3],
          is := nerve[2][4],
          it := nerve[2][5],
          ps := nerve[2][6],
          pt := nerve[2][7],
          mu := nerve[2][8] );
    
    name := Concatenation( "Nerve of ", Name( B ) );
    
    ## Delta(C0,C1,C2)[id:C1->C0,s:C0->C1,t:C0->C1,is:C2->C1,it:C2->C1,ps:C1->C2,pt:C1->C2,mu:C1->C2]
    Delta2 := SimplicialCategoryTruncatedInDegree( 2 );
    
    ## Delta_op(C0,C1,C2)[id:C0->C1,s:C1->C0,t:C1->C0,is:C1->C2,it:C1->C2,ps:C2->C1,pt:C2->C1,mu:C2->C1]
    Delta2op := OppositeFpCategory( Delta2 );
    
    return CapFunctor( Delta2op, nerve_ValuesOnAllObjects, nerve_ValuesOnAllGeneratingMorphisms );
    
end );

##
InstallMethodForCompilerForCAP( YonedaNaturalEpimorphisms,
        [ IsCapCategory and IsFinite ],
        
  function ( B )
    local sFinSets, objs, mors, o, m, Hom2, hom3, Hom3, tum2, emb2, sum2, iso2,
          B0, N0, N1, N2, D, precompose, pt, mu, s;
    
    sFinSets := RangeCategoryOfHomomorphismStructure( B );
    
    ## sFinSets must be the category skeletal finite sets
    Assert( 0, IsCategoryOfSkeletalFinSets( sFinSets ) );
    
    objs := SetOfObjects( B );
    mors := SetOfGeneratingMorphisms( B );
    
    o := Length( objs );
    m := Length( mors );
    
    ## [ [ Hom(a, c) ]_{a ∈ B} ]_{c ∈ B}:
    Hom2 := List( objs, c ->
                  List( objs, a ->
                        HomomorphismStructureOnObjects( B, a, c ) ) );
    
    ## [ [ [ ( Hom(a, b), Hom(b, c) ) ]_{b ∈ B} ]_{a ∈ B} ]_{c ∈ B}:
    hom3 := List( [ 1 .. o ], c ->
                  List( [ 1 .. o ], a ->
                        List( [ 1 .. o ], b ->
                              [ Hom2[b][a], Hom2[c][b] ] ) ) );
    
    ## [ [ [ Hom(a, b) × Hom(b, c) ]_{b ∈ B} ]_{a ∈ B} ]_{c ∈ B}:
    Hom3 := List( [ 1 .. o ], c ->
                  List( [ 1 .. o ], a ->
                        List( [ 1 .. o ], b ->
                              DirectProduct( sFinSets, hom3[c][a][b] ) ) ) );
    
    ## [ [ Hom(a, b) × Hom(b, c) ]_{a, b ∈ B} ]_{c ∈ B}:
    ## tum2 := List( Hom3, L -> Concatenation( TransposedMat( L ) ) );
    tum2 := List( [ 1 .. o ], c ->
                  Concatenation(
                          List( [ 1 .. o ], b ->
                                List( [ 1 .. o ], a ->
                                      Hom3[c][a][b] ) ) ) );
    
    ## The embeddings into the double coproducts
    ## [ [ Hom(a, b) × Hom(b, c) ↪ ⊔_{a' ∈ B} ⊔_{b' ∈ B} Hom(a', b') × Hom(b', c) ]_{a ∈ B, b ∈ B} ]_{c ∈ B}:
    emb2 := List( [ 1 .. o ], c ->
                  Concatenation(
                          List( [ 1 .. o ], a ->
                                List( [ 1 .. o ], b ->
                                      InjectionOfCofactorOfCoproduct( sFinSets,
                                              tum2[c], o * ( b - 1 ) + a ) ) ) ) );
    
    ## [ [ Hom(a, b) × Hom(b, c) ]_{b, a ∈ B} ]_{c ∈ B}:
    sum2 := List( Hom3, L -> Concatenation( L ) );
    
    ## The isomorphisms
    ## [ ⊔_{a ∈ B} ⊔_{b ∈ B} Hom(a, b) × Hom(b, c) → ⊔_{b ∈ B} ⊔_{a ∈ B} Hom(a, b) × Hom(b, c) ]_{c ∈ B}:
    iso2 := List( [ 1 .. o ], c ->
                  UniversalMorphismFromCoproduct( sFinSets,
                          sum2[c],
                          Coproduct( sFinSets,
                                  tum2[c] ),
                          emb2[c] ) );
    
    ## The constant functor of 0-cells B → sFinSets, c ↦ B_0, ψ ↦ id_{B_0}
    B0 := ObjectConstructor( sFinSets, o );
    
    N0 := Pair( ListWithIdenticalEntries( o, B0 ),
                ListWithIdenticalEntries( m, IdentityMorphism( sFinSets, B0 ) ) );
    
    ## The Yoneda functor B → sFinSets, c ↦ Hom(-, c), ψ ↦ Hom(-, ψ), where
    ## Hom(-, c) := ⊔_{a ∈ B} Hom(a, c),
    ## Hom(-, ψ) := ⊔_{a ∈ B} Hom(id_a, ψ):
    N1 := Pair(
               List( [ 1 .. o ], c ->
                     ## Hom(-, c) := ⊔_{a ∈ B} Hom(a, c):
                     Coproduct( sFinSets, Hom2[c] ) ),
               List( mors, psi ->
                     ## Hom(-, ψ) := ⊔_{a ∈ B} Hom(id_a, ψ):
                     CoproductFunctorial( sFinSets,
                             List( objs, a ->
                                   HomomorphismStructureOnMorphisms( B,
                                           IdentityMorphism( B, a ), psi ) ) ) ) );
    
    ## The 2-Yoneda functor B → sFinSets, c ↦ Hom(-, -) × Hom(-, c) and ψ ↦ Hom(-, -) × Hom(-, ψ), where
    ## Hom(-, -) × Hom(-, c) := ⊔_{a ∈ B} ⊔_{b ∈ B} Hom(a, b) × Hom(b, c),
    ## Hom(-, -) × Hom(-, ψ) := ⊔_{a ∈ B} ⊔_{b ∈ B} Hom(id_a, id_b) × Hom(id_b, ψ):
    N2 := Pair(
               List( [ 1 .. o ], c ->
                     ## Hom(-, -) × Hom(-, c) := ⊔_{a ∈ B} ⊔_{b ∈ B} Hom(a, b) × Hom(b, c):
                     Coproduct( sFinSets,
                             Concatenation( Hom3[c] ) ) ),
               List( mors, psi ->
                     ## Hom(-, -) × Hom(-, ψ) := ⊔_{a ∈ B} ⊔_{b ∈ B} Hom(id_a, id_b) × Hom(id_b, ψ):
                     CoproductFunctorial( sFinSets,
                             Concatenation(
                                     List( objs, a ->
                                           List( objs, b ->
                                                 ## Hom(id_a, id_b) × Hom(id_b, ψ):
                                                 DirectProductFunctorial( sFinSets,
                                                         [ HomomorphismStructureOnMorphisms( B,
                                                                 IdentityMorphism( B, a ), IdentityMorphism( B, b ) ),
                                                           HomomorphismStructureOnMorphisms( B,
                                                                   IdentityMorphism( B, b ), psi ) ] ) ) ) ) ) ) );
    
    D := DistinguishedObjectOfHomomorphismStructure( B );
    
    ## mu_{a,b,c}: Hom(a, b) × Hom(b, c) ↠ Hom(a, c):
    precompose :=
      function ( a, b, c )
        return
          MorphismConstructor( sFinSets,
                  Hom3[c][a][b], # = Hom(a, b) × Hom(b, c)
                  List( Hom3[c][a][b],
                        function ( i )
                          local d, d_ab, d_bc, m_ab, m_bc, m;
                          
                          ## D → Hom(a, b) × Hom(b, c):
                          d := MorphismConstructor( sFinSets, D, [ i ], Hom3[c][a][b] );
                          
                          ## D → Hom(a, b) × Hom(b, c) → Hom(a, b):
                          d_ab := PreCompose( sFinSets, d, ProjectionInFactorOfDirectProduct( sFinSets, hom3[c][a][b], 1 ) );
                          
                          ## D → Hom(a, b) × Hom(b, c) → Hom(b, c):
                          d_bc := PreCompose( sFinSets, d, ProjectionInFactorOfDirectProduct( sFinSets, hom3[c][a][b], 2 ) );
                          
                          ## the map a → b corresponding to d_ab:
                          m_ab := InterpretMorphismFromDistinguishedObjectToHomomorphismStructureAsMorphism( B, objs[a], objs[b], d_ab );
                          
                          ## the map b → c corresponding to d_bc:
                          m_bc := InterpretMorphismFromDistinguishedObjectToHomomorphismStructureAsMorphism( B, objs[b], objs[c], d_bc );
                          
                          ## the composition a → b → c:
                          m := PreCompose( B, m_ab, m_bc );
                          
                          ## reinterpret the composition m as a morphism D → Hom(a, c),
                          ## then get its number as an element in Hom(a, c):
                          return AsList( InterpretMorphismAsMorphismFromDistinguishedObjectToHomomorphismStructure( B, m ) )[1 + 0];
                          
                      end ),
                  Hom2[c][a] ); # = Hom(a, c)
    end;
    
    ## The Yoneda projection is a natrual epimorphism from the 2-Yoneda functor to the Yoneda functor
    ## B → sFinSets, c ↦ Hom(-, -) × Hom(-, c) and ψ ↦ Hom(-, -) × Hom(-, ψ)
    pt := List( [ 1 .. o ], c ->
                ## ⊔_{a ∈ B} ⊔_{b ∈ B} Hom(a, b) × Hom(b, c) ↠ ⊔_{b ∈ B} Hom(b, c):
                PreCompose( sFinSets,
                        ## ⊔_{a ∈ B} ⊔_{b ∈ B} Hom(a, b) × Hom(b, c) → ⊔_{b ∈ B} ⊔_{a ∈ B} Hom(a, b) × Hom(b, c):
                        iso2[c],
                        ## ⊔_{b ∈ B} ⊔_{a ∈ B} Hom(a, b) × Hom(b, c) ↠ ⊔_{b ∈ B} Hom(b, c):
                        CoproductFunctorial( sFinSets,
                                List( [ 1 .. o ], b ->
                                      ## ⊔_{a ∈ B} Hom(a, b) × Hom(b, c) ↠ Hom(b, c):
                                      UniversalMorphismFromCoproduct( sFinSets,
                                              List( [ 1 .. o ], a -> Hom3[c][a][b] ),
                                              Hom2[c][b],
                                              List( [ 1 .. o ], a ->
                                                    ## Hom(a, b) × Hom(b, c) ↠ Hom(b, c):
                                                    ProjectionInFactorOfDirectProduct( sFinSets,
                                                            hom3[c][a][b], 2 ) ) ) ) ) ) );
    
    ## The Yoneda composition is a natrual epimorphism from the 2-Yoneda functor to the Yoneda functor
    ## Hom(-, -) × Hom(-, c) ↠ Hom(-, c):
    mu := List( [ 1 .. o ], c ->
                ## ⊔_{a ∈ B} ⊔_{b ∈ B} Hom(a, b) × Hom(b, c) ↠ ⊔_{a ∈ B} Hom(a, c):
                CoproductFunctorial( sFinSets,
                        List( [ 1 .. o ], a ->
                              ## ⊔_{b ∈ B} Hom(a, b) × Hom(b, c) ↠ Hom(a, c):
                              UniversalMorphismFromCoproduct( sFinSets,
                                      List( [ 1 .. o ], b -> Hom3[c][a][b] ),
                                      Hom2[c][a],
                                      List( [ 1 .. o ], b ->
                                            ## Hom(a, b) × Hom(b, c) ↠ Hom(a, c):
                                            precompose( a, b, c ) ) ) ) ) );
    
    ## The source fibration is a natrual morphism from the Yoneda functor to the constant functor of 0-cells
    ## Hom(-, c) → B_0:
    s := List( [ 1 .. o ], c ->
               ## ⊔_{a ∈ B} Hom(a, c) → B_0, ϕ ↦ Source(ϕ)
               CoproductFunctorial( sFinSets,
                       List( [ 1 .. o ], a ->
                             ## Hom(a, c) → {a}, ϕ ↦ a
                             UniversalMorphismIntoTerminalObject( sFinSets,
                                     Hom2[c][a] ) ) ) );
    
    return NTuple( 6, N0, N1, N2, pt, mu, s );
    
end );

##
InstallMethod( YonedaProjectionAsNaturalEpimorphism,
        [ IsFpCategory and HasRangeCategoryOfHomomorphismStructure ],
        
  function ( B )
    local Yepis, sFinSets, N1, N2, pt;
    
    Yepis := YonedaNaturalEpimorphisms( B );
    
    sFinSets := RangeCategoryOfHomomorphismStructure( B );
    
    ## sFinSets must be the category skeletal finite sets
    Assert( 0, IsCategoryOfSkeletalFinSets( sFinSets ) );
    
    ## The Yoneda functor B → sFinSets, c ↦ Hom(-, c), ψ ↦ Hom(-, ψ), where
    ## Hom(-, c) := ⊔_{a ∈ B} Hom(a, c),
    ## Hom(-, ψ) := ⊔_{a ∈ B} Hom(id_a, ψ):
    N1 := CapFunctor( B, Yepis[2][1], Yepis[2][2], sFinSets );
    
    ## The 2-Yoneda functor B → sFinSets, c ↦ Hom(-, -) × Hom(-, c) and ψ ↦ Hom(-, -) × Hom(-, ψ), where
    ## Hom(-, -) × Hom(-, c) := ⊔_{a ∈ B} ⊔_{b ∈ B} Hom(a, b) × Hom(b, c),
    ## Hom(-, -) × Hom(-, ψ) := ⊔_{a ∈ B} ⊔_{b ∈ B} Hom(id_a, id_b) × Hom(id_b, ψ):
    N2 := CapFunctor( B, Yepis[3][1], Yepis[3][2], sFinSets );
    
    ## The Yoneda projection is a natrual epimorphism from the 2-Yoneda functor to the Yoneda functor
    ## B → sFinSets, c ↦ Hom(-, -) × Hom(-, c) and ψ ↦ Hom(-, -) × Hom(-, ψ)
    pt := NaturalTransformation(
                  N2,   ## The 2-Yoneda functor: B → sFinSets, c ↦ Hom(-, -) × Hom(-, c) and ψ ↦ Hom(-, -) × Hom(-, ψ)
                  Yepis[4],
                  N1 ); ## The Yoneda functor B → sFinSets, c ↦ Hom(-, c), ψ ↦ Hom(-, ψ)
    
    #% CAP_JIT_DROP_NEXT_STATEMENT
    SetIsEpimorphism( pt, true );
    
    return pt;
    
end );

##
InstallMethod( YonedaCompositionAsNaturalEpimorphism,
        [ IsFpCategory and HasRangeCategoryOfHomomorphismStructure ],
        
  function ( B )
    local Yepis, sFinSets, N1, N2, mu;
    
    Yepis := YonedaNaturalEpimorphisms( B );
    
    sFinSets := RangeCategoryOfHomomorphismStructure( B );
    
    ## sFinSets must be the category skeletal finite sets
    Assert( 0, IsCategoryOfSkeletalFinSets( sFinSets ) );
    
    ## The Yoneda functor B → sFinSets, c ↦ Hom(-, c), ψ ↦ Hom(-, ψ), where
    ## Hom(-, c) := ⊔_{a ∈ B} Hom(a, c),
    ## Hom(-, ψ) := ⊔_{a ∈ B} Hom(id_a, ψ):
    N1 := CapFunctor( B, Yepis[2][1], Yepis[2][2], sFinSets );
    
    ## The 2-Yoneda functor B → sFinSets, c ↦ Hom(-, -) × Hom(-, c) and ψ ↦ Hom(-, -) × Hom(-, ψ), where
    ## Hom(-, -) × Hom(-, c) := ⊔_{a ∈ B} ⊔_{b ∈ B} Hom(a, b) × Hom(b, c),
    ## Hom(-, -) × Hom(-, ψ) := ⊔_{a ∈ B} ⊔_{b ∈ B} Hom(id_a, id_b) × Hom(id_b, ψ):
    N2 := CapFunctor( B, Yepis[3][1], Yepis[3][2], sFinSets );
    
    ## The Yoneda composition is a natrual epimorphism from the 2-Yoneda functor to the Yoneda functor
    ## Hom(-, -) × Hom(-, c) ↠ Hom(-, c):
    mu := NaturalTransformation(
                  N2, ## The 2-Yoneda functor: B → sFinSets, c ↦ Hom(-, -) × Hom(-, c) and ψ ↦ Hom(-, -) × Hom(-, ψ)
                  Yepis[5],
                  N1 ); ## The Yoneda functor B → sFinSets, c ↦ Hom(-, c), ψ ↦ Hom(-, ψ)
    
    #% CAP_JIT_DROP_NEXT_STATEMENT
    SetIsEpimorphism( mu, true );
    
    return mu;
    
end );

##
InstallMethod( YonedaFibrationAsNaturalTransformation,
        [ IsFpCategory and HasRangeCategoryOfHomomorphismStructure ],
        
  function ( B )
    local Yepis, sFinSets, N0, N1;
    
    Yepis := YonedaNaturalEpimorphisms( B );
    
    sFinSets := RangeCategoryOfHomomorphismStructure( B );
    
    ## sFinSets must be the category skeletal finite sets
    Assert( 0, IsCategoryOfSkeletalFinSets( sFinSets ) );
    
    ## The constant functor of 0-cells B → sFinSets, c ↦ B_0, ψ ↦ id_{B_0}
    N0 := CapFunctor( B, Yepis[1][1], Yepis[1][2], sFinSets );
    
    ## The Yoneda functor B → sFinSets, c ↦ Hom(-, c), ψ ↦ Hom(-, ψ), where
    ## Hom(-, c) := ⊔_{a ∈ B} Hom(a, c),
    ## Hom(-, ψ) := ⊔_{a ∈ B} Hom(id_a, ψ):
    N1 := CapFunctor( B, Yepis[2][1], Yepis[2][2], sFinSets );
    
    ## The source fibration is a natrual morphism from the Yoneda functor to the constant functor of 0-cells
    ## Hom(-, c) → B_0:
    return NaturalTransformation(
                   N1, ## The Yoneda functor B → sFinSets, c ↦ Hom(-, c), ψ ↦ Hom(-, ψ)
                   Yepis[6],
                   N0 ); ## The constant functor of 0-cells
    
end );

##
InstallMethodForCompilerForCAP( TruthMorphismOfTrueToSieveFunctorAndEmbedding,
        [ IsCapCategory and IsFinite ],
        
  function ( B )
    local sFinSets, D, Omega, Yepis, Ymu, Ypt, sieves, defining_triple, lobjs, lmors, arrows, id, N1,
          Sieves, Sieves_emb, Sieves_maximal,
          HomHomOmega_objects, HomHomOmega_morphisms, Sieves_objects, Sieves_morphisms,
          Constant_functor, Sieves_functor, HomHomOmega_functor;
    
    sFinSets := RangeCategoryOfHomomorphismStructure( B );
    
    ## sFinSets must be the category skeletal finite sets
    Assert( 0, IsCategoryOfSkeletalFinSets( sFinSets ) );
    
    D := DistinguishedObjectOfHomomorphismStructure( B );
    
    Omega := SubobjectClassifier( sFinSets );
    
    Yepis := YonedaNaturalEpimorphisms( B );
    
    Ypt := Yepis[4]; # YonedaProjectionAsNaturalEpimorphism( B );
    Ymu := Yepis[5]; # YonedaCompositionAsNaturalEpimorphism( B );
    
    sieves :=
      function ( c )
        local pt_c, mu_c, hom_c, power, action, maximal, emb;
        
        ## Hom(-, -) × Hom(-, c) ↠ Hom(-, c)
        pt_c := Ypt[c];
        
        ## Hom(-, -) × Hom(-, c) ↠ Hom(-, c)
        mu_c := Ymu[c];
        
        ## Hom(-, c) := ⊔_{a ∈ B} Hom(a, c)
        hom_c := Range( mu_c );
        
        ## Hom(Hom(-, c), Ω) := Hom(⊔_{a ∈ B} Hom(a, c), Ω)
        power := HomomorphismStructureOnObjects( sFinSets, hom_c, Omega );
        
        ## define the action as an endomorphism on Hom(Hom(-, c), Ω)
        action :=
          MorphismConstructor( sFinSets,
                  power, ## Hom(Hom(-, c), Ω)
                  List( power, i ->
                        ## interpreted as an "element" D → Hom(Hom(-, c), Ω)
                        AsList( InterpretMorphismAsMorphismFromDistinguishedObjectToHomomorphismStructure( sFinSets,
                                ## interpreted as a classifying morphism χ_{s'}: Hom(-, c) → Ω
                                ClassifyingMorphismOfSubobject( sFinSets,
                                        ## s' ↪ Hom(-, c)
                                        ImageEmbedding( sFinSets,
                                                ## Hom(-, -) × s → Hom(-, c)
                                                PreCompose( sFinSets,
                                                        ## Hom(-, -) × s ↪ Hom(-, -) × Hom(-, c)
                                                        ProjectionInFactorOfFiberProduct( sFinSets,
                                                                [ pt_c,
                                                                  ## interpreted as a subobject s ↪ Hom(-, c)
                                                                  SubobjectOfClassifyingMorphism( sFinSets,
                                                                          ## interpreted as a  classifying morphism χ_s: Hom(-, c) → Ω
                                                                          InterpretMorphismFromDistinguishedObjectToHomomorphismStructureAsMorphism( sFinSets,
                                                                                  hom_c,
                                                                                  Omega,
                                                                                  ## an "element" D → Hom(Hom(-, c), Ω)
                                                                                  MorphismConstructor( sFinSets, D, [ i ], power ) ) )
                                                                  ], 1 ),
                                                        ## μ_c: Hom(-, -) × Hom(-, c) ↠ Hom(-, c)
                                                        mu_c ) ) ) ) )[1 + 0] ),
                  power ); ## Hom(Hom(-, c), Ω)
        
        ## The sieves on c are the fixed points of the above action on Hom(Hom(-, c), Ω),
        ## resulting in the embedding Sieves(c) ↪ Hom(Hom(-, c), Ω):
        emb := EmbeddingOfEqualizer( sFinSets, power, [ action, IdentityMorphism( sFinSets, power ) ] );
        
        ## the "element" D → Sieves(c) corresponding to the maximal sieve:
        maximal := LiftAlongMonomorphism( sFinSets,
                           ## Sieves(c) ↪ Hom(Hom(-, c), Ω):
                           emb,
                           ## interpreted as an "element" D → Hom(Hom(-, c), Ω)
                           InterpretMorphismAsMorphismFromDistinguishedObjectToHomomorphismStructure( sFinSets,
                                   ## the corresponding classifying morphism χ: Hom(-, c) → Ω
                                   ClassifyingMorphismOfSubobject( sFinSets,
                                           ## id: Hom(-, c) → Hom(-, c)
                                           IdentityMorphism( sFinSets, hom_c ) ) ) );
        
        return Pair( emb, maximal );
        
    end;
    
    defining_triple := DefiningTripleOfUnderlyingQuiver( B );
    
    lobjs := defining_triple[1];
    lmors := defining_triple[2];
    
    arrows := defining_triple[3];
    
    id := IdentityMorphism( sFinSets, Omega );
    
    N1 := Yepis[2]; # Range( Ypt );
    
    Sieves := List( [ 1 .. lobjs ], o -> sieves( o ) );
    Sieves_emb := List( Sieves, s -> s[1] );
    Sieves_maximal := List( Sieves, s -> s[2] );
    
    ## Hom(Hom(-, c), Ω)
    HomHomOmega_objects := List( Sieves_emb, Range );
    HomHomOmega_morphisms := List( [ 1 .. lmors ], m ->
                                   HomomorphismStructureOnMorphisms( sFinSets,
                                           N1[2][m], # N1( m )
                                           id ) );
    
    Sieves_objects := List( Sieves_emb, Source );
    Sieves_morphisms := List( [ 1 .. lmors ], m ->
                              LiftAlongMonomorphism( sFinSets,
                                      Sieves_emb[1 + arrows[m][1]], # Source( m )
                                      PreCompose( sFinSets,
                                              Sieves_emb[1 + arrows[m][2]], # Range( m )
                                              HomHomOmega_morphisms[m] ) ) );
    
    return NTuple( 5,
                   Pair( Sieves_objects,
                         Sieves_morphisms ),
                   Pair( ListWithIdenticalEntries( lobjs, D ),
                         ListWithIdenticalEntries( lmors, IdentityMorphism( sFinSets, D ) ) ),
                   Pair( HomHomOmega_objects,
                         HomHomOmega_morphisms ),
                   Sieves_maximal,
                   Sieves_emb  );
    
end );

##
InstallMethod( SieveFunctor,
        [ IsFpCategory ],
        
  function ( B )
    local Sieves, Bop, sFinSets;
    
    # asserts that IsCategoryOfSkeletalFinSets( RangeCategoryOfHomomorphismStructure( B ) )
    Sieves := TruthMorphismOfTrueToSieveFunctorAndEmbedding( B );
    
    Bop := OppositeFpCategory( B );
    
    sFinSets := RangeCategoryOfHomomorphismStructure( B );
    
    return CapFunctor( Bop, Sieves[1][1], Sieves[1][2], sFinSets );
    
end );

##
InstallMethod( TruthMorphismOfTrueToSieveFunctor,
        [ IsFpCategory ],
        
  function ( B )
    local Sieves, Bop, sFinSets, Constant_functor, Sieves_maximal, Sieves_functor;
    
    # asserts that IsCategoryOfSkeletalFinSets( RangeCategoryOfHomomorphismStructure( B ) )
    Sieves := TruthMorphismOfTrueToSieveFunctorAndEmbedding( B );
    
    Bop := OppositeFpCategory( B );
    
    sFinSets := RangeCategoryOfHomomorphismStructure( B );
    
    Constant_functor := CapFunctor( Bop, Sieves[2][1], Sieves[2][2], sFinSets );
    Sieves_maximal := Sieves[4];
    Sieves_functor := SieveFunctor( B );
    
    ## T → Sieves, c ↦ ( T(c) = {*} → Sieves(c), * ↦ maximal_sieve(c) := Hom(-, c) )
    return NaturalTransformation(
                   Constant_functor,
                   Sieves_maximal,
                   Sieves_functor );
    
end );

##
InstallMethod( EmbeddingOfSieveFunctor,
        [ IsFpCategory ],
        
  function ( B )
    local Sieves, Bop, sFinSets, Sieves_functor, Sieves_emb, HomHomOmega_functor;
    
    # asserts that IsCategoryOfSkeletalFinSets( RangeCategoryOfHomomorphismStructure( B ) )
    Sieves := TruthMorphismOfTrueToSieveFunctorAndEmbedding( B );
    
    Bop := OppositeFpCategory( B );
    
    sFinSets := RangeCategoryOfHomomorphismStructure( B );
    
    Sieves_functor := SieveFunctor( B );
    Sieves_emb := Sieves[5];
    HomHomOmega_functor := CapFunctor( Bop, Sieves[3][1], Sieves[3][2], sFinSets );
    
    ## Sieves → Hom(Hom(-, c), Ω), c ↦ ( Sieves(c) ↪ Hom(Hom(-, c), Ω), s ↦ s )
    return NaturalTransformation(
                   Sieves_functor,
                   Sieves_emb,
                   HomHomOmega_functor );
    
end );

####################################
#
# methods for properties:
#
####################################

##
InstallMethod( IsCommutative,
        "for an FpCategory",
        [ IsFpCategory ],
     
  function( A )
    local arrows, i, j;
    
    arrows := Arrows( UnderlyingQuiverAlgebra( A ) );
    
    for i in [ 1 .. Length( arrows ) ] do
      for j in [ (i+1) .. Length( arrows ) ] do
        if not arrows[i] * arrows[j] = arrows[j] * arrows[i] then
          return false;
        fi;
      od;
    od;
    
    return true;
    
end );

####################################
#
# View, Print, and Display methods:
#
####################################

##
InstallMethod( ViewString,
        "for an object in a f.p. category",
        [ IsObjectInFpCategory ],
        
  function( o )
    
    return Concatenation( "<", StringView( UnderlyingVertex( o ) ), ">" );
    
end );

##
InstallMethod( ViewObj,
        "for a morphism in a f.p. category",
        [ IsMorphismInFpCategory ],
        
  function( m )
    
    if IsRightQuiverAlgebra( UnderlyingQuiverAlgebra( CapCategory( m ) ) ) then
        ViewObj( UnderlyingVertex( Source( m ) ) );
        Print( "-[" );
        ViewObj( BasisPathOfPathAlgebraBasisElement( UnderlyingQuiverAlgebraElement( m ) ) );
        Print( "]->" );
        ViewObj( UnderlyingVertex( Range( m ) ) );
    else
        ViewObj( UnderlyingVertex( Range( m ) ) );
        Print( "<-[" );
        ViewObj( BasisPathOfPathAlgebraBasisElement( UnderlyingQuiverAlgebraElement( m ) ) );
        Print( "]-" );
        ViewObj( UnderlyingVertex( Source( m ) ) );
    fi;
    
end );

##
InstallMethod( PrintObj,
        "for an object in a f.p. category",
        [ IsObjectInFpCategory ],
        
  function( o )
    
    ViewObj( o );
    
end );

##
InstallMethod( PrintObj,
        "for a morphism in a f.p. category",
        [ IsMorphismInFpCategory ],
        
  function( m )
    
    ViewObj( m );
    
end );

##
InstallMethod( Display,
        "for an object in a f.p. category",
        [ IsObjectInFpCategory ],
        
  function( o )
    
    ViewObj( o );
    Print( "\n" );
    
end );

##
InstallMethod( Display,
        "for a morphism in a f.p. category",
        [ IsMorphismInFpCategory ],
        
  function( m )
    
    ViewObj( m );
    Print( "\n" );
    
end );

##
InstallMethod( LaTeXOutput,
          [ IsObjectInFpCategory ],
          
  o -> LaTeXStringForQPA( UnderlyingVertex( o ) )
);

##
InstallMethod( LaTeXOutput,
          [ IsMorphismInFpCategory ],
          
  function( m )
    local s;
    
    s := LaTeXStringForQPA( UnderlyingQuiverAlgebraElement( m ) );
    
    if ValueOption( "OnlyDatum" ) = true then
      
      return s;
      
    else
      
      return Concatenation(
                "{", LaTeXOutput( Source( m ) ), "}-\\left(",
                "{", s, "}\\right)\\rightarrow",
                "{", LaTeXOutput( Range( m ) ), "}"
              );
              
    fi;
    
end );
