# SPDX-License-Identifier: GPL-2.0-or-later
# Algebroids: Algebroids and bialgebroids as preadditive categories generated by enhanced quivers
#
# Implementations
#

#############################################
#
# PreSheaves of algebroids from data tables
#
############################################

##
InstallMethod( PreSheaves,
          [ IsAlgebroidFromDataTables ],
  
  function ( A )
    local bool, PSh;
    
    bool := CAP_INTERNAL_RETURN_OPTION_OR_DEFAULT( "enhance_presheaves_category_of_linear_algebroid_from_data", true );
    
    if bool then
        
        PSh := PreSheaves( A : enhance_presheaves_category_of_linear_algebroid_from_data := false, FinalizeCategory := false );
        
        if not IsFinalized( PSh ) then
          
          AddIsEqualForMorphisms( PSh,
            function ( PSh, eta1, eta2 )
              local A, C;
              
              A := Source( PSh );
              C := Target( PSh );
              
              return ForAll( SetOfObjects( A ), o -> IsEqualForMorphisms( C, eta1( o ), eta2( o ) ) );
              
          end );
          
          PSh!.is_computable := true;
          
          AddIsCongruentForMorphisms( PSh,
            function ( PSh, eta1, eta2 )
              local A, C;
              
              A := Source( PSh );
              C := Target( PSh );
              
              return ForAll( SetOfObjects( A ), o -> IsCongruentForMorphisms( C, eta1( o ), eta2( o ) ) );
              
          end );
          
          AddIsEqualForObjects( PSh,
            function ( PSh, obj1, obj2 )
              local A, C;
              
              A := Source( PSh );
              C := Target( PSh );
              
              return ForAll( SetOfObjects( A ), o -> IsEqualForObjects( C, obj1( o ), obj2( o ) ) )
                        and ForAll( SetOfGeneratingMorphisms( A ), m -> IsEqualForMorphisms( C, obj1( m ), obj2( m ) ) );
              
          end );
          
          AddIsWellDefinedForObjects( PSh,
            function ( PSh, obj )
              local A, C, gmors, pairs;
              
              A := Source( PSh );
              C := Target( PSh );
              
              gmors := SetOfGeneratingMorphisms( A );
              pairs := IndicesPairsOfCompatibleMorphisms( UnderlyingQuiver( A ) );
              
              return ForAll( pairs, p -> IsCongruentForMorphisms( C, obj( PreCompose( A, gmors[p[1]], gmors[p[2]] ) ), PostCompose( C, obj( gmors[p[1]] ), obj( gmors[p[2]] ) ) ) );
              
          end );
          
          AddIsWellDefinedForMorphisms( PSh,
            function ( PSh, mor )
              local A, C, gmors;
              
              A := Source( PSh );
              C := Target( PSh );
              
              gmors := SetOfGeneratingMorphisms( A );
              
              return IsWellDefinedForObjects( PSh, Source( mor ) )
                    and IsWellDefinedForObjects( PSh, Target( mor ) )
                    and ForAll( gmors, g -> IsCongruentForMorphisms( C, PreCompose( C,  Source( mor )( g ), mor( Source( g ) ) ), PreCompose( C, mor( Target( g ) ), Target( mor )( g ) ) ) );
              
          end );
          
          Finalize( PSh );
          
        fi;
        
        return PSh;
        
    else
        
        TryNextMethod( );
        
    fi;
    
end );

#
# Let k be a commutative ring
# Let A a k-algebroid defined by data-tables, k-rows and PSh := PreSheaves(A, k-rows).
# Let Y: A -> PSh be the Yoneda embedding functor.
# For two objects obj ∈ A and F ∈ PSh we have Hom_{k-rows}(1,F(obj)) ≃ F(obj) ≃ Hom_PSh(Y(obj), F).
#
InstallOtherMethod( MorphismFromRepresentableFunctor,
          [ IsPreSheafCategory, IsObjectInAlgebroidFromDataTables, IsObjectInPreSheafCategory, IsObjectInPreSheafCategory, IsCategoryOfRowsMorphism ],
  
  function ( PSh, obj, Y_obj, F, ell )
    local A, C, func_of_presheaf_morphism;
    
    A := Source( PSh );
    C := Target( PSh );
    
    if not IsIdenticalObj( A, CapCategory( obj ) ) then
        Error( "the argument <obj> passed to 'MorphismFromRepresentableFunctor' must be an object in ", Name( A ) );
    fi;
    
    if not IsIdenticalObj( C, CapCategory( ell ) ) then
        Error( "the argument <ell> passed to 'MorphismFromRepresentableFunctor' must be a morphism in ", Name( C ) );
    fi;
    
    func_of_presheaf_morphism :=
      function ( Y_obj_o, o, F_o )
        local tau, summands;
        
        tau := List( BasisOfExternalHom( A, o, obj ), m -> PreCompose( C, ell, F(m) ) );
        
        Assert( 0, RankOfObject( Y_obj_o ) = Length( tau ) );
        
        summands := ListWithIdenticalEntries( RankOfObject( Y_obj_o ), Source( ell ) );
        
        return UniversalMorphismFromDirectSumWithGivenDirectSum( C, summands, F_o, tau, Y_obj_o );
        
  end;
  
  return MorphismConstructor( PSh, Y_obj, func_of_presheaf_morphism, F );
  
end );

#                                                       op
#  Interpret an algebroid A as an object in PreSheaves(A ⊗ A, k-rows).
#                    _  _     _     op
#  For two morphims: g: X --> Y in A   &  f: U --> V in A
#                                    op
#  we send the following diagram in A ⊗ A
#                     _
#          _          X⊗f         _
#          X⊗U  ---------------≻  X⊗V
#      _    |                      |  _
#      g⊗U  |                      |  g⊗V
#           |         _            |
#          _⋎         Y⊗f         _⋎
#          Y⊗U  ---------------≻  Y⊗V
#
#  to the diagram in k-rows:
#
#                     hom(f,X)
#         hom(U,X)  ≺----------  hom(V,X)
#           ⋏                      ⋏
#           |                      |
# hom(U,g)  |                      |  hom(V,g)
#           |         hom(f,Y)     |
#         hom(U,Y)  ≺----------  hom(V,Y)
#
##
InstallMethod( AlgebroidAsObjectInPreSheavesCategoryData,
          [ IsAlgebroidFromDataTables ],
  
  function ( A )
    local q, nr_objs, nr_gmors, images_of_objs, images_of_gmorphisms;
    
    q := UnderlyingQuiver( A );
    
    nr_objs := NumberOfObjects( q );
    nr_gmors := NumberOfMorphisms( q );
    
    images_of_objs :=
      _ConcatenationLazyHLists_( LazyHList( [ 1 .. nr_objs ],
          l -> LazyHList( [ 1 .. nr_objs ],
            r -> HomomorphismStructureOnObjects( A, SetOfObjects( A )[r], SetOfObjects( A )[l] ) ) ) );
    
    images_of_gmorphisms :=
                _ConcatenationLazyHLists_(
                     [ _ConcatenationLazyHLists_( LazyHList( [ 1 .. nr_objs ], l -> LazyHList( [ 1 .. nr_gmors ],
                        r -> HomomorphismStructureOnMorphisms( A, SetOfGeneratingMorphisms( A )[r], IdentityMorphism( SetOfObjects( A )[l] ) ) ) ) ),
                       _ConcatenationLazyHLists_( LazyHList( [ 1 .. nr_gmors ], l -> LazyHList( [ 1 .. nr_objs ],
                        r -> HomomorphismStructureOnMorphisms( A, IdentityMorphism( SetOfObjects( A )[r] ), SetOfGeneratingMorphisms( A )[l] ) ) ) ) ] );
    
    return Pair( images_of_objs, images_of_gmorphisms );
    
end );

##
InstallMethod( AlgebroidAsObjectInPreSheavesCategory,
          [ IsAlgebroidFromDataTables ],
  
  function ( A )
    local q, nr_objs, nr_gmors, A_op, A_op_x_A, PSh, range_cat, presheaf_on_objs, presheaf_on_id_or_gmor, presheaf_on_mors;
    
    q := UnderlyingQuiver( A );
    
    nr_objs := NumberOfObjects( q );
    nr_gmors := NumberOfMorphisms( q );
    
    A_op := OppositeAlgebroid( A );
    A_op_x_A := TensorProductOfAlgebroids( A_op, A );
    
    PSh := PreSheaves( A_op_x_A );
    range_cat := RangeCategoryOfHomomorphismStructure( A );
    
    Assert( 0, IsIdenticalObj( range_cat, Target( PSh ) ) );
    
    presheaf_on_objs := obj -> AlgebroidAsObjectInPreSheavesCategoryData( A )[1][ObjectIndex( obj )];
    
    presheaf_on_id_or_gmor :=
      function ( w )
        local index, datum, l, r;
        
        if IsEqualToIdentityMorphism( w ) then
              
              datum := ObjectIndex( Source( w ) );
              
              l := QuoInt( datum - 1, nr_objs ) + 1;
              r := RemInt( datum - 1, nr_objs ) + 1;
              
              return IdentityMorphism( HomomorphismStructureOnObjects( A, SetOfObjects( A )[r], SetOfObjects( A )[l] ) );
              
        else
              
              index := Position( SetOfGeneratingMorphisms( A_op_x_A ), w );
              
              return AlgebroidAsObjectInPreSheavesCategoryData( A )[2][index];
              
        fi;
        
    end;
    
    presheaf_on_mors :=
      {s, mor, r} -> SumOfMorphisms( range_cat,
                        s,
                        List( DecompositionOfMorphismInAlgebroid( mor ),
                                  p -> p[1] * PostComposeList( range_cat, List( p[2], presheaf_on_id_or_gmor ) ) ),
                        r );
    
    return ObjectConstructor( PSh, Pair( presheaf_on_objs, presheaf_on_mors ) );
    
end );

##
InstallMethod( AssociatedMorphismIntoAlgebroidAsObjectInPreSheavesCategory,
          [ IsMorphismInAlgebroidFromDataTables ],
  
  function ( m )
    local A, A_op, A_op_x_A, F, PSh, obj, Y_obj;
    
    A := CapCategory( m );
    A_op := OppositeAlgebroid( A );
    A_op_x_A := TensorProductOfAlgebroids( A_op, A );
    
    F := AlgebroidAsObjectInPreSheavesCategory( A );
    PSh := CapCategory( F );
    
    obj := ElementaryTensor( SetOfObjects( A_op )[ObjectIndex( Target( m ) )], Source( m ), A_op_x_A );
    
    Y_obj := YonedaEmbeddingOfSourceCategory( PSh )( obj );
    
    return MorphismFromRepresentableFunctor(
                        PSh,
                        obj,
                        Y_obj,
                        F,
                        InterpretMorphismAsMorphismFromDistinguishedObjectToHomomorphismStructure( A, m ) );
    
end );

##################################
#
# Algebroids By Two-Sided Ideals
#
##################################

##
InstallOtherMethod( QuotientCategory,
        [ IsAlgebroidFromDataTables, IsDenseList ],
  
  function ( A, ideal )
    local A_op, A_op_x_A, F, PSh, C, tau, pi, congruence_function, name, quotient_category, FinalizeCategory, range_of_HomStructure, ring;
    
    A_op := OppositeAlgebroid( A );
    A_op_x_A := TensorProductOfAlgebroids( A_op, A : eager := false );
    
    F := AlgebroidAsObjectInPreSheavesCategory( A );
    
    PSh := CapCategory( F );
    C := Target( PSh );
    
    tau := UniversalMorphismFromDirectSum( PSh, F, List( ideal, AssociatedMorphismIntoAlgebroidAsObjectInPreSheavesCategory ) );
    
    if HasIsAbelianCategory( C ) and IsAbelianCategory( C ) then
        
        pi := CokernelProjection( PSh, tau );
        
        congruence_function :=
          function ( m )
            local obj;
            
            obj := ElementaryTensor( SetOfObjects( A_op )[ObjectIndex( Target( m ) )], Source( m ), A_op_x_A );
            
            return IsZeroForMorphisms( C, PreCompose( C, AssociatedMorphismIntoAlgebroidAsObjectInPreSheavesCategory( m )( obj ), pi( obj ) ) );
            
        end;
        
    elif CanCompute( C, "IsLiftable" ) then
        
        congruence_function :=
          function ( m )
            local obj;
            
            obj := ElementaryTensor( SetOfObjects( A_op )[ObjectIndex( Target( m ) )], Source( m ), A_op_x_A );
            
            return IsLiftable( C, AssociatedMorphismIntoAlgebroidAsObjectInPreSheavesCategory( m )( obj ), tau( obj ) );
            
        end;
        
    else
        
        Error( "the operation 'IsLiftable' must be added to the range category of Hom-Structure!" );
        
    fi;
    
    name := Concatenation( "QuotientCategory( ", Name( A ), ", 2-sided ideal generated by ", String( Length( ideal ) ), " morphisms )" );
    
    if Length( ideal ) = 1 then
        name := ReplacedString( name, "morphisms )", "morphism )" );
    fi;
    
    quotient_category := QuotientCategory( rec(
                                      underlying_category := A,
                                      name := name,
                                      congruence_function := congruence_function,
                                      nr_arguments_of_congruence_function := 1 ) : FinalizeCategory := false );
    ##
    ## Adding the Hom-Structure
    ##
    
    range_of_HomStructure := RangeCategoryOfHomomorphismStructure( A );
    
    ring := UnderlyingRing( range_of_HomStructure );
    
    if IsFieldForHomalg( ring ) then
        
        SetRangeCategoryOfHomomorphismStructure( quotient_category, range_of_HomStructure );
        
        AddDistinguishedObjectOfHomomorphismStructure( quotient_category,
          function ( quotient_category )
            
            return DistinguishedObjectOfHomomorphismStructure( A );
            
        end );
        
        AddHomomorphismStructureOnObjects( quotient_category,
          function ( quotient_category, obj1, obj2 )
            local obj2_op;
            
            obj1 := UnderlyingCell( obj1 );
            obj2 := UnderlyingCell( obj2 );
            
            obj2_op := SetOfObjects( A_op )[ObjectIndex( obj2 )];
            
            return Target( pi )( ElementaryTensor( obj2_op, obj1, A_op_x_A ) );
            
        end );
        
        AddHomomorphismStructureOnMorphismsWithGivenObjects( quotient_category,
          function ( quotient_category, s, f, g, r )
            local g_op, g_op_x_f;
            
            f := UnderlyingCell( f );
            
            g_op := MorphismConstructor(
                      A_op,
                      SetOfObjects( A_op )[ObjectIndex( UnderlyingCell( Target( g ) ) )],
                      CoefficientsList( UnderlyingCell( g ) ),
                      IndicesOfSupportMorphisms( UnderlyingCell( g ) ),
                      SetOfObjects( A_op )[ObjectIndex( UnderlyingCell( Source( g ) ) )] );
            
            g_op_x_f := ElementaryTensor( g_op, f, A_op_x_A );
            
            return CokernelObjectFunctorialWithGivenCokernelObjects( range_of_HomStructure,
                        s,
                        tau( Target( g_op_x_f ) ),
                        F( g_op_x_f ),
                        tau( Source( g_op_x_f ) ),
                        r );
            
        end );
        
        AddInterpretMorphismAsMorphismFromDistinguishedObjectToHomomorphismStructure( quotient_category,
          function ( quotient_category, mor )
            local distinguished_object, obj1, obj2, obj2_op, obj2_op_x_obj1;
            
            distinguished_object := DistinguishedObjectOfHomomorphismStructure( quotient_category );
            
            mor := UnderlyingCell( mor );
            
            obj1 := Source( mor );
            obj2 := Target( mor );
            
            obj2_op := SetOfObjects( A_op )[ObjectIndex( obj2 )];
            
            obj2_op_x_obj1 := ElementaryTensor( obj2_op, obj1, A_op_x_A );
            
            return PreCompose(
                      range_of_HomStructure,
                      InterpretMorphismAsMorphismFromDistinguishedObjectToHomomorphismStructureWithGivenObjects( A, distinguished_object, mor, F( obj2_op_x_obj1 ) ),
                      pi( obj2_op_x_obj1 ) );
            
        end );
        
        AddInterpretMorphismFromDistinguishedObjectToHomomorphismStructureAsMorphism( quotient_category,
          function ( quotient_category, obj1, obj2, eta )
            local obj2_op, obj2_op_x_obj1, ell, mor;
            
            obj1 := UnderlyingCell( obj1 );
            obj2 := UnderlyingCell( obj2 );
            
            obj2_op := SetOfObjects( A_op )[ObjectIndex( obj2 )];
            obj2_op_x_obj1 := ElementaryTensor( obj2_op, obj1, A_op_x_A );
            
            ell := ProjectiveLift( range_of_HomStructure, eta, pi( obj2_op_x_obj1 ) );
            
            mor := InterpretMorphismFromDistinguishedObjectToHomomorphismStructureAsMorphism( A, obj1, obj2, ell );
            
            return mor / quotient_category;
            
        end );
         
    else
        
        range_of_HomStructure := FreydCategory( range_of_HomStructure );
        
        SetRangeCategoryOfHomomorphismStructure( quotient_category, range_of_HomStructure );
        
        AddDistinguishedObjectOfHomomorphismStructure( quotient_category,
          function ( quotient_category )
            
            return AsFreydCategoryObject( range_of_HomStructure, DistinguishedObjectOfHomomorphismStructure( A ) );
            
        end );
        
        AddHomomorphismStructureOnObjects( quotient_category,
          function ( quotient_category, obj1, obj2 )
            local obj2_op;
            
            obj1 := UnderlyingCell( obj1 );
            obj2 := UnderlyingCell( obj2 );
            
            obj2_op := SetOfObjects( A_op )[ObjectIndex( obj2 )];
            
            return FreydCategoryObject( range_of_HomStructure, tau( ElementaryTensor( obj2_op, obj1, A_op_x_A ) ) );
            
        end );
        
        AddHomomorphismStructureOnMorphismsWithGivenObjects( quotient_category,
          function ( quotient_category, s, f, g, r )
            local g_op, g_op_x_f;
            
            f := UnderlyingCell( f );
            
            g_op := MorphismConstructor(
                      A_op,
                      SetOfObjects( A_op )[ObjectIndex( UnderlyingCell( Target( g ) ) )],
                      CoefficientsList( UnderlyingCell( g ) ),
                      IndicesOfSupportMorphisms( UnderlyingCell( g ) ),
                      SetOfObjects( A_op )[ObjectIndex( UnderlyingCell( Source( g ) ) )] );
            
            g_op_x_f := ElementaryTensor( g_op, f, A_op_x_A );
            
            return FreydCategoryMorphism( range_of_HomStructure,
                        s,
                        F( g_op_x_f ),
                        r );
            
        end );
        
        AddInterpretMorphismAsMorphismFromDistinguishedObjectToHomomorphismStructureWithGivenObjects( quotient_category,
          function ( quotient_category, distinguished_object, mor, r )
            
            return FreydCategoryMorphism( range_of_HomStructure,
                      distinguished_object,
                      InterpretMorphismAsMorphismFromDistinguishedObjectToHomomorphismStructureWithGivenObjects( A,
                                        Target( RelationMorphism( distinguished_object ) ),
                                        UnderlyingCell( mor ),
                                        Target( RelationMorphism( r ) ) ),
                      r );
            
        end );
        
        AddInterpretMorphismFromDistinguishedObjectToHomomorphismStructureAsMorphism( quotient_category,
          function ( quotient_category, obj1, obj2, eta )
            local mor;
            
            mor := InterpretMorphismFromDistinguishedObjectToHomomorphismStructureAsMorphism( A,
                                    UnderlyingCell( obj1 ),
                                    UnderlyingCell( obj2 ),
                                    UnderlyingMorphism( eta ) );
            
            return mor / quotient_category;
            
        end );
    
    fi;
    
    InstallMethod( DisplayString,
              [ ObjectFilter( quotient_category ) ],
    
     o -> Concatenation( ViewString( o ), "\n" ) );
    
    InstallMethod( ViewString,
              [ ObjectFilter( quotient_category ) ],
      function ( obj )
        
        return ViewString( UnderlyingCell( obj ) );
        
    end );
    
    InstallMethod( DisplayString,
              [ MorphismFilter( quotient_category ) ],
    
    m -> Concatenation( ViewString( m ), "\n" ) );
    
    InstallMethod( ViewString,
              [ MorphismFilter( quotient_category ) ],
      function ( mor )
        local string;
        
        string := ViewString( UnderlyingCell( mor ) );
        string := ReplacedString( string, "<", "<[ " );
        string := ReplacedString( string, ">", " ]>" );
        
        return string;
        
    end );
    
    Finalize( quotient_category );
    
    return quotient_category;
    
end );

##
InstallOtherMethod( \/,
        [ IsAlgebroidFromDataTables, IsDenseList ],
  
  QuotientCategory );

