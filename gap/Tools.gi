# SPDX-License-Identifier: GPL-2.0-or-later
# Algebroids: Algebroids and bialgebroids as preadditive categories generated by enhanced quivers
#
# Implementations
#

##
InstallMethod( DefiningTripleOfAQuiver,
        "for a quiver",
        [ IsQuiver ],
        
  function( q )
    local vertices, arrows;
    
    vertices := Vertices( q );
    arrows := Arrows( q );
    
    return Immutable(
                   Triple( Length( vertices ),
                           Length( arrows ),
                           List( arrows, m -> Pair( -1 + SafePosition( vertices, Source( m ) ), -1 + SafePosition( vertices, Range( m ) ) ) ) ) );
    
end );

##
InstallMethod( IndicesOfGeneratingMorphismsFromHomStructure,
        "for a finite category",
        [ IsCapCategory and IsFinite ],
        
  function( C )
    local sFinSets, C0, N0, D00, N0N0, p21, p22, C1, T, st, mors;
    
    sFinSets := RangeCategoryOfHomomorphismStructure( C );
    
    ## sFinSets must be the category skeletal finite sets
    Assert( 0, IsSkeletalCategoryOfFiniteSets( sFinSets ) );
    
    C0 := SetOfObjects( C );
    N0 := ObjectConstructor( sFinSets, Length( C0 ) );
    
    D00 := [ N0, N0 ];
    
    ## N0 Ã— N0 -> N0
    p21 := ProjectionInFactorOfDirectProduct( sFinSets, D00, 1 );
    p22 := ProjectionInFactorOfDirectProduct( sFinSets, D00, 2 );
    
    C1 := List( DirectProduct( sFinSets, D00 ), i ->
                HomomorphismStructureOnObjects( C,
                        C0[1 + AsList( p21 )[1 + i]],
                        C0[1 + AsList( p22 )[1 + i]] ) );
    
    T := DistinguishedObjectOfHomomorphismStructure( C );
    
    st := List( DefiningTripleOfUnderlyingQuiver( C )[3], pair ->
                UniversalMorphismIntoDirectProduct( sFinSets,
                        D00,
                        T,
                        [ MorphismConstructor( sFinSets, T, [ pair[1] ], N0 ),
                          MorphismConstructor( sFinSets, T, [ pair[2] ], N0 ) ] ) );
    
    mors := SetOfGeneratingMorphisms( C );
    
    return List( [ 1 .. Length( st ) ], i ->
                 Sum( C1{[ 1 .. AsList( st[i] )[1 + 0] ]}, Length ) +
                 AsList( InterpretMorphismAsMorphismFromDistinguishedObjectToHomomorphismStructure( C, mors[i] ) )[1 + 0] );
    
end );

##
InstallMethod( OppositeFiniteCategory,
        "for a finite category",
        [ IsCapCategory and IsFinite ],
        
  function( C )
    local C_op, defining_triple;
    
    C_op := Opposite( C );
    
    SetIsFinite( C_op, true );
    
    SetSetOfObjects( C_op,
            List( SetOfObjects( C ), Opposite ) );
    
    SetSetOfGeneratingMorphisms( C_op,
            List( SetOfGeneratingMorphisms( C ), Opposite ) );
    
    defining_triple := DefiningTripleOfUnderlyingQuiver( C );
    
    defining_triple := Triple( defining_triple[1],
                               defining_triple[2],
                               List( defining_triple[3], a -> Pair( a[2], a[1] ) ) );
    
    SetDefiningTripleOfUnderlyingQuiver( C_op, defining_triple );
    
    return C_op;
    
end );

##
InstallGlobalFunction( DefiningTripleOfUnderlyingQuiverAsString,
  function( defining_triple_of_underlying_quiver )
    
    return Concatenation( Concatenation(
                   [ "Triple( ", String( defining_triple_of_underlying_quiver[1] ), ", ", String( defining_triple_of_underlying_quiver[2] ), ", " ],
                   [ "[ ", JoinStringsWithSeparator( List( defining_triple_of_underlying_quiver[3], pair ->
                           Concatenation( "Pair( ", String( pair[1] ), ", ", String( pair[2] ), " )" ) ), ", " ) ], [ " ] )" ] ) );
    
end );

##
InstallGlobalFunction( DefiningTripleOfUnderlyingQuiverAsENHANCED_SYNTAX_TREE,
  function( defining_triple_of_underlying_quiver )
    
    return ReplacedStringViaRecord(
                   "ENHANCED_SYNTAX_TREE( x -> defining_triple_of_underlying_quiver ).bindings.BINDING_RETURN_VALUE",
                   rec( defining_triple_of_underlying_quiver := DefiningTripleOfUnderlyingQuiverAsString( defining_triple_of_underlying_quiver ) ) );
    
end );

##
InstallGlobalFunction( IndicesOfGeneratingMorphismsAsENHANCED_SYNTAX_TREE,
  function( indices_of_generating_morphisms )
    
    return ReplacedStringViaRecord(
                   "ENHANCED_SYNTAX_TREE( x -> indices_of_generating_morphisms ).bindings.BINDING_RETURN_VALUE",
                   rec( indices_of_generating_morphisms := String( indices_of_generating_morphisms ) ) );
    
end );

##
InstallGlobalFunction( DecompositionIndicesOfAllMorphismsAsENHANCED_SYNTAX_TREE,
  function( decomposition_of_all_morphisms )
    
    return ReplacedStringViaRecord(
                   "ENHANCED_SYNTAX_TREE( x -> decomposition_of_all_morphisms ).bindings.BINDING_RETURN_VALUE",
                   rec( decomposition_of_all_morphisms := String( decomposition_of_all_morphisms ) ) );
    
end );

##
InstallGlobalFunction( DataTablesAsString,
  function( data_tables )
    
    return Concatenation( Concatenation(
                   [ "Pair( Pair( ", String( data_tables[1][1] ), ", ", String( data_tables[1][2] ), " ), ", ],
                   [ "NTuple( 8, ", JoinStringsWithSeparator( List( data_tables[2], String ), ", " ) ], [ " ) )" ] ) );
    
end );

##
InstallGlobalFunction( DataTablesAsENHANCED_SYNTAX_TREE,
  function( data_tables )
    
    return ReplacedStringViaRecord(
                   "ENHANCED_SYNTAX_TREE( x -> data_tables ).bindings.BINDING_RETURN_VALUE",
                   rec( data_tables := DataTablesAsString( data_tables ) ) );
    
end );

##
InstallMethod( \.,
        "for an additive closure category and a positive integer",
        [ IsAdditiveClosureCategory, IsPosInt ],
        
  function( UC, string_as_int )
    local name, C, Yc;
    
    name := NameRNam( string_as_int );
    
    C := UnderlyingCategory( UC );
    
    Yc := C.(name) / UC;
    
    if IsAdditiveClosureObject( Yc ) then

        #TODO: is this true?
        #SetIsProjective( Yc, true );
        
    elif IsAdditiveClosureMorphism( Yc ) then
        
        if CanCompute( UC, "IsMonomorphism" ) then
            IsMonomorphism( Yc );
        fi;
        
        if CanCompute( UC, "IsSplitMonomorphism" ) then
            IsSplitMonomorphism( Yc );
        fi;
        
        if CanCompute( UC, "IsEpimorphism" ) then
            IsEpimorphism( Yc );
        fi;
        
        if CanCompute( UC, "IsSplitEpimorphism" ) then
            IsSplitEpimorphism( Yc );
        fi;
        
        ## IsIsomorphism = IsSplitMonomorphism and IsSplitEpimorphism
        ## we add this here in case the logic is deactivated
        if CanCompute( UC, "IsIsomorphism" ) then
            IsIsomorphism( Yc );
        fi;
        
    fi;
    
    return Yc;
    
end );
