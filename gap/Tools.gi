# SPDX-License-Identifier: GPL-2.0-or-later
# Algebroids: Algebroids and bialgebroids as preadditive categories generated by enhanced quivers
#
# Implementations
#

##
InstallMethod( Dimension,
        "for an algebroid",
        [ IsCapCategory and IsObjectFiniteCategory and IsLinearCategoryOverCommutativeRingWithFinitelyGeneratedFreeExternalHoms ],
        
  function( A )
    local objects;
    
    objects := SetOfObjects( A );
    
    return Sum( objects, s -> Sum( objects, t -> ObjectDatum( HomomorphismStructureOnObjects( s, t ) ) ) );
    
end );

##
InstallMethod( DefiningTripleOfAQuiver,
        "for a quiver",
        [ IsQuiver ],
        
  function( q )
    local vertices, arrows;
    
    vertices := Vertices( q );
    arrows := Arrows( q );
    
    return Immutable(
                   Triple( Length( vertices ),
                           Length( arrows ),
                           List( arrows, m -> Pair( -1 + SafePosition( vertices, Source( m ) ), -1 + SafePosition( vertices, Target( m ) ) ) ) ) );
    
end );

##
InstallMethod( IndicesOfGeneratingMorphismsFromHomStructure,
        "for a finite category",
        [ IsCapCategory and IsFiniteCategory ],
        
  function( C )
    local sFinSets, C0, N0, D00, N0N0, p21, p22, C1, T, st, mors;
    
    sFinSets := RangeCategoryOfHomomorphismStructure( C );
    
    ## sFinSets must be the category skeletal finite sets
    Assert( 0, IsSkeletalCategoryOfFiniteSets( sFinSets ) );
    
    C0 := SetOfObjects( C );
    N0 := ObjectConstructor( sFinSets, Length( C0 ) );
    
    D00 := [ N0, N0 ];
    
    ## N0 Ã— N0 -> N0
    p21 := ProjectionInFactorOfDirectProduct( sFinSets, D00, 1 );
    p22 := ProjectionInFactorOfDirectProduct( sFinSets, D00, 2 );
    
    C1 := List( DirectProduct( sFinSets, D00 ), i ->
                HomomorphismStructureOnObjects( C,
                        C0[1 + AsList( p21 )[1 + i]],
                        C0[1 + AsList( p22 )[1 + i]] ) );
    
    T := DistinguishedObjectOfHomomorphismStructure( C );
    
    st := List( DefiningTripleOfUnderlyingQuiver( C )[3], pair ->
                UniversalMorphismIntoDirectProduct( sFinSets,
                        D00,
                        T,
                        [ MorphismConstructor( sFinSets, T, [ pair[1] ], N0 ),
                          MorphismConstructor( sFinSets, T, [ pair[2] ], N0 ) ] ) );
    
    mors := SetOfGeneratingMorphisms( C );
    
    return List( [ 1 .. Length( st ) ], i ->
                 Sum( C1{[ 1 .. AsList( st[i] )[1 + 0] ]}, Length ) +
                 AsList( InterpretMorphismAsMorphismFromDistinguishedObjectToHomomorphismStructure( C, mors[i] ) )[1 + 0] );
    
end );

##
InstallMethod( OppositeFiniteCategory,
        "for a finite category",
        [ IsCapCategory and IsFiniteCategory ],
        
  function( C )
    local C_op, defining_triple;
    
    C_op := Opposite( C );
    
    defining_triple := DefiningTripleOfUnderlyingQuiver( C );
    
    defining_triple := Triple( defining_triple[1],
                               defining_triple[2],
                               List( defining_triple[3], a -> Pair( a[2], a[1] ) ) );
    
    SetDefiningTripleOfUnderlyingQuiver( C_op, defining_triple );
    
    return C_op;
    
end );

##
InstallGlobalFunction( DefiningTripleOfUnderlyingQuiverAsString,
  function( defining_triple_of_underlying_quiver )
    local string;
    
    string := Concatenation( Concatenation(
                      [ "Triple( ", String( defining_triple_of_underlying_quiver[1] ), ", ", String( defining_triple_of_underlying_quiver[2] ), ", " ],
                      [ "CapJitTypedExpression( [ ", JoinStringsWithSeparator( List( defining_triple_of_underlying_quiver[3], pair ->
                              Concatenation( "Pair( ", String( pair[1] ), ", ", String( pair[2] ), " )" ) ), ", " ) ],
                      [ " ], { } -> CapJitDataTypeOfListOf( IsInt ) ) )" ] ) );
    
    Assert( 0, EvalString( string ) = defining_triple_of_underlying_quiver );
    
    return string;
    
end );

##
InstallGlobalFunction( DefiningTripleOfUnderlyingQuiverAsENHANCED_SYNTAX_TREE,
  function( defining_triple_of_underlying_quiver )
    
    return ReplacedStringViaRecord(
                   "ENHANCED_SYNTAX_TREE( x -> defining_triple_of_underlying_quiver ).bindings.BINDING_RETURN_VALUE",
                   rec( defining_triple_of_underlying_quiver := DefiningTripleOfUnderlyingQuiverAsString( defining_triple_of_underlying_quiver ) ) );
    
end );

##
InstallGlobalFunction( IndicesOfGeneratingMorphismsAsString,
  function( indices_of_generating_morphisms )
    local string;
    
    string := Concatenation( "CapJitTypedExpression( ", String( indices_of_generating_morphisms ), ", { } -> CapJitDataTypeOfListOf( IsInt ) )" );
    
    Assert( 0, EvalString( string ) = indices_of_generating_morphisms );
    
    return string;
    
end );

##
InstallGlobalFunction( IndicesOfGeneratingMorphismsAsENHANCED_SYNTAX_TREE,
  function( indices_of_generating_morphisms )
    
    return ReplacedStringViaRecord(
                   "ENHANCED_SYNTAX_TREE( x -> indices_of_generating_morphisms ).bindings.BINDING_RETURN_VALUE",
                   rec( indices_of_generating_morphisms := IndicesOfGeneratingMorphismsAsString( indices_of_generating_morphisms ) ) );
    
end );

##
InstallGlobalFunction( DecompositionIndicesOfAllMorphismsAsString,
  function( decomposition_of_all_morphisms )
    local string;
    
    string := Concatenation( [ "CapJitTypedExpression( [ ", JoinStringsWithSeparator( List( decomposition_of_all_morphisms, s ->
                      Concatenation( "CapJitTypedExpression( [ ", JoinStringsWithSeparator( List( s, t ->
                              Concatenation( "CapJitTypedExpression( [ ", JoinStringsWithSeparator( List( t, mor_st ->
                                   Concatenation( "CapJitTypedExpression( ", String( mor_st ), ", { } -> CapJitDataTypeOfListOf( IsInt ) )" ) ), ", " ),
                                      " ], { } -> CapJitDataTypeOfListOf( CapJitDataTypeOfListOf( IsInt ) ) )" ) ), ", " ),
                              " ], { } -> CapJitDataTypeOfListOf( CapJitDataTypeOfListOf( CapJitDataTypeOfListOf( IsInt ) ) ) )" ) ), ", " ),
                      " ], { } -> CapJitDataTypeOfListOf( CapJitDataTypeOfListOf( CapJitDataTypeOfListOf( CapJitDataTypeOfListOf( IsInt ) ) ) ) )" ] );
    
    Assert( 0, EvalString( string ) = decomposition_of_all_morphisms );
    
    return string;
    
end );

##
InstallGlobalFunction( DecompositionIndicesOfAllMorphismsAsENHANCED_SYNTAX_TREE,
  function( decomposition_of_all_morphisms )
    
    return ReplacedStringViaRecord(
                   "ENHANCED_SYNTAX_TREE( x -> decomposition_of_all_morphisms ).bindings.BINDING_RETURN_VALUE",
                   rec( decomposition_of_all_morphisms := DecompositionIndicesOfAllMorphismsAsString( decomposition_of_all_morphisms ) ) );
    
end );

##
InstallGlobalFunction( DataTablesAsString,
  function( data_tables )
    local string;
    
    string := Concatenation( Concatenation(
                      [ "Pair( Pair( ", String( data_tables[1][1] ), ", ", String( data_tables[1][2] ), " ), ", ],
                      [ "NTuple( 8, " ],
                      [ "CapJitTypedExpression( ", String( data_tables[2][1] ), ", { } -> CapJitDataTypeOfListOf( IsInt ) ), " ],
                      [ "CapJitTypedExpression( ", String( data_tables[2][2] ), ", { } -> CapJitDataTypeOfListOf( IsInt ) ), " ],
                      [ "CapJitTypedExpression( ", String( data_tables[2][3] ), ", { } -> CapJitDataTypeOfListOf( IsInt ) ), " ],
                      [ "CapJitTypedExpression( [ ", JoinStringsWithSeparator( List( data_tables[2][4], pre ->
                              Concatenation( "CapJitTypedExpression( ", String( pre ), ", { } -> CapJitDataTypeOfListOf( IsInt ) )" ) ), ", " ),
                        " ], { } -> CapJitDataTypeOfListOf( CapJitDataTypeOfListOf( IsInt ) ) ), " ],
                      [ "CapJitTypedExpression( [ ", JoinStringsWithSeparator( List( data_tables[2][5], s ->
                              Concatenation( "CapJitTypedExpression( ", String( s ), ", { } -> CapJitDataTypeOfListOf( IsInt ) )" ) ), ", " ),
                        " ], { } -> CapJitDataTypeOfListOf( CapJitDataTypeOfListOf( IsInt ) ) ), " ],
                      [ "CapJitTypedExpression( [ ", JoinStringsWithSeparator( List( data_tables[2][6], pre ->
                              Concatenation( "CapJitTypedExpression( [ ", JoinStringsWithSeparator( List( pre, post ->
                                      Concatenation( "CapJitTypedExpression( ", String( post ), ", { } -> CapJitDataTypeOfListOf( IsInt ) )" ) ), ", " ),
                                      " ], { } -> CapJitDataTypeOfListOf( CapJitDataTypeOfListOf( IsInt ) ) )" ) ), ", " ),
                        " ], { } -> CapJitDataTypeOfListOf( CapJitDataTypeOfListOf( CapJitDataTypeOfListOf( IsInt ) ) ) ), " ],
                      [ "CapJitTypedExpression( [ ", JoinStringsWithSeparator( List( data_tables[2][7], mor ->
                              Concatenation( "CapJitTypedExpression( ", String( mor ), ", { } -> CapJitDataTypeOfListOf( IsInt ) )" ) ), ", " ),
                        " ], { } -> CapJitDataTypeOfListOf( CapJitDataTypeOfListOf( IsInt ) ) ), " ],
                      [ "CapJitTypedExpression( [ ", JoinStringsWithSeparator( List( data_tables[2][8], s ->
                              Concatenation( "CapJitTypedExpression( [ ", JoinStringsWithSeparator( List( s, t ->
                                      Concatenation( "CapJitTypedExpression( ", String( t ), ", { } -> CapJitDataTypeOfListOf( IsInt ) )" ) ), ", " ),
                                      " ], { } -> CapJitDataTypeOfListOf( CapJitDataTypeOfListOf( IsInt ) ) )" ) ), ", " ),
                        " ], { } -> CapJitDataTypeOfListOf( CapJitDataTypeOfListOf( CapJitDataTypeOfListOf( IsInt ) ) ) )" ],
                      [ " ) )" ] ) );
    
    Assert( 0, EvalString( string ) = data_tables );
    
    return string;
    
end );

##
InstallGlobalFunction( DataTablesAsENHANCED_SYNTAX_TREE,
  function( data_tables )
    
    return ReplacedStringViaRecord(
                   "ENHANCED_SYNTAX_TREE( x -> data_tables ).bindings.BINDING_RETURN_VALUE",
                   rec( data_tables := DataTablesAsString( data_tables ) ) );
    
end );

##
InstallMethod( \.,
        "for an additive closure category and a positive integer",
        [ IsAdditiveClosureCategory, IsPosInt ],
        
  function( UC, string_as_int )
    local name, C, Yc;
    
    name := NameRNam( string_as_int );
    
    C := UnderlyingCategory( UC );
    
    Yc := C.(name) / UC;
    
    if IsAdditiveClosureObject( Yc ) then

        #TODO: is this true?
        #SetIsProjective( Yc, true );
        
    elif IsAdditiveClosureMorphism( Yc ) then
        
        if CanCompute( UC, "IsMonomorphism" ) then
            IsMonomorphism( Yc );
        fi;
        
        if CanCompute( UC, "IsSplitMonomorphism" ) then
            IsSplitMonomorphism( Yc );
        fi;
        
        if CanCompute( UC, "IsEpimorphism" ) then
            IsEpimorphism( Yc );
        fi;
        
        if CanCompute( UC, "IsSplitEpimorphism" ) then
            IsSplitEpimorphism( Yc );
        fi;
        
        ## IsIsomorphism = IsSplitMonomorphism and IsSplitEpimorphism
        ## we add this here in case the logic is deactivated
        if CanCompute( UC, "IsIsomorphism" ) then
            IsIsomorphism( Yc );
        fi;
        
    fi;
    
    return Yc;
    
end );
