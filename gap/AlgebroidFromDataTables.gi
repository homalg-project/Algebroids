# SPDX-License-Identifier: GPL-2.0-or-later
# Algebroids: Algebroids and bialgebroids as preadditive categories generated by enhanced quivers
#
# Implementations
#

##
InstallMethod( DataTablesOfCategory,
            "for hom-finite k-algebroids",
          [ IsAlgebroid ],
  
  function ( B )
    local objs, gmors, bases_elms;
    
    if not HasRangeCategoryOfHomomorphismStructure( B ) then
        Error( "the algebroid passed to 'DataTablesOfCategory' must be hom-finite!" );
    fi;
    
    objs := SetOfObjects( B );
    
    gmors := SetOfGeneratingMorphisms( B );
    
    bases_elms := Concatenation( List( objs, u -> Concatenation( List( objs, v -> BasisOfExternalHom( u, v ) ) ) ) );
    
    return rec(
      coefficients_ring := CommutativeRingOfLinearCategory( B ),
      nr_objs := Length( objs ),
      nr_bases_elms := Length( bases_elms ),
      
      labels_objs := List( objs, o -> LabelAsString(UnderlyingVertex(o)) ),
      latex_strings_objs := List( objs, o -> LaTeXOutput( o ) ),
      indices_objs := List( objs, o -> Position( bases_elms, IdentityMorphism( o ) ) ),
      
      nr_gmors := Length( gmors ),
      labels_gmors := List( gmors, m -> LabelAsString( Paths( UnderlyingQuiverAlgebraElement( m ) )[1] ) ),
      latex_strings_gmors := List( gmors, m -> LaTeXOutput( m : OnlyDatum := true ) ),
      indices_gmors := List( gmors, m -> Position( bases_elms, m ) ),
      sources_gmors := List( gmors, m -> Position( objs, Source( m ) ) ),
      ranges_gmors := List( gmors, m -> Position( objs, Range( m ) ) ),
      
      bases_elms_comps := Concatenation( List( objs,
                            i -> Concatenation( List( objs,
                              j -> List( BasisOfExternalHom( i, j ),
                                b -> List( DecompositionOfMorphismInAlgebroid(b)[1][2],
                                  g -> Position( bases_elms, g ) ) ) ) ) ) ),
      
      indices_of_bases_elms := List( objs,
                                i -> List( objs,
                                  j -> List( BasisOfExternalHom( i, j ),
                                    b -> Position( bases_elms, b ) ) ) ),
      
      hom_structure_objs_gmors := List( objs,
                                    o -> List( gmors,
                                      gm -> EntriesOfHomalgMatrixAsListList( UnderlyingMatrix( HomStructure( o, gm ) ) ) ) ),
      
      hom_structure_gmors_objs := List( objs,
                                    o -> List( gmors,
                                      gm -> EntriesOfHomalgMatrixAsListList( UnderlyingMatrix( HomStructure( gm, o ) ) ) ) ) );
end );

##
InstallMethod( IsomorphismOntoAlgebroidFromDataTables,
          [ IsAlgebroid ],
  
  function ( A )
    local B, eta;
    
    B := AlgebroidFromDataTables( A );
    
    eta := CapFunctor( "Isomorphism functor onto algebroid from data tables", A, B );
    
    AddObjectFunction( eta,
      
      o -> CreateObject( B, VertexIndex( UnderlyingVertex( o ) ) )
    );
    
    AddMorphismFunction( eta,
      
      { s, alpha, r } -> CreateMorphism( B, s, CoefficientsOfMorphism( A, alpha ), r )
    );
    
    return eta;
    
end );

##
InstallMethod( IsomorphismFromAlgebroidFromDataTables,
          [ IsAlgebroid ],
  
  function ( A )
    local B, eta;
    
    B := AlgebroidFromDataTables( A );
    
    eta := CapFunctor( "Isomorphism functor from algebroid from data tables", B, A );
    
    AddObjectFunction( eta,
      
      o -> ObjectInAlgebroid( A, Vertex( UnderlyingQuiver( A ), ObjectIndex( o ) ) )
    );
    
    AddMorphismFunction( eta,
      
      { s, alpha, r } -> SumOfMorphisms( A, s, ListN( MorphismCoefficients( alpha ), BasisOfExternalHom( s, r ), \* ), r )
    );
    
    return eta;
    
end );

##
InstallOtherMethod( DataTablesOfCategory,
            "for quotient categories of k-algebroids enriched over k-rows",
          [ IsQuotientCapCategory ],
  
  function ( qB )
    local B, objs, support_objs, gmors, support_gmors, bases_elms;
    
    if not HasRangeCategoryOfHomomorphismStructure( qB ) then
        Error( "the quotient category passed to 'DataTablesOfCategory' must be hom-finite!" );
    fi;
    
    if not IsCategoryOfRows( RangeCategoryOfHomomorphismStructure( qB ) ) then
        TryNextMethod();
    fi;
    
    B := UnderlyingCategory( qB );
    
    objs := List( SetOfObjects( B ), o -> o / qB );
    support_objs := PositionsProperty( objs, o -> not IsZero( o ) );
    objs := objs{support_objs};
    
    gmors := List( SetOfGeneratingMorphisms( B ), m -> m / qB );
    support_gmors := PositionsProperty( gmors, m -> not IsZero( m ) );
    gmors := gmors{support_gmors};
    
    bases_elms := Concatenation( List( objs, u -> Concatenation( List( objs, v -> BasisOfExternalHom( u, v ) ) ) ) );
    
    return rec(
      coefficients_ring := CommutativeRingOfLinearCategory( B ),
      nr_objs := Length( objs ),
      nr_bases_elms := Length( bases_elms ),
      
      labels_objs := (EnhancedDataTables( B )[3]){support_objs},
      indices_objs := List( objs, o -> Position( bases_elms, IdentityMorphism( o ) ) ),
      
      nr_gmors := Length( gmors ),
      labels_gmors := (EnhancedDataTables( B )[7]){support_gmors},
      indices_gmors := List( gmors, m -> Position( bases_elms, m ) ),
      sources_gmors := List( gmors, m -> Position( objs, Source( m ) ) ),
      ranges_gmors := List( gmors, m -> Position( objs, Range( m ) ) ),
      
      bases_elms_comps := Concatenation( List( objs,
                              u -> Concatenation( List( objs,
                                v -> List( BasisOfExternalHom( u, v ),
                                  b -> List( DecompositionOfMorphismInAlgebroid( UnderlyingCell( b ) )[1][2],
                                    g -> Position( bases_elms, g / qB ) ) ) ) ) ) ),
      
      indices_of_bases_elms := List( objs,
                                u -> List( objs,
                                  v -> List( BasisOfExternalHom( u, v ),
                                    b -> Position( bases_elms, b ) ) ) ),
      
      hom_structure_objs_gmors := List( objs,
                    o -> List( gmors,
                      gm -> EntriesOfHomalgMatrixAsListList( UnderlyingMatrix( HomStructure( o, gm ) ) ) ) ),
      
      hom_structure_gmors_objs := List( objs,
                    o -> List( gmors,
                      gm -> EntriesOfHomalgMatrixAsListList( UnderlyingMatrix( HomStructure( gm, o ) ) ) ) ) );
end );

############################
#
# Auxiliary Functions
#
############################

##
BindGlobal( "_Product_Matrices_",
  
  function ( m_1, mat_1, n_1, m_2, mat_2, n_2, ring )
    
    if n_1 <> m_2 then
        Error("you are multiplying two non-compatible matrices!");
    fi;
    
    if m_1 = 0 or n_2 = 0 then
        return ListWithIdenticalEntries( m_1, [] );
    elif n_1 = 0 then
        return NullMat( m_1, n_2, ring );
    else
        return mat_1 * mat_2;
    fi;
    
end );

##
BindGlobal( "_Product_Matrices_List_",
  
  function ( L, ring )
    
    if IsEmpty( L ) then
        Error( "the list pass to '_Product_Matrices_List_' must not be empty!" );
    fi;
    
    if Length( L ) = 1 then
        return L[1];
    else
        return Iterated( L, { l, r } -> [ l[1], _Product_Matrices_( l[1], l[2], l[3], r[1], r[2], r[3], ring ), r[3] ] );
    fi;
    
end );

##
BindGlobal( "_KroneckerProduct_",
  function ( m_1, mat_1, n_1, m_2, mat_2, n_2 )
    
    if m_1 * m_2 = 0 or n_1 * n_2 = 0 then
        return ListWithIdenticalEntries( m_1 * m_2, [] );
    else
        return KroneckerProduct( mat_1, mat_2 );
    fi;
    
end );

##
BindGlobal( "_ConcatenationLazyHLists_",
  
  function ( list )
    local n, len, indices;
    
    n := Length( list );
     
    len := List( [ 1 .. n ], i -> Length( list[i] ) );
    
    indices := List( [ 0 .. n ], i -> Sum( len{[ 1 .. i ]} ) );
    
    return LazyHList( [ 1 .. Sum( len ) ],
                function ( i )
                  local pos;
                  
                  pos := PositionSorted( indices, i ) - 1;
                  
                  return list[pos][i-indices[pos]];
                  
                end );
     
end );

###########################
#
# Category Constructor
#
###########################

##
InstallOtherMethod( AlgebroidFromDataTables,
          [ IsAlgebroid ],
  
  B -> AlgebroidFromDataTables( DataTablesOfCategory( B ) )
);

##
InstallOtherMethod( AlgebroidFromDataTables,
          [ IsQuotientCapCategory ],
  
  qB -> AlgebroidFromDataTables( DataTablesOfCategory( qB ) )
);

##
InstallMethod( AlgebroidFromDataTables,
          [ IsRecord ],
  
  function ( input_data )
    local data, range_category_of_hom_structure, hom_structure_objs_gmors, hom_structure_on_objs_bases_elms, hom_structure_gmors_objs, hom_structure_on_bases_elms_objs, eager, name, o_string, gm_string, with_or_without_s, cat, p;
    
    data := [];
    
    # coefficient ring
    
    data[1] := input_data.coefficients_ring;
    
    # objects
    
    data[2] := input_data.nr_objs;
    data[3] := input_data.labels_objs;
    
    if IsBound( input_data.latex_strings_objs ) then
        data[4] := input_data.latex_strings_objs;
    else
        data[4] := input_data.labels_objs;
    fi;
    
    data[5] := input_data.indices_objs;
    
    # generating morphisms
    
    data[6] := input_data.nr_gmors;
    data[7] := input_data.labels_gmors;
    
    if IsBound( input_data.latex_strings_gmors ) then
        data[8] := input_data.latex_strings_gmors;
    else
        data[8] := input_data.labels_gmors;
    fi;
    
    data[9] := input_data.indices_gmors;
    data[10] := input_data.sources_gmors;
    data[11] := input_data.ranges_gmors;
    
    # all bases elements
    
    data[12] := input_data.nr_bases_elms;
    data[13] := input_data.bases_elms_comps;
    
    data[14] := [];
    
    for p in [ 1 .. data[2] ] do
          data[14][data[5][p]] := p;
    od;
    
    for p in [ 1 .. data[6] ] do
          data[14][data[9][p]] := p;
    od;
    
    if IsBound( input_data.labels_of_bases_elms ) then
          data[15] := input_data.labels_of_bases_elms;
    else
          data[15] :=
              LazyHList( data[13],
                 m -> JoinStringsWithSeparator(
                        List( CollectEntries( List( m,
                          function ( g )
                            if g in data[5] then
                                return Concatenation( "id(", data[3][data[14][g]], ")" );
                            else
                                return data[7][data[14][g]];
                            fi;
                          end ) ),
                          function ( pair )
                            if pair[2] = 1 then
                                return pair[1];
                            else
                                return Concatenation( pair[1], "^", String( pair[2] ) );
                            fi;
                          end ) , "•" ) );
    fi;
    
    if IsBound( input_data.latex_strings_of_bases_elms ) then
          data[16] := input_data.latex_strings_of_bases_elms;
    else
          data[16] :=
              LazyHList( data[13],
                 m -> JoinStringsWithSeparator(
                        List( CollectEntries( List( m,
                          function ( g )
                            if g in data[5] then
                                return Concatenation( "id_{", data[4][data[14][g]], "}" );
                            else
                                return data[8][data[14][g]];
                            fi;
                          end ) ),
                          function ( pair )
                            if pair[2] = 1 then
                                return pair[1];
                            else
                                return Concatenation( "{", pair[1], "}^{", String( pair[2] ), "}" );
                            fi;
                          end ) , "" ) );
    fi;
    
    data[17] := input_data.indices_of_bases_elms;
    
    data[18] := input_data.hom_structure_objs_gmors;
    
    data[19] := input_data.hom_structure_gmors_objs;
    
    # homomorphism structure
    
    data[20] := LazyHList( data[17], i -> LazyHList( i, Length ) );
    
    if IsBound( input_data.hom_structure_on_bases_elms ) then
        
        data[21] := input_data.hom_structure_on_bases_elms;
        
    else
        
        hom_structure_objs_gmors := LazyHList( [ 1 .. data[2] ],
                  i -> LazyHList( [ 1 .. data[6] ],
                    j -> [ data[20][i][data[10][j]],
                           data[18][i][j],
                           data[20][i][data[11][j]] ] ) );
        
        hom_structure_on_objs_bases_elms :=
                LazyHList( [ 1 .. data[2] ],
                  i -> List( [ 1 .. data[12] ],
                    function ( j )
                      local m;
                      
                      m := data[13][j];
                      
                      if Length( m ) = 1 and m[1] in data[5] then
                          m := data[20][i][data[14][m[1]]];
                          return [ m, IdentityMat( m, data[1] ), m ];
                      else
                          return _Product_Matrices_List_(
                                        ListOfValues( hom_structure_objs_gmors[i] ){
                                        List( m, index -> data[14][index] ) }, data[1] );
                      fi;
                      
                    end ) );
        
        hom_structure_gmors_objs := LazyHList( [ 1 .. data[2] ],
                  i -> LazyHList( [ 1 .. data[6] ],
                    j -> [ data[20][data[11][j]][i],
                           data[19][i][j],
                           data[20][data[10][j]][i] ] ) );
        
        hom_structure_on_bases_elms_objs :=
                LazyHList( [ 1 .. data[2] ],
                  i -> List( [ 1 .. data[12] ],
                    function ( j )
                      local m;
                      
                      m := data[13][j];
                      
                      if Length(m) = 1 and m[1] in data[5] then
                          m := data[20][data[14][m[1]]][i];
                          return [ m, IdentityMat( m, data[1] ), m ];
                      else
                          return _Product_Matrices_List_(
                                        ListOfValues( hom_structure_gmors_objs[i] ){
                                        Reversed( List( m, index -> data[14][index] ) ) }, data[1] );
                      fi;
                      
                    end ) );
        
        data[21] :=
          LazyHList( [ 1 .. data[2] ],
            i -> LazyHList( [ 1 .. data[2] ],
              j -> LazyHList( [ 1 .. data[2] ],
                p -> LazyHList( [ 1 .. data[2] ],
                  q -> LazyHList( hom_structure_on_bases_elms_objs[q]{data[17][i][j]},
                    l -> LazyHList( hom_structure_on_objs_bases_elms[j]{data[17][p][q]},
                      r -> _Product_Matrices_( r[1], r[2], r[3], l[1], l[2], l[3], data[1] ) ) ) ) ) ) );
    fi;
    
    # other
    
    data[22] := LazyHList( [ 1 .. data[6] ],
                                  i -> Cartesian( [ i ], Filtered( [ 1 .. input_data.nr_gmors ],
                                    j -> input_data.ranges_gmors[i] = input_data.sources_gmors[j] ) ) );
    
    if not IsBound( input_data.colors ) then
          
          data[23] := rec( obj := "", coeff := "", basis_elm := "", other := "", reset := "" );
          
    elif input_data.colors = true then
          
          data[23] := rec( obj := TextAttr.4, coeff := TextAttr.5, basis_elm := TextAttr.2, other := TextAttr.1, reset := TextAttr.reset );
          # to avoid line-breaking run SizeScreen([3000,3000]);
    else
          data[23] := input_data.colors;
    fi;
    
    data :=
      NTuple( 23,
         data[1],    # ring
         data[2],    # nr_objs
         data[3],    # labels_objs
         data[4],    # latex_strings_objs
         data[5],    # indices_objs
         data[6],    # nr_gmors
         data[7],    # labels_gmors
         data[8],    # latex_strings_gmors
         data[9],    # indices_gmors
         data[10],   # sources_gmors
         data[11],   # ranges_gmors
         data[12],   # nr_bases_elms
         data[13],   # bases_elms_comps
         data[14],   # pos_of_objs_gmors
         data[15],   # labels_of_bases_elms
         data[16],   # latex_strings_of_bases_elms
         data[17],   # indices_of_bases_elms
         data[18],   # hom_structure_objs_gmors
         data[19],   # hom_structure_gmors_objs
         data[20],   # hom_structure_ranks
         data[21],   # hom_structure_on_bases_elms
         data[22],   # indices_composable_gmors
         data[23] ); # colors
    
    eager := CAP_INTERNAL_RETURN_OPTION_OR_DEFAULT( "eager", true );
    
    if eager then
        
        ListOfValues( data[15] );
        
        ListOfValues( data[16] );
        
        List( ListOfValues( data[20] ), ListOfValues );
        
        List( ListOfValues( data[21] ),
          a -> List( ListOfValues( a ),
            b -> List( ListOfValues( b ),
              c -> List( ListOfValues( c ),
                d -> List( ListOfValues( d ),
                  e -> ListOfValues( e ) ) ) ) ) );
        
    fi;
    
    if IsBound( input_data.name ) then
        
        name := input_data.name;
        
    else
        
        if input_data.nr_objs < 10 then
            o_string := JoinStringsWithSeparator( input_data.labels_objs, "," );
        else
            o_string := Concatenation(
                              JoinStringsWithSeparator( input_data.labels_objs{[1..3]}, "," ),
                              ",..,",
                              JoinStringsWithSeparator( input_data.labels_objs{[input_data.nr_objs - 2 .. input_data.nr_objs]}, "," ) );
        fi;
        
        if input_data.nr_gmors < 10 then
            
            gm_string := JoinStringsWithSeparator(
                          ListN( input_data.labels_gmors, input_data.sources_gmors, input_data.ranges_gmors,
                              { l, i, j } -> Concatenation( l, ":", input_data.labels_objs[i], "-≻", input_data.labels_objs[j] ) ), "," );
        else
            
            gm_string := Concatenation(
                              JoinStringsWithSeparator(
                                  ListN( ListOfValues( input_data.labels_gmors ){[1..3]}, ListOfValues( input_data.sources_gmors ){[1..3]}, ListOfValues( input_data.ranges_gmors ){[1..3]},
                                    { l, i, j } -> Concatenation( l, ":", input_data.labels_objs[i], "-≻", input_data.labels_objs[j] ) ), "," ),
                              ",..,",
                              JoinStringsWithSeparator(
                                  ListN( ListOfValues( input_data.labels_gmors ){[input_data.nr_objs - 2 .. input_data.nr_objs]},
                                    ListOfValues( input_data.sources_gmors){[input_data.nr_objs - 2 .. input_data.nr_objs]},
                                    ListOfValues( input_data.ranges_gmors ){[input_data.nr_objs - 2 .. input_data.nr_objs]},
                                    { l, i, j } -> Concatenation( l, ":", input_data.labels_objs[i], "-≻", input_data.labels_objs[j] ) ), "," ) );
        
        fi;
        
        with_or_without_s := nr -> Concatenation( Concatenation( [ "" ], ListWithIdenticalEntries( Position( [ false, true ], nr <> 1 ) - 1, "s" ) ) );
        
        name := Concatenation(
                      RingName( input_data.coefficients_ring ),
                      "-algebroid( {",
                      o_string,
                      "}[",
                      gm_string,
                      "] ) defined by ",
                      String( input_data.nr_objs ),
                      " object",
                      with_or_without_s( input_data.nr_objs ),
                      " and ",
                      String( input_data.nr_gmors ),
                      " generating morphism",
                      with_or_without_s( input_data.nr_gmors ) );
        
    fi;
    
    cat := CreateCapCategory( name,
                IsAlgebroidFromDataTables,
                IsAlgebroidFromDataTablesObject,
                IsAlgebroidFromDataTablesMorphism,
                IsCapCategoryTwoCell );
    
    # Similar to Algebroids
    DeactivateCachingOfCategory( cat );
    CapCategorySwitchLogicOff( cat );
    DisableSanityChecks( cat );
    
    SetEnhancedDataTables( cat, data );
    
    cat!.category_as_first_argument := true;
    
    SetIsAbCategory( cat, true );
    SetIsLinearCategoryOverCommutativeRing( cat, true );
    SetCommutativeRingOfLinearCategory( cat, input_data.coefficients_ring );
    
    range_category_of_hom_structure := CAP_INTERNAL_RETURN_OPTION_OR_DEFAULT( "range_of_HomStructure", CategoryOfRows( data[1] : FinalizeCategory := true ) );
    
    SetSetOfObjects( cat, List( [ 1 .. data[2] ], index -> CreateCapCategoryObjectWithAttributes( cat, ObjectIndex, index ) ) );
    
    SetSetOfBasesOfExternalHomsLazyHList( cat,
                    LazyHList( [ 1 .. data[2] ],
                        i -> LazyHList( [ 1 .. data[2] ],
                          j -> ListN( [ 1 .. data[20][i][j] ], IdentityMat( data[20][i][j], data[1] ),
                            { index, coeff } -> CreateMorphism( cat, SetOfObjects( cat )[i], coeff, [ index ], SetOfObjects( cat )[j] ) ) ) ) );
    
    if eager then
        List( ListOfValues( SetOfBasesOfExternalHomsLazyHList( cat ) ), ListOfValues );
    fi;
    
    cat!.compiler_hints :=
      rec( category_attribute_names :=
           [ "SetOfObjects",
             "SetOfGeneratingMorphisms",
             "EnhancedDataTables",
             "SetOfBasesOfExternalHomsLazyHList",
             "CommutativeRingOfLinearCategory",
            ],
            precompiled_towers := [
            rec(
                remaining_constructors_in_tower := [ "AdditiveClosure" ],
                precompiled_functions_adder := ADD_FUNCTIONS_FOR_AdditiveClosureOfAlgebroidFromDataTablesPrecompiled ),
            ] );
    
    ##
    AddObjectConstructor( cat,
      
      { cat, index } -> SetOfObjects( cat )[index]
    );
    
    ##
    AddObjectDatum( cat,
      
      { cat, obj } -> ObjectIndex( obj )
    );
    
    ##
    AddMorphismConstructor( cat,
      
      { cat, obj_1, datum, obj_2 } -> CreateCapCategoryMorphismWithAttributes( cat,
                                            obj_1, obj_2,
                                            MorphismCoefficients, datum )
    );
    
    ##
    AddMorphismDatum( cat,
      
      { cat, alpha } -> MorphismCoefficients( alpha )
    );
    
    ##
    AddIsWellDefinedForObjects( cat,
      
      { cat, obj } -> 0 < ObjectIndex( obj ) and ObjectIndex( obj ) <= EnhancedDataTables( cat )[2]
    );
    
    ##
    AddIsEqualForObjects( cat,
      
      { cat, obj_1, obj_2 } -> ObjectIndex( obj_1 ) = ObjectIndex( obj_2 )
     );
    
    ##
    AddIsWellDefinedForMorphisms( cat,
      
      { cat, mor } -> EnhancedDataTables( cat )[20][ObjectIndex( Source( mor ) )][ObjectIndex( Range( mor ) )] = Length( MorphismCoefficients( mor ) )
    );

    ##
    AddIsEqualForMorphisms( cat,
      
      { cat, mor_1, mor_2 } -> MorphismCoefficients( mor_1 ) = MorphismCoefficients( mor_2 )
    );
    
    ##
    AddIsCongruentForMorphisms( cat,
      
      { cat, mor_1, mor_2 } -> MorphismCoefficients( mor_1 ) = MorphismCoefficients( mor_2 )
    );
    
    ##
    AddIdentityMorphism( cat,
      
      function ( cat, obj )
        local i;
        
        i := ObjectIndex( obj );
        
        return SetOfBasesOfExternalHomsLazyHList( cat )[i][i][SafePosition( EnhancedDataTables( cat )[17][i][i], EnhancedDataTables( cat )[5][i] )];
        
    end );
    
    ##
    AddZeroMorphism( cat,
      
      { cat, obj_1, obj_2 } -> MorphismConstructor( cat,
                                    obj_1,
                                    ListWithIdenticalEntries(
                                        EnhancedDataTables( cat )[20][ObjectIndex( obj_1 )][ObjectIndex( obj_2 )],
                                        ZeroImmutable( CommutativeRingOfLinearCategory( cat ) ) ),
                                    obj_2 )
    );
    
    ##
    AddMultiplyWithElementOfCommutativeRingForMorphisms( cat,
      
      { cat, r, alpha } -> MorphismConstructor( cat, Source( alpha ), List( MorphismCoefficients( alpha ), c -> r * c ), Range( alpha ) )
    );
    
    ##
    AddAdditionForMorphisms( cat,
      
      { cat, alpha_1, alpha_2 } -> MorphismConstructor( cat, Source( alpha_1 ), Sum( List( [ alpha_1, alpha_2 ], MorphismCoefficients ) ), Range( alpha_1 ) )
    );
    
    ##
    AddAdditiveInverseForMorphisms( cat,
      
      { cat, alpha } -> MorphismConstructor( cat, Source( alpha ), List( MorphismCoefficients( alpha ), c -> -c ), Range( alpha ) )
    );
    
    #
    AddBasisOfExternalHom( cat,
      
      { cat, obj_1, obj_2 } -> SetOfBasesOfExternalHomsLazyHList( cat )[ObjectIndex( obj_1 )][ObjectIndex( obj_2 )]
    );
    
    #
    AddCoefficientsOfMorphism( cat,
      
      { cat, alpha } -> MorphismCoefficients( alpha )
    );
    
    ## Hom-Structure
    
    SetIsEquippedWithHomomorphismStructure( cat, true );
    
    SetRangeCategoryOfHomomorphismStructure( cat, range_category_of_hom_structure );
    
    ##
    AddDistinguishedObjectOfHomomorphismStructure( cat,
      
      cat -> ObjectConstructor( RangeCategoryOfHomomorphismStructure( cat ), 1 )
    );
    
    ##
    AddHomomorphismStructureOnObjects( cat,
      
      { cat, obj_1, obj_2 } -> ObjectConstructor( RangeCategoryOfHomomorphismStructure( cat ),
                                      EnhancedDataTables( cat )[20][ObjectIndex( obj_1 )][ObjectIndex( obj_2 )] )
    );
    
    ##  H(α:i->j, γ:p->q) = H( α•id_j, γ•id_q ) = H(id_j, γ)•H(α, id_q)
    ##
    AddHomomorphismStructureOnMorphismsWithGivenObjects( cat,
      
      function ( cat, s, alpha, gamma, r )
        local s_alpha, s_gamma, i, j, p, q, hom_ijpq, coeffs_alpha, coeffs_gamma, mat;
        
        if (RankOfObject( s ) = 0 or Length( MorphismSupport( alpha ) ) = 0)  or (RankOfObject( r ) = 0 or Length( MorphismSupport( gamma ) ) = 0) then

            return ZeroMorphism( RangeCategoryOfHomomorphismStructure( cat ), s, r );

        else

            s_alpha := MorphismSupport( alpha );
            s_gamma := MorphismSupport( gamma );

            i := ObjectIndex( Source( alpha ) );
            j := ObjectIndex( Range( alpha ) );

            p := ObjectIndex( Source( gamma ) );
            q := ObjectIndex( Range( gamma ) );

            hom_ijpq := EnhancedDataTables( cat )[21][i][j][p][q];

            coeffs_alpha := MorphismCoefficients( alpha );
            coeffs_gamma := MorphismCoefficients( gamma );

            mat := Sum( List( s_alpha, l -> Sum( List( s_gamma, r -> List( hom_ijpq[l][r], x -> List( x, y -> (coeffs_alpha[l] * coeffs_gamma[r]) * y ) ) ) ) ) );

            return MorphismConstructor( RangeCategoryOfHomomorphismStructure( cat ),
                          s,
                          HomalgMatrixListList( mat, RankOfObject( s ), RankOfObject( r ), CommutativeRingOfLinearCategory( cat ) ),
                          r );

        fi;
        
    end );
    
    ##
    AddInterpretMorphismAsMorphismFromDistinguishedObjectToHomomorphismStructure( cat,
      
      function ( cat, alpha )
        local dim;
        
        dim := EnhancedDataTables( cat )[20][ObjectIndex( Source( alpha ) )][ObjectIndex( Range( alpha ) )];
        
        return MorphismConstructor( RangeCategoryOfHomomorphismStructure( cat ),
                            DistinguishedObjectOfHomomorphismStructure( cat ),
                            HomalgMatrixListList( [ MorphismCoefficients( alpha ) ], 1, dim, CommutativeRingOfLinearCategory( cat ) ),
                            ObjectConstructor( RangeCategoryOfHomomorphismStructure( cat ), dim ) );
    end );
    
    #
    AddInterpretMorphismAsMorphismFromDistinguishedObjectToHomomorphismStructureWithGivenObjects( cat,
      
      { cat, distinguished_object, alpha, r } -> MorphismConstructor( RangeCategoryOfHomomorphismStructure( cat ),
                                                            distinguished_object,
                                                            HomalgMatrixListList( [ MorphismCoefficients( alpha ) ], 1, RankOfObject( r ), CommutativeRingOfLinearCategory( cat ) ),
                                                            r )
    );
    
    #
    AddInterpretMorphismFromDistinguishedObjectToHomomorphismStructureAsMorphism( cat,
      
      { cat, obj_1, obj_2, eta } -> MorphismConstructor( cat, obj_1, EntriesOfHomalgMatrixAsListList( UnderlyingMatrix( eta ) )[1], obj_2 )
    );
    
    ## α:i->j, β:j->k
    ## α•β = ν⁻¹(ν(α•β)) = ν⁻¹(ν(α•id_j•β)) = ν⁻¹(ν(id_j)•H(α,β))
    ##
    AddPreCompose( cat,
      
      { cat, alpha, beta } -> InterpretMorphismFromDistinguishedObjectToHomomorphismStructureAsMorphism( cat, Source( alpha ), Range( beta ),
                                  PreCompose( RangeCategoryOfHomomorphismStructure( cat ),
                                      InterpretMorphismAsMorphismFromDistinguishedObjectToHomomorphismStructure( cat, IdentityMorphism( cat, Range( alpha ) ) ),
                                      HomomorphismStructureOnMorphisms( cat, alpha, beta ) ) )
    );
    
    ## Random Methods
    
    ##
    AddRandomObjectByInteger( cat,
      
      { cat, i } -> Random( SetOfObjects( cat ) )
    );
    
    ##
    AddRandomMorphismWithFixedSourceByInteger( cat,
      
      function ( cat, obj, n )
        local ring, r, basis;
        
        ring := CommutativeRingOfLinearCategory( cat );
        
        r := Random( Filtered( SetOfObjects( cat ), o -> not IsZero( HomomorphismStructureOnObjects( cat, obj, o ) ) ) );
        
        basis := SetOfBasesOfExternalHomsLazyHList( cat )[ObjectIndex( obj )][ObjectIndex( r )];
        
        return Sum( [ 0 .. AbsInt( n ) ], i -> Random( ring ) * Random( basis ) );
        
    end );
    
    ##
    AddRandomMorphismWithFixedRangeByInteger( cat,
      
      function ( cat, obj, n )
        local ring, s, basis;
        
        ring := CommutativeRingOfLinearCategory( cat );
        
        s := Random( Filtered( SetOfObjects( cat ), o -> not IsZero( HomomorphismStructureOnObjects( cat, o, obj ) ) ) );
        
        basis := SetOfBasesOfExternalHomsLazyHList( cat )[ObjectIndex( s )][ObjectIndex( obj )];
        
        return SumOfMorphisms( cat, s, List( [ 0 .. AbsInt( n ) ], i -> Random( ring ) * Random( basis ) ), obj );
        
    end );
    
    ##
    AddRandomMorphismWithFixedSourceAndRangeByInteger( cat,
      
      function ( cat, s, r, n )
        local ring, morphisms;
        
        ring := CommutativeRingOfLinearCategory( cat );
        
        morphisms := Concatenation( [ ZeroMorphism( cat, s, r ) ], SetOfBasesOfExternalHomsLazyHList( cat )[ObjectIndex( s )][ObjectIndex( r )] );
        
        return SumOfMorphisms( cat, s, List( [ 0 .. AbsInt( n ) ], i -> Random( ring ) * Random( morphisms ) ), r );
        
    end );
    
    Finalize( cat );
    
    return cat;
    
end );

##
InstallMethod( SetOfGeneratingMorphisms,
          [ IsAlgebroidFromDataTables ],
  
  B -> ListN( EnhancedDataTables( B )[9], EnhancedDataTables( B )[10], EnhancedDataTables( B )[11],
            { g, i, j } -> SetOfBasesOfExternalHomsLazyHList( B )[i][j][Position( EnhancedDataTables( B )[17][i][j], g )] )
);

##
InstallMethod( SetOfBasesOfExternalHoms,
          [ IsAlgebroidFromDataTables ],
  
  B -> List( ListOfValues( SetOfBasesOfExternalHomsLazyHList( B ) ), ListOfValues )
);

##############################
#
# Objects & Morphisms
#
##############################

##
InstallMethod( CreateObject,
          [ IsAlgebroidFromDataTables, IsInt ],
  
  { cat, index } -> SetOfObjects( cat )[index]
);

##
InstallOtherMethod( \[\],
          [ IsAlgebroidFromDataTables, IsInt ],
  
  { cat, index } -> SetOfObjects( cat )[index]
);

##
InstallMethod( CreateMorphism,
          [ IsAlgebroidFromDataTables, IsAlgebroidFromDataTablesObject, IsDenseList, IsAlgebroidFromDataTablesObject ],
  
  MorphismConstructor
);

##
InstallOtherMethod( CreateMorphism,
          [ IsAlgebroidFromDataTablesObject, IsDenseList, IsAlgebroidFromDataTablesObject ],
  
  MorphismConstructor
);

##
InstallOtherMethod( CreateMorphism,
          [ IsAlgebroidFromDataTables, IsAlgebroidFromDataTablesObject, IsDenseList, IsDenseList, IsAlgebroidFromDataTablesObject ],
  
  { cat, S, coeffs, support, R } -> CreateCapCategoryMorphismWithAttributes( cat,
                                        S, R,
                                        MorphismCoefficients, coeffs,
                                        MorphismSupport, support )
);

##
InstallMethod( MorphismSupport,
          [ IsAlgebroidFromDataTablesMorphism ],
  
  alpha -> PositionsProperty( MorphismCoefficients( alpha ), c -> not IsZero( c ) )
);

##
InstallMethod( DecompositionOfMorphismInAlgebroid,
          [ IsAlgebroidFromDataTablesMorphism ],
  
  function ( mor )
    local B, indices_objs, indices_gmors, source, range, supp, coeffs, precomps;
    
    B := CapCategory( mor );
    indices_objs := EnhancedDataTables( B )[5];
    indices_gmors := EnhancedDataTables( B )[9];
    
    source := ObjectIndex( Source( mor ) );
    range := ObjectIndex( Range( mor ) );
    
    supp := MorphismSupport( mor );
    coeffs := MorphismCoefficients( mor ){ supp };
    precomps := List( EnhancedDataTables( B )[17][source][range]{supp},
                        function ( j )
                          local m;
                          m := EnhancedDataTables( B )[13][j];
                          if Length( m ) = 1 and m[1] in indices_objs then
                              return [ IdentityMorphism( SetOfObjects( B )[EnhancedDataTables( B )[14][m[1]]] ) ];
                          else
                              return List( m, index -> SetOfGeneratingMorphisms( B )[EnhancedDataTables( B )[14][index]] );
                          fi;
                        end );
    
    return ListN( coeffs, precomps, { c, l } -> [ c, l ] );
    
end );

####################################
#
# Opposite Algebroid
#
####################################

##
InstallOtherMethod( OppositeAlgebroid,
          [ IsAlgebroidFromDataTables ],
  
  function ( cat )
    local data, data_op;
    
    data := EnhancedDataTables( cat );
    
    data_op := rec();
    
    data_op!.coefficients_ring := data[1];
    
    data_op!.nr_objs := data[2];
    
    data_op!.nr_bases_elms := data[12];
    
    data_op!.labels_objs := data[3];
    
    data_op!.indices_objs := data[5];
    
    data_op!.nr_gmors := data[6];
    
    data_op!.labels_gmors := data[7];
    
    data_op!.indices_gmors := data[9];
    
    data_op!.sources_gmors := data[11];
    
    data_op!.ranges_gmors := data[10];
    
    data_op!.bases_elms_comps := List( data[13], Reversed );
    
    data_op!.indices_of_bases_elms := TransposedMat( data[17] );
    
    data_op!.hom_structure_objs_gmors := data[19];
    
    data_op!.hom_structure_gmors_objs := data[18];
    
    data_op!.hom_structure_ranks := TransposedMat( data[20] );
    
    data_op!.hom_structure_on_bases_elms :=
        List( [ 1 .. data_op.nr_objs ],
          i -> List( [ 1 .. data_op.nr_objs ],
            j -> List( [ 1 .. data_op.nr_objs ],
              p -> List( [ 1 .. data_op.nr_objs ],
                q -> List( [ 1 .. data_op.hom_structure_ranks[i][j] ],
                  l -> List( [ 1 .. data_op.hom_structure_ranks[p][q] ],
                    r -> data[21][q][p][j][i][r][l] ) ) ) ) ) );
    
    return AlgebroidFromDataTables( data_op : range_of_HomStructure := RangeCategoryOfHomomorphismStructure( cat ) );
    
end );

####################################
#
# Tensor Product Of Algebroids
#
####################################

##
InstallMethod( \*,
          [ IsAlgebroidFromDataTables, IsAlgebroidFromDataTables ],
  
  { B_1, B_2 } -> TensorProductOfAlgebroids( B_1, B_2 : eager := false )
);

##
InstallMethodWithCache( TensorProductOfAlgebroids,
          [ IsAlgebroidFromDataTables, IsAlgebroidFromDataTables ],
  
  function ( B_1, B_2 )
    local data_1, data_2, data;
    
    data_1 := EnhancedDataTables( B_1 );
    data_2 := EnhancedDataTables( B_2 );
    
    if not IsIdenticalObj( data_1[1], data_2[1] ) then
        Error( "the algebroids must be linear over the same commutative ring!" );
    fi;
    
    data := rec();
    
    data!.coefficients_ring := data_1[1];
    
    data!.nr_objs := data_1[2] * data_2[2];
    
    data!.nr_bases_elms := data_1[12] * data_2[12];
    
    data!.indices_objs := Concatenation( List( data_1[5], l -> List( data_2[5], r -> (l-1) * data_2[12] + r ) ) );
    
    data!.labels_objs := Concatenation( List( data_1[3], l -> List( data_2[3], r -> Concatenation( l, "⊗", r ) ) ) );
    
    data!.latex_strings_objs := Concatenation( List( data_1[4], l -> List( data_2[4], r -> Concatenation( l, "{\\otimes}", r ) ) ) );
    
    data!.nr_gmors := data_1[2] * data_2[6] + data_1[6] * data_2[2];
    
    data!.indices_gmors :=
                    _ConcatenationLazyHLists_(
                        [ _ConcatenationLazyHLists_( LazyHList( data_1[5], l -> LazyHList( data_2[9], r -> (l-1) * data_2[12] + r ) ) ),
                          _ConcatenationLazyHLists_( LazyHList( data_1[9], l -> LazyHList( data_2[5], r -> (l-1) * data_2[12] + r ) ) ) ] );
    
    data!.labels_gmors :=
                    _ConcatenationLazyHLists_(
                        [ _ConcatenationLazyHLists_( LazyHList( data_1[3], l -> LazyHList( data_2[7], r -> Concatenation( l, "⊗", r ) ) ) ),
                          _ConcatenationLazyHLists_( LazyHList( data_1[7], l -> LazyHList( data_2[3], r -> Concatenation( l, "⊗", r ) ) ) ) ] );
    
    data!.latex_strings_gmors :=
                    _ConcatenationLazyHLists_(
                        [ _ConcatenationLazyHLists_( LazyHList( data_1[4], l -> LazyHList( data_2[8], r -> Concatenation( l, "{\\otimes}", r ) ) ) ),
                          _ConcatenationLazyHLists_( LazyHList( data_1[8], l -> LazyHList( data_2[4], r -> Concatenation( l, "{\\otimes}", r ) ) ) ) ] );

    data!.sources_gmors :=
                    _ConcatenationLazyHLists_(
                        [ _ConcatenationLazyHLists_( LazyHList( [ 1 .. data_1[2] ], l -> LazyHList( data_2[10], r -> (l-1) * data_2[2] + r ) ) ),
                          _ConcatenationLazyHLists_( LazyHList( data_1[10], l -> LazyHList( [ 1 .. data_2[2] ], r -> (l-1) * data_2[2] + r ) ) ) ] );
    
    data!.ranges_gmors :=
                    _ConcatenationLazyHLists_(
                        [ _ConcatenationLazyHLists_( LazyHList( [ 1 .. data_1[2] ], l -> LazyHList( data_2[11], r -> (l-1) * data_2[2] + r ) ) ),
                          _ConcatenationLazyHLists_( LazyHList( data_1[11], l -> LazyHList( [ 1 .. data_2[2] ], r -> (l-1) * data_2[2] + r ) ) ) ] );
    
    data!.hom_structure_objs_gmors :=
        _ConcatenationLazyHLists_(
            LazyHList( [ 1 .. data_1[2] ],
                i -> LazyHList( [ 1 .. data_2[2] ],
                    p -> _ConcatenationLazyHLists_(
                              [ _ConcatenationLazyHLists_(
                                  LazyHList( [ 1 .. data_1[2] ],
                                    j -> LazyHList( [ 1 .. Length( data_2[9] ) ],
                                        index_2 -> _KroneckerProduct_(
                                                        data_1[20][i][j],
                                                        IdentityMat( data_1[20][i][j], data.coefficients_ring ),
                                                        data_1[20][i][j],
                                                        data_2[20][p][data_2[10][index_2]],
                                                        data_2[18][p][index_2],
                                                        data_2[20][p][data_2[11][index_2]] ) ) ) ),
                              _ConcatenationLazyHLists_(
                                  LazyHList( [ 1 .. Length( data_1[9] ) ],
                                    index_1 -> LazyHList( [ 1 .. data_2[2] ],
                                              q -> _KroneckerProduct_(
                                                        data_1[20][i][data_1[10][index_1]],
                                                        data_1[18][i][index_1],
                                                        data_1[20][i][data_1[11][index_1]],
                                                        data_2[20][p][q],
                                                        IdentityMat( data_2[20][p][q], data.coefficients_ring ),
                                                        data_2[20][p][q] ) ) ) ) ] ) ) ) );
    
    data!.hom_structure_gmors_objs :=
        _ConcatenationLazyHLists_(
            LazyHList( [ 1 .. data_1[2] ],
                i -> LazyHList( [ 1 .. data_2[2] ],
                    p -> _ConcatenationLazyHLists_(
                              [ _ConcatenationLazyHLists_(
                                  LazyHList( [ 1 .. data_1[2] ],
                                    j -> LazyHList( [ 1 .. Length( data_2[9] ) ],
                                        index_2 -> _KroneckerProduct_(
                                                        data_1[20][j][i],
                                                        IdentityMat( data_1[20][j][i], data.coefficients_ring ),
                                                        data_1[20][j][i],
                                                        data_2[20][data_2[11][index_2]][p],
                                                        data_2[19][p][index_2],
                                                        data_2[20][data_2[10][index_2]][p] ) ) ) ),
                                _ConcatenationLazyHLists_(
                                  LazyHList( [ 1 .. Length( data_1[9] ) ],
                                    index_1 -> LazyHList( [ 1 .. data_2[2] ],
                                              q -> _KroneckerProduct_(
                                                        data_1[20][data_1[11][index_1]][i],
                                                        data_1[19][i][index_1],
                                                        data_1[20][data_1[10][index_1]][i],
                                                        data_2[20][q][p],
                                                        IdentityMat( data_2[20][q][p], data.coefficients_ring ),
                                                        data_2[20][q][p] ) ) ) ) ] ) ) ) );
    
    data!.bases_elms_comps :=
        _ConcatenationLazyHLists_(
            LazyHList( data_1[13],
              l -> LazyHList( data_2[13],
                      function ( r )
                        local index_l, index_r, l_is_object, r_is_object;
                        
                        if Length( l ) = 1 and l[1] in data_1[5] then
                          index_l := l[1];
                          l_is_object := true;
                        else
                          index_l := data_1[5][data_1[11][data_1[14][l[Length( l )]]]];
                          l_is_object := false;
                        fi;
                        
                        if Length( r ) = 1 and r[1] in data_2[5] then
                          index_r := r[1];
                          r_is_object := true;
                        else
                          index_r := data_2[5][data_2[10][data_2[14][r[1]]]];
                          r_is_object := false;
                        fi;
                        
                        if l_is_object and r_is_object then
                          return [ (index_l-1) * data_2[12] + index_r ];
                        elif r_is_object then
                          return List( l, i -> (i-1) * data_2[12] + index_r );
                        elif l_is_object then
                          return List( r, j -> (index_l-1) * data_2[12] + j );
                        else
                          return Concatenation(
                                    List( l, i -> (i-1) * data_2[12] + index_r ),
                                    List( r, j -> (index_l-1) * data_2[12] + j ) );
                        fi;
                        
                      end ) ) );
    
    data.labels_of_bases_elms :=
        _ConcatenationLazyHLists_( LazyHList( data_1[15], l -> LazyHList( data_2[15], r -> Concatenation( l, "⊗", r ) ) ) );
    
    data.latex_strings_of_bases_elms :=
        _ConcatenationLazyHLists_( LazyHList( data_1[16], l -> LazyHList( data_2[16], r -> Concatenation( l, "{\\otimes}", r ) ) ) );
    
    data!.indices_of_bases_elms :=
        _ConcatenationLazyHLists_( LazyHList( [ 1 .. data_1[2] ], i -> LazyHList( [ 1 .. data_2[2] ],
            function ( p )
                return Concatenation( List( [ 1 .. data_1[2] ], j -> List( [ 1 .. data_2[2] ],
                    function ( q )
                        return Concatenation( List( data_1[17][i][j], l -> List( data_2[17][p][q],
                                  r -> (l-1) * data_2[12] + r ) ) );
                    end ) ) );
            end ) ) );
    
    data!.colors := data_1[23];
    
    return AlgebroidFromDataTables( data : range_of_HomStructure := RangeCategoryOfHomomorphismStructure( B_1 ) );
    
end );

##
InstallMethod( ElementaryTensor,
        [ IsAlgebroidFromDataTablesObject, IsAlgebroidFromDataTablesObject, IsAlgebroidFromDataTables ],
  
  { obj_1, obj_2, B1_x_B2 } -> SetOfObjects( B1_x_B2 )[( ObjectIndex( obj_1 ) - 1 ) * Length( SetOfObjects( CapCategory( obj_2 ) ) ) + ObjectIndex( obj_2 )]
);

##
InstallMethod( ElementaryTensor,
        [ IsAlgebroidFromDataTablesMorphism, IsAlgebroidFromDataTablesMorphism, IsAlgebroidFromDataTables ],
  
  { mor_1, mor_2, B1_x_B2 } -> CreateMorphism( B1_x_B2,
                                    ElementaryTensor( Source( mor_1 ), Source( mor_2 ), B1_x_B2 ),
                                    Concatenation( List( MorphismCoefficients( mor_1 ), c_1 -> List( MorphismCoefficients( mor_2 ), c_2 -> c_1 * c_2 ) ) ),
                                    Concatenation( List( MorphismSupport( mor_1 ), l -> List( MorphismSupport( mor_2 ), r -> (l-1) * Length( MorphismCoefficients( mor_2 ) ) + r ) ) ),
                                    ElementaryTensor( Range( mor_1 ), Range( mor_2 ), B1_x_B2 ) )
);

##
InstallOtherMethod( ElementaryTensor,
        [ IsAlgebroidFromDataTablesObject, IsAlgebroidFromDataTablesObject ],
  
  { obj_1, obj_2 } -> ElementaryTensor( obj_1, obj_2, TensorProductOfAlgebroids( CapCategory( obj_1 ), CapCategory( obj_2 ) ) )
);

##
InstallOtherMethod( ElementaryTensor,
        [ IsAlgebroidFromDataTablesMorphism, IsAlgebroidFromDataTablesMorphism ],
  
  { mor_1, mor_2 } -> ElementaryTensor( mor_1, mor_2, TensorProductOfAlgebroids( CapCategory( mor_1 ), CapCategory( mor_2 ) ) )
);

##
InstallOtherMethod( ElementaryTensor,
        [ IsAlgebroidFromDataTablesObject, IsAlgebroidFromDataTablesMorphism ],
  
  { obj_1, mor_2 } -> ElementaryTensor( IdentityMorphism( obj_1 ), mor_2 )
);

##
InstallOtherMethod( ElementaryTensor,
        [ IsAlgebroidFromDataTablesMorphism, IsAlgebroidFromDataTablesObject ],
  
  { mor_1, obj_2 } -> ElementaryTensor( mor_1, IdentityMorphism( obj_2 ) )
);

####################################
#
# Methods For Attributes:
#
####################################

##
InstallMethod( AssignSetOfObjects,
        [ IsAlgebroidFromDataTables, IsString ],
  
  function ( B, label )
    local names, func;
    
    names := EnhancedDataTables( B )[3];
    
    if label = "" and ForAny( names, name -> Int( name ) <> fail ) then
        Error( "the <label> passed to 'AssignSetOfObjects' must be a non-empty string!\n" );
    fi;
    
    func :=
      function ( name, o )
        
        name := Concatenation( label, ReplacedString( name, "-", "m" ) );
        MakeReadWriteGlobal( name );
        DeclareSynonym( name, o );
        return true;
        
    end;
    
    ListN( names, SetOfObjects( B ), func );
    
end );

##
InstallOtherMethod( AssignSetOfObjects,
        [ IsAlgebroidFromDataTables ],
  
  function ( B )
    
    AssignSetOfObjects( B, "" );
    
end );

##
InstallMethod( AssignSetOfGeneratingMorphisms,
        [ IsAlgebroidFromDataTables, IsString ],
  
  function ( B, label )
    local names, morphisms, func;
    
    names := EnhancedDataTables( B )[7];
    
    if label = "" and ForAny( names, name -> Int( name ) <> fail ) then
        Error( "the <label> passed to 'AssignSetOfGeneratingMorphisms' must be a non-empty string!\n" );
    fi;
    
    morphisms := SetOfGeneratingMorphisms( B );
    
    func :=
      function ( name, m )
        
        name := Concatenation( label, ReplacedString( name, "-", "m" ) );
        MakeReadWriteGlobal( name );
        DeclareSynonym( name, m );
        return true;
        
    end;
    
    ListN( names, morphisms, func );
    
end );

##
InstallOtherMethod( AssignSetOfGeneratingMorphisms,
        [ IsAlgebroidFromDataTables ],
  
  function ( B )
    
    AssignSetOfGeneratingMorphisms( B, "" );
    
end );

##
InstallMethod( \.,
        "for an algebroid from data table and a positive integer",
        [ IsAlgebroidFromDataTables, IsPosInt ],
  
  function ( B, string_as_int )
    local name, p, nr_objs, indices_of_bases_elms, pairs, pair, pos;
    
    name := NameRNam( string_as_int );
    
    p := Position( EnhancedDataTables( B )[3], name );
    
    if p <> fail then
        return SetOfObjects( B )[p];
    fi;
    
    p := PositionProperty( EnhancedDataTables( B )[15], m -> ReplacedString( m, "•", "" ) = ReplacedString( name, "•", "" ) );
    
    if p <> fail then
        
        nr_objs := EnhancedDataTables( B )[2];
        
        indices_of_bases_elms := EnhancedDataTables( B )[17];
        
        pairs := Cartesian( [ 1 .. nr_objs ], [ 1 .. nr_objs ] );
        
        pair := pairs[PositionProperty( pairs, pair -> p in indices_of_bases_elms[pair[1]][pair[2]] )];
        
        pos := Position( indices_of_bases_elms[pair[1]][pair[2]], p );
        
        return BasisOfExternalHom( SetOfObjects( B )[pair[1]], SetOfObjects( B )[pair[2]] )[pos];
        
    fi;
    
    Error( "the given string ", name, " is not a label of an object or morphism in the category ", Name( B ), "\n" );
    
end );

########################################
#
# Enhancing PreSheaves( B )
#
#######################################

##
InstallMethod( PreSheaves,
          [ IsAlgebroidFromDataTables ],
  
  function ( B )
    local bool, PSh;
    
    bool := CAP_INTERNAL_RETURN_OPTION_OR_DEFAULT( "enhance_presheaves_category_of_linear_algebroid_from_data", true );
    
    if bool then
        
        PSh := PreSheaves( B : enhance_presheaves_category_of_linear_algebroid_from_data := false, FinalizeCategory := false );
        
        if not IsFinalized( PSh ) then
          
          AddIsEqualForMorphisms( PSh,
            function ( PSh, eta1, eta2 )
              local B, C;
              
              B := Source( PSh );
              C := Range( PSh );
              
              return ForAll( SetOfObjects( B ), o -> IsEqualForMorphisms( C, eta1( o ), eta2( o ) ) );
              
          end );
          
          AddIsCongruentForMorphisms( PSh,
            function ( PSh, eta1, eta2 )
              local B, C;
              
              B := Source( PSh );
              C := Range( PSh );
              
              return ForAll( SetOfObjects( B ), o -> IsCongruentForMorphisms( C, eta1( o ), eta2( o ) ) );
              
          end );
          
          AddIsEqualForObjects( PSh,
            function ( PSh, obj1, obj2 )
              local B, C;
              
              B := Source( PSh );
              C := Range( PSh );
              
              return ForAll( SetOfObjects( B ), o -> IsEqualForObjects( C, obj1( o ), obj2( o ) ) )
                        and ForAll( SetOfGeneratingMorphisms( B ), m -> IsEqualForMorphisms( C, obj1( m ), obj2( m ) ) );
              
          end );
          
          AddIsWellDefinedForObjects( PSh,
            function ( PSh, obj )
              local B, C, gmors, pairs;
              
              B := Source( PSh );
              C := Range( PSh );
              
              gmors := SetOfGeneratingMorphisms( B );
              pairs := Concatenation( ListOfValues( EnhancedDataTables( B )[22] ) );
              
              return ForAll( pairs, p -> IsCongruentForMorphisms( C, obj( PreCompose( B, gmors[p[1]], gmors[p[2]] ) ), PostCompose( C, obj( gmors[p[1]] ), obj( gmors[p[2]] ) ) ) );
              
          end );
          
          AddIsWellDefinedForMorphisms( PSh,
            function ( PSh, mor )
              local B, C, gmors;
              
              B := Source( PSh );
              C := Range( PSh );
              
              gmors := SetOfGeneratingMorphisms( B );
              
              return IsWellDefinedForObjects( PSh, Source( mor ) )
                    and IsWellDefinedForObjects( PSh, Range( mor ) )
                    and ForAll( gmors, g -> IsCongruentForMorphisms( C, PreCompose( C,  Source( mor )( g ), mor( Source( g ) ) ), PreCompose( C, mor( Range( g ) ), Range( mor )( g ) ) ) );
              
          end );
          
          Finalize( PSh );
          
        fi;
        
        return PSh;
        
    else
        
        TryNextMethod( );
        
    fi;
    
end );

#
# Let k be a commutative ring
# Let B a k-algebroid defined by data-tables, k-rows and PSh := PreSheaves(B, k-rows).
# Let Y: B -> PSh be the Yoneda embedding functor.
# For two objects obj ∈ B and F ∈ PSh we have Hom_{k-rows}(1,F(obj)) ≃ F(obj) ≃ Hom_PSh(Y(obj), F).
#
InstallOtherMethod( MorphismFromRepresentableFunctor,
          [ IsPreSheafCategory, IsAlgebroidFromDataTablesObject, IsObjectInPreSheafCategory, IsObjectInPreSheafCategory, IsCategoryOfRowsMorphism ],
  
  function ( PSh, obj, Y_obj, F, ell )
    local B, C, func_of_presheaf_morphism;
    
    B := Source( PSh );
    C := Range( PSh );
    
    if not IsIdenticalObj( B, CapCategory( obj ) ) then
        Error( "the argument <obj> passed to 'MorphismFromRepresentableFunctor' must be an object in ", Name( B ) );
    fi;
    
    if not IsIdenticalObj( C, CapCategory( ell ) ) then
        Error( "the argument <ell> passed to 'MorphismFromRepresentableFunctor' must be a morphism in ", Name( C ) );
    fi;
    
    func_of_presheaf_morphism :=
      function ( Y_obj_o, o, F_o )
        local tau, summands;
        
        tau := List( BasisOfExternalHom( B, o, obj ), m -> PreCompose( C, ell, F(m) ) );
        
        Assert( 0, RankOfObject( Y_obj_o ) = Length( tau ) );
        
        summands := ListWithIdenticalEntries( RankOfObject( Y_obj_o ), Source( ell ) );
        
        return UniversalMorphismFromDirectSumWithGivenDirectSum( C, summands, F_o, tau, Y_obj_o );
        
  end;
  
  return MorphismConstructor( PSh, Y_obj, func_of_presheaf_morphism, F );
  
end );

#                                                       op
#  Interpret an algebroid B as an object in PreSheaves(B ⊗ B, k-rows).
#                    _  _     _     op
#  For two morphims: g: X --> Y in B   &  f: U --> V in B
#                                    op
#  we send the following diagram in B ⊗ B
#                     _
#          _          X⊗f         _
#          X⊗U  ---------------≻  X⊗V
#      _    |                      |  _
#      g⊗U  |                      |  g⊗V
#           |         _            |
#          _⋎         Y⊗f         _⋎
#          Y⊗U  ---------------≻  Y⊗V
#
#  to the diagram in k-rows:
#
#                     hom(f,X)
#         hom(U,X)  ≺----------  hom(V,X)
#           ⋏                      ⋏
#           |                      |
# hom(U,g)  |                      |  hom(V,g)
#           |         hom(f,Y)     |
#         hom(U,Y)  ≺----------  hom(V,Y)
#
##
InstallMethod( AlgebroidAsObjectInPreSheavesCategoryData,
          [ IsAlgebroidFromDataTables ],
  
  function ( B )
    local nr_objs, nr_gmors, images_of_objs, images_of_gmorphisms;
    
    nr_objs := EnhancedDataTables( B )[2];
    nr_gmors := EnhancedDataTables( B )[6];
    
    images_of_objs :=
      _ConcatenationLazyHLists_( LazyHList( [ 1 .. nr_objs ],
          l -> LazyHList( [ 1 .. nr_objs ],
            r -> HomomorphismStructureOnObjects( B, SetOfObjects( B )[r], SetOfObjects( B )[l] ) ) ) );
    
    images_of_gmorphisms :=
                _ConcatenationLazyHLists_(
                     [ _ConcatenationLazyHLists_( LazyHList( [ 1 .. nr_objs ], l -> LazyHList( [ 1 .. nr_gmors ],
                        r -> HomomorphismStructureOnMorphisms( B, SetOfGeneratingMorphisms( B )[r], IdentityMorphism( SetOfObjects( B )[l] ) ) ) ) ),
                    _ConcatenationLazyHLists_( LazyHList( [ 1 .. nr_gmors ], l -> LazyHList( [ 1 .. nr_objs ],
                        r -> HomomorphismStructureOnMorphisms( B, IdentityMorphism( SetOfObjects( B )[r] ), SetOfGeneratingMorphisms( B )[l] ) ) ) ) ] );
    
    return Pair( images_of_objs, images_of_gmorphisms );
    
end );

##
InstallMethod( AlgebroidAsObjectInPreSheavesCategory,
          [ IsAlgebroidFromDataTables ],
  
  function ( B )
    local nr_objs, nr_gmors, B_op, B_op_x_B, PSh, range_cat, presheaf_on_objs, presheaf_on_id_or_gmor, presheaf_on_mors;
    
    nr_objs := EnhancedDataTables( B )[2];
    nr_gmors := EnhancedDataTables( B )[6];
    
    B_op := OppositeAlgebroid( B );
    B_op_x_B := TensorProductOfAlgebroids( B_op, B );
    
    PSh := PreSheaves( B_op_x_B );
    range_cat := RangeCategoryOfHomomorphismStructure( B );
    
    Assert( 0, IsIdenticalObj( range_cat, Range( PSh ) ) );
    
    presheaf_on_objs := obj -> AlgebroidAsObjectInPreSheavesCategoryData( B )[1][ObjectIndex( obj )];
    
    presheaf_on_id_or_gmor :=
      function ( w )
        local index, datum, l, r;
        
        if IsEqualToIdentityMorphism( w ) then
              
              datum := ObjectIndex( Source( w ) );
              
              l := QuoInt( datum - 1, nr_objs ) + 1;
              r := RemInt( datum - 1, nr_objs ) + 1;
              
              return IdentityMorphism( HomomorphismStructureOnObjects( B, SetOfObjects( B )[r], SetOfObjects( B )[l] ) );
              
        else
              
              index := Position( SetOfGeneratingMorphisms( B_op_x_B ), w );
              
              return AlgebroidAsObjectInPreSheavesCategoryData( B )[2][index];
              
        fi;
        
    end;
    
    presheaf_on_mors :=
      {s, mor, r} -> SumOfMorphisms( range_cat,
                        s,
                        List( DecompositionOfMorphismInAlgebroid( mor ),
                                  p -> p[1] * PostComposeList( range_cat, List( p[2], presheaf_on_id_or_gmor ) ) ),
                        r );
    
    return ObjectConstructor( PSh, Pair( presheaf_on_objs, presheaf_on_mors ) );
    
end );

##
InstallMethod( AssociatedMorphismIntoAlgebroidAsObjectInPreSheavesCategory,
          [ IsAlgebroidFromDataTablesMorphism ],
  
  function ( m )
    local B, B_op, B_op_x_B, F, PSh, obj, Y_obj;
    
    B := CapCategory( m );
    B_op := OppositeAlgebroid( B );
    B_op_x_B := TensorProductOfAlgebroids( B_op, B );
    
    F := AlgebroidAsObjectInPreSheavesCategory( B );
    PSh := CapCategory( F );
    
    obj := ElementaryTensor( SetOfObjects( B_op )[ObjectIndex( Range( m ) )], Source( m ), B_op_x_B );
    
    Y_obj := YonedaEmbeddingOfSourceCategory( PSh )( obj );
    
    return MorphismFromRepresentableFunctor(
                        PSh,
                        obj,
                        Y_obj,
                        F,
                        InterpretMorphismAsMorphismFromDistinguishedObjectToHomomorphismStructure( B, m ) );
    
end );

##################################
#
# Algebroids By Two-Sided Ideals
#
##################################

##
InstallOtherMethod( QuotientCategory,
        [ IsAlgebroidFromDataTables, IsDenseList ],
  
  function ( B, ideal )
    local B_op, B_op_x_B, F, PSh, C, tau, pi, congruence_function, name, quotient_category, FinalizeCategory, range_of_HomStructure, ring;
    
    B_op := OppositeAlgebroid( B );
    B_op_x_B := TensorProductOfAlgebroids( B_op, B : eager := false );
    
    F := AlgebroidAsObjectInPreSheavesCategory( B );
    
    PSh := CapCategory( F );
    C := Range( PSh );
    
    tau := UniversalMorphismFromDirectSum( PSh, F, List( ideal, AssociatedMorphismIntoAlgebroidAsObjectInPreSheavesCategory ) );
    
    if HasIsAbelianCategory( C ) and IsAbelianCategory( C ) then
        
        pi := CokernelProjection( PSh, tau );
        
        congruence_function :=
          function ( m )
            local obj;
            
            obj := ElementaryTensor( SetOfObjects( B_op )[ObjectIndex( Range( m ) )], Source( m ), B_op_x_B );
            
            return IsZeroForMorphisms( C, PreCompose( C, AssociatedMorphismIntoAlgebroidAsObjectInPreSheavesCategory( m )( obj ), pi( obj ) ) );
            
        end;
        
    elif CanCompute( C, "IsLiftable" ) then
        
        congruence_function :=
          function ( m )
            local obj;
            
            obj := ElementaryTensor( SetOfObjects( B_op )[ObjectIndex( Range( m ) )], Source( m ), B_op_x_B );
            
            return IsLiftable( C, AssociatedMorphismIntoAlgebroidAsObjectInPreSheavesCategory( m )( obj ), tau( obj ) );
            
        end;
        
    else
        
        Error( "the operation 'IsLiftable' must be added to the range category of Hom-Structure!" );
        
    fi;
    
    name := Concatenation( "QuotientCategory( ", Name( B ), ", 2-sided ideal generated by ", String( Length( ideal ) ), " morphisms )" );
    
    if Length( ideal ) = 1 then
        name := ReplacedString( name, "morphisms )", "morphism )" );
    fi;
    
    quotient_category := QuotientCategory( rec(
                                      underlying_category := B,
                                      name := name,
                                      congruence_function := congruence_function,
                                      nr_arguments_of_congruence_function := 1 ) : FinalizeCategory := false );
    ##
    ## Adding the Hom-Structure
    ##
    
    range_of_HomStructure := RangeCategoryOfHomomorphismStructure( B );
    
    ring := UnderlyingRing( range_of_HomStructure );
    
    if IsFieldForHomalg( ring ) then
        
        SetRangeCategoryOfHomomorphismStructure( quotient_category, range_of_HomStructure );
        
        AddDistinguishedObjectOfHomomorphismStructure( quotient_category,
          function ( quotient_category )
            
            return DistinguishedObjectOfHomomorphismStructure( B );
            
        end );
        
        AddHomomorphismStructureOnObjects( quotient_category,
          function ( quotient_category, obj1, obj2 )
            local obj2_op;
            
            obj1 := UnderlyingCell( obj1 );
            obj2 := UnderlyingCell( obj2 );
            
            obj2_op := SetOfObjects( B_op )[ObjectIndex( obj2 )];
            
            return Range( pi )( ElementaryTensor( obj2_op, obj1, B_op_x_B ) );
            
        end );
        
        AddHomomorphismStructureOnMorphismsWithGivenObjects( quotient_category,
          function ( quotient_category, s, f, g, r )
            local g_op, g_op_x_f;
            
            f := UnderlyingCell( f );
            
            g_op := CreateMorphism(
                      B_op,
                      SetOfObjects( B_op )[ObjectIndex( UnderlyingCell( Range( g ) ) )],
                      CoefficientsOfMorphism( UnderlyingCell( g ) ),
                      MorphismSupport( UnderlyingCell( g ) ),
                      SetOfObjects( B_op )[ObjectIndex( UnderlyingCell( Source( g ) ) )] );
            
            g_op_x_f := ElementaryTensor( g_op, f, B_op_x_B );
            
            return CokernelObjectFunctorialWithGivenCokernelObjects( range_of_HomStructure,
                        s,
                        tau( Range( g_op_x_f ) ),
                        F( g_op_x_f ),
                        tau( Source( g_op_x_f ) ),
                        r );
            
        end );
        
        AddInterpretMorphismAsMorphismFromDistinguishedObjectToHomomorphismStructure( quotient_category,
          function ( quotient_category, mor )
            local distinguished_object, obj1, obj2, obj2_op, obj2_op_x_obj1;
            
            distinguished_object := DistinguishedObjectOfHomomorphismStructure( quotient_category );
            
            mor := UnderlyingCell( mor );
            
            obj1 := Source( mor );
            obj2 := Range( mor );
            
            obj2_op := SetOfObjects( B_op )[ObjectIndex( obj2 )];
            
            obj2_op_x_obj1 := ElementaryTensor( obj2_op, obj1, B_op_x_B );
            
            return PreCompose(
                      range_of_HomStructure,
                      InterpretMorphismAsMorphismFromDistinguishedObjectToHomomorphismStructureWithGivenObjects( B, distinguished_object, mor, F( obj2_op_x_obj1 ) ),
                      pi( obj2_op_x_obj1 ) );
            
        end );
        
        AddInterpretMorphismFromDistinguishedObjectToHomomorphismStructureAsMorphism( quotient_category,
          function ( quotient_category, obj1, obj2, eta )
            local obj2_op, obj2_op_x_obj1, ell, mor;
            
            obj1 := UnderlyingCell( obj1 );
            obj2 := UnderlyingCell( obj2 );
            
            obj2_op := SetOfObjects( B_op )[ObjectIndex( obj2 )];
            obj2_op_x_obj1 := ElementaryTensor( obj2_op, obj1, B_op_x_B );
            
            ell := ProjectiveLift( range_of_HomStructure, eta, pi( obj2_op_x_obj1 ) );
            
            mor := InterpretMorphismFromDistinguishedObjectToHomomorphismStructureAsMorphism( B, obj1, obj2, ell );
            
            return mor / quotient_category;
            
        end );
         
    else
        
        range_of_HomStructure := FreydCategory( range_of_HomStructure );
        
        SetRangeCategoryOfHomomorphismStructure( quotient_category, range_of_HomStructure );
        
        AddDistinguishedObjectOfHomomorphismStructure( quotient_category,
          function ( quotient_category )
            
            return AsFreydCategoryObject( range_of_HomStructure, DistinguishedObjectOfHomomorphismStructure( B ) );
            
        end );
        
        AddHomomorphismStructureOnObjects( quotient_category,
          function ( quotient_category, obj1, obj2 )
            local obj2_op;
            
            obj1 := UnderlyingCell( obj1 );
            obj2 := UnderlyingCell( obj2 );
            
            obj2_op := SetOfObjects( B_op )[ObjectIndex( obj2 )];
            
            return FreydCategoryObject( range_of_HomStructure, tau( ElementaryTensor( obj2_op, obj1, B_op_x_B ) ) );
            
        end );
        
        AddHomomorphismStructureOnMorphismsWithGivenObjects( quotient_category,
          function ( quotient_category, s, f, g, r )
            local g_op, g_op_x_f;
            
            f := UnderlyingCell( f );
            
            g_op := CreateMorphism(
                      B_op,
                      SetOfObjects( B_op )[ObjectIndex( UnderlyingCell( Range( g ) ) )],
                      CoefficientsOfMorphism( UnderlyingCell( g ) ),
                      MorphismSupport( UnderlyingCell( g ) ),
                      SetOfObjects( B_op )[ObjectIndex( UnderlyingCell( Source( g ) ) )] );
            
            g_op_x_f := ElementaryTensor( g_op, f, B_op_x_B );
            
            return FreydCategoryMorphism( range_of_HomStructure,
                        s,
                        F( g_op_x_f ),
                        r );
            
        end );
        
        AddInterpretMorphismAsMorphismFromDistinguishedObjectToHomomorphismStructureWithGivenObjects( quotient_category,
          function ( quotient_category, distinguished_object, mor, r )
            
            return FreydCategoryMorphism( range_of_HomStructure,
                      distinguished_object,
                      InterpretMorphismAsMorphismFromDistinguishedObjectToHomomorphismStructureWithGivenObjects( B,
                                        Range( RelationMorphism( distinguished_object ) ),
                                        UnderlyingCell( mor ),
                                        Range( RelationMorphism( r ) ) ),
                      r );
            
        end );
        
        AddInterpretMorphismFromDistinguishedObjectToHomomorphismStructureAsMorphism( quotient_category,
          function ( quotient_category, obj1, obj2, eta )
            local mor;
            
            mor := InterpretMorphismFromDistinguishedObjectToHomomorphismStructureAsMorphism( B,
                                    UnderlyingCell( obj1 ),
                                    UnderlyingCell( obj2 ),
                                    UnderlyingMorphism( eta ) );
            
            return mor / quotient_category;
            
        end );
    
    fi;
    
    InstallMethod( DisplayString,
              [ ObjectFilter( quotient_category ) ],
    
    ViewString );
    
    InstallMethod( ViewString,
              [ ObjectFilter( quotient_category ) ],
      function ( obj )
        
        return ViewString( UnderlyingCell( obj ) );
        
    end );
    
    InstallMethod( DisplayString,
              [ MorphismFilter( quotient_category ) ],
    
    ViewString );
    
    InstallMethod( ViewString,
              [ MorphismFilter( quotient_category ) ],
      function ( mor )
        local string;
        
        string := ViewString( UnderlyingCell( mor ) );
        string := ReplacedString( string, "<", "<[ " );
        string := ReplacedString( string, ">", " ]>" );
        
        return string;
        
    end );
    
    Finalize( quotient_category );
    
    return quotient_category;
    
end );

##
InstallOtherMethod( \/,
        [ IsAlgebroidFromDataTables, IsDenseList ],
  
  QuotientCategory );

###################
#
# View Methods
#
###################

##
InstallMethod( ViewString,
          [ IsAlgebroidFromDataTablesObject ],
  
  function ( obj )
    
    return Concatenation( "<(", EnhancedDataTables( CapCategory( obj ) )[3][ObjectIndex( obj )], ")>" );
    
end );

##
InstallMethod( DisplayString,
          [ IsAlgebroidFromDataTablesObject ],
  
  ViewString );


##
InstallMethod( LaTeXOutput,
          [ IsAlgebroidFromDataTablesObject ],
  
  function ( obj )
    
    return EnhancedDataTables( CapCategory( obj ) )[4][ObjectIndex(obj)];
    
end );

##
InstallMethod( ViewString,
          [ IsAlgebroidFromDataTablesMorphism ],
  
  function ( alpha )
    local B, i, j, coeffs, support, colors, datum_string, labels;
    
    B := CapCategory( alpha );
    
    i := ObjectIndex( Source( alpha ) );
    j := ObjectIndex( Range( alpha ) );
    
    coeffs := MorphismCoefficients( alpha );
    support := MorphismSupport( alpha );
    
    colors := EnhancedDataTables( B )[23];
    
    if IsEmpty( support ) then
        datum_string := Concatenation( colors.coeff, "0", colors.reset );
    else
        coeffs := List( coeffs{support}, String );
        coeffs := List( coeffs, c -> Concatenation( colors.coeff, c, colors.reset ) );
        
        labels := (ListOfValues(EnhancedDataTables( B )[15]){EnhancedDataTables( B )[17][i][j]}){support};
        labels := List( labels, l -> Concatenation( colors.basis_elm, l, colors.reset ) );
        
        datum_string := JoinStringsWithSeparator( ListN( coeffs, labels, { c, l } -> Concatenation( c, "*", l ) ), " + " );
        datum_string := ReplacedString( datum_string, Concatenation( "+ ", colors.coeff, "-" ), Concatenation( "- ", colors.coeff ) );
    fi;
    
    return
      Concatenation(
          "<",
          datum_string,
          colors.other,
          ":",
          colors.reset,
          "(",
          colors.obj,
          EnhancedDataTables( B )[3][i],
          colors.reset,
          ") ",
          colors.other,
          "-≻",
          colors.reset,
          " (",
          colors.obj,
          EnhancedDataTables( B )[3][j],
          colors.reset,
          ")>" );
    
end );

##
InstallMethod( DisplayString,
          [ IsAlgebroidFromDataTablesMorphism ],
  
  ViewString );

##
InstallMethod( LaTeXOutput,
          [ IsAlgebroidFromDataTablesMorphism ],
  
  function ( alpha )
    local B, i, j, coeffs, support, string;
    
    B := CapCategory( alpha );
    
    i := ObjectIndex( Source( alpha ) );
    j := ObjectIndex( Range( alpha ) );
    
    coeffs := MorphismCoefficients( alpha );
    support := MorphismSupport( alpha );
    
    if IsEmpty( support ) then
        string := "0";
    else
        coeffs := List( coeffs{support},  function (c)
                                            
                                            if c in [ 1, -1 ] then
                                                  return ReplacedString( LaTeXOutput( c ), "1", "" );
                                            else
                                                  return Concatenation( LaTeXOutput( c ), "\\cdot " );
                                            fi;
                                            
                                          end );
        
        string := (ListOfValues(EnhancedDataTables( B )[16]){EnhancedDataTables( B )[17][i][j]}){support};
        string := ReplacedString( JoinStringsWithSeparator( ListN( coeffs, string, { c, l } -> Concatenation( c, l ) ), " + " ), "+ -", "- " );
    fi;
    
    if ValueOption( "OnlyDatum" ) = true then
      
      return string;
      
    else
      
      return Concatenation(
                "{", LaTeXOutput( Source( alpha ) ), "}-\\left(",
                "{", string, "}\\right)\\rightarrow",
                "{", LaTeXOutput( Range( alpha ) ), "}" );
    
    fi;
    
end );

