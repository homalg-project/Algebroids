# SPDX-License-Identifier: GPL-2.0-or-later
# Algebroids: Algebroids and bialgebroids as preadditive categories generated by enhanced quivers
#
# Implementations
#

##
InstallMethod( DataTablesOfCategory,
            "for hom-finite k-algebroids",
          [ IsAlgebroid ],
  
  function ( B )
    local objs, gmors, bases_elms;
    
    if not HasRangeCategoryOfHomomorphismStructure( B ) then
        Error( "the algebroid passed to 'DataTablesOfCategory' must be hom-finite!" );
    fi;
    
    objs := SetOfObjects( B );
    
    gmors := SetOfGeneratingMorphisms( B );
    
    bases_elms := Concatenation( List( objs, u -> Concatenation( List( objs, v -> BasisOfExternalHom( v, u ) ) ) ) );
    
    return rec(
      coefficients_ring := CommutativeRingOfLinearCategory( B ),
      nr_objs := Length( objs ),
      nr_bases_elms := Length( bases_elms ),
      
      labels_objs := List( objs, o -> LabelAsString(UnderlyingVertex(o)) ),
      latex_strings_objs := List( objs, o -> LaTeXOutput( o ) ),
      indices_objs := List( objs, o -> Position( bases_elms, IdentityMorphism( o ) ) ),
      
      nr_gmors := Length( gmors ),
      labels_gmors := List( gmors, m -> LabelAsString( Paths( UnderlyingQuiverAlgebraElement( m ) )[1] ) ),
      latex_strings_gmors := List( gmors, m -> LaTeXOutput( m : OnlyDatum := true ) ),
      indices_gmors := List( gmors, m -> Position( bases_elms, m ) ),
      sources_gmors := List( gmors, m -> Position( objs, Source( m ) ) ),
      ranges_gmors := List( gmors, m -> Position( objs, Range( m ) ) ),
      
      bases_elms_comps := Concatenation( List( objs,
                            i -> Concatenation( List( objs,
                              j -> List( BasisOfExternalHom( j, i ),
                                b -> List( DecompositionOfMorphismInAlgebroid(b)[1][2],
                                  function ( g )
                                    if IsEqualToIdentityMorphism( g ) then
                                            return -VertexIndex( UnderlyingVertex( Source( g ) ) );
                                    else
                                            return Position( SetOfGeneratingMorphisms( B ), g );
                                    fi;
                                  end ) ) ) ) ) ),
      
      indices_of_bases_elms := List( objs,
                                i -> List( objs,
                                  j -> List( BasisOfExternalHom( j, i ),
                                    b -> Position( bases_elms, b ) ) ) ),
      
      hom_structure_objs_gmors := List( objs,
                                    o -> List( gmors,
                                      gm -> EntriesOfHomalgMatrixAsListList( UnderlyingMatrix( HomStructure( o, gm ) ) ) ) ),
      
      hom_structure_gmors_objs := List( objs,
                                    o -> List( gmors,
                                      gm -> EntriesOfHomalgMatrixAsListList( UnderlyingMatrix( HomStructure( gm, o ) ) ) ) ) );
end );

##
InstallMethod( IsomorphismOntoAlgebroidFromDataTables,
          [ IsAlgebroid ],
  
  function ( A )
    local B, eta;
    
    B := AlgebroidFromDataTables( A );
    
    eta := CapFunctor( "Isomorphism functor onto algebroid from data tables", A, B );
    
    AddObjectFunction( eta,
      
      o -> CreateObject( B, VertexIndex( UnderlyingVertex( o ) ) )
    );
    
    AddMorphismFunction( eta,
      
      { s, alpha, r } -> CreateMorphism( B, s, CoefficientsOfMorphism( A, alpha ), r )
    );
    
    return eta;
    
end );

##
InstallMethod( IsomorphismFromAlgebroidFromDataTables,
          [ IsAlgebroid ],
  
  function ( A )
    local B, eta;
    
    B := AlgebroidFromDataTables( A );
    
    eta := CapFunctor( "Isomorphism functor from algebroid from data tables", B, A );
    
    AddObjectFunction( eta,
      
      o -> ObjectInAlgebroid( A, Vertex( UnderlyingQuiver( A ), ObjectIndex( o ) ) )
    );
    
    AddMorphismFunction( eta,
      
      { s, alpha, r } -> SumOfMorphisms( A, s, ListN( MorphismCoefficients( alpha ), BasisOfExternalHom( s, r ), \* ), r )
    );
    
    return eta;
    
end );

##
InstallOtherMethod( DataTablesOfCategory,
            "for quotient categories of k-algebroids enriched over k-rows",
          [ IsQuotientCapCategory ],
  
  function ( qB )
    local B, objs, support_objs, gmors, support_gmors, bases_elms;
    
    if not HasRangeCategoryOfHomomorphismStructure( qB ) then
        Error( "the quotient category passed to 'DataTablesOfCategory' must be hom-finite!" );
    fi;
    
    if not IsCategoryOfRows( RangeCategoryOfHomomorphismStructure( qB ) ) then
        TryNextMethod();
    fi;
    
    B := UnderlyingCategory( qB );
    
    objs := List( SetOfObjects( B ), o -> o / qB );
    support_objs := PositionsProperty( objs, o -> not IsZero( o ) );
    objs := objs{support_objs};
    
    gmors := List( SetOfGeneratingMorphisms( B ), m -> m / qB );
    support_gmors := PositionsProperty( gmors, m -> not IsZero( m ) );
    gmors := gmors{support_gmors};
    
    bases_elms := Concatenation( List( objs, u -> Concatenation( List( objs, v -> BasisOfExternalHom( v, u ) ) ) ) );
    
    return rec(
      coefficients_ring := CommutativeRingOfLinearCategory( B ),
      nr_objs := Length( objs ),
      nr_bases_elms := Length( bases_elms ),
      
      labels_objs := (EnhancedDataTables( B )[3]){support_objs},
      indices_objs := List( objs, o -> Position( bases_elms, IdentityMorphism( o ) ) ),
      
      nr_gmors := Length( gmors ),
      labels_gmors := (EnhancedDataTables( B )[7]){support_gmors},
      indices_gmors := List( gmors, m -> Position( bases_elms, m ) ),
      sources_gmors := List( gmors, m -> Position( objs, Source( m ) ) ),
      ranges_gmors := List( gmors, m -> Position( objs, Range( m ) ) ),
      
      bases_elms_comps := Concatenation( List( objs,
                              u -> Concatenation( List( objs,
                                v -> List( BasisOfExternalHom( v, u ),
                                  b -> List( DecompositionOfMorphismInAlgebroid( UnderlyingCell( b ) )[1][2],
                                    function ( g )
                                      if IsEqualToIdentityMorphism( g ) then
                                            return -Position( objs, Source( g ) / qB );
                                      else
                                            return Position( gmors, g / qB );
                                      fi;
                                    end ) ) ) ) ) ),
      
      indices_of_bases_elms := List( objs,
                                u -> List( objs,
                                  v -> List( BasisOfExternalHom( v, u ),
                                    b -> Position( bases_elms, b ) ) ) ),
      
      hom_structure_objs_gmors := List( objs,
                    o -> List( gmors,
                      gm -> EntriesOfHomalgMatrixAsListList( UnderlyingMatrix( HomStructure( o, gm ) ) ) ) ),
      
      hom_structure_gmors_objs := List( objs,
                    o -> List( gmors,
                      gm -> EntriesOfHomalgMatrixAsListList( UnderlyingMatrix( HomStructure( gm, o ) ) ) ) ) );
end );

############################
#
# Auxiliary Functions
#
############################

##
BindGlobal( "_Product_Matrices_",
  
  function ( m_1, mat_1, n_1, m_2, mat_2, n_2, ring )
    
    if n_1 <> m_2 then
        Error("you are multiplying two non-compatible matrices!");
    fi;
    
    if m_1 = 0 or n_2 = 0 then
        return ListWithIdenticalEntries( m_1, [] );
    elif n_1 = 0 then
        return NullMat( m_1, n_2, ring );
    else
        return mat_1 * mat_2;
    fi;
    
end );

##
BindGlobal( "_Product_Matrices_List_",
  
  function ( L, ring )
    
    if IsEmpty( L ) then
        Error( "the list pass to '_Product_Matrices_List_' must not be empty!" );
    fi;
    
    if Length( L ) = 1 then
        return L[1];
    else
        return Iterated( L, { l, r } -> [ l[1], _Product_Matrices_( l[1], l[2], l[3], r[1], r[2], r[3], ring ), r[3] ] );
    fi;
    
end );

##
BindGlobal( "_KroneckerProduct_",
  function ( m_1, mat_1, n_1, m_2, mat_2, n_2 )
    
    if m_1 * m_2 = 0 or n_1 * n_2 = 0 then
        return ListWithIdenticalEntries( m_1 * m_2, [] );
    else
        return KroneckerProduct( mat_1, mat_2 );
    fi;
    
end );

##
BindGlobal( "_ConcatenationLazyHLists_",
  
  function ( list )
    local n, indices, i;
    
    n := Length( list );
    
    indices := [ 0 ];
    
    for i in [ 1 .. n ] do
        Add( indices, indices[i] + Length( list[i] ) );
    od;
    
    return LazyHList( [ 1 .. indices[n+1] ],
                function ( i )
                  local pos;
                  
                  pos := PositionSorted( indices, i ) - 1;
                  
                  return list[pos][i-indices[pos]];
                  
                end );
     
end );

###########################
#
# Category Constructor
#
###########################

##
InstallOtherMethod( AlgebroidFromDataTables,
          [ IsAlgebroid ],
  
  B -> AlgebroidFromDataTables( DataTablesOfCategory( B ) )
);

##
InstallOtherMethod( AlgebroidFromDataTables,
          [ IsQuotientCapCategory ],
  
  qB -> AlgebroidFromDataTables( DataTablesOfCategory( qB ) )
);

##
InstallMethod( AlgebroidFromDataTables,
          [ IsRecord ],
  
  function ( input_data )
    local data, range_category_of_hom_structure, hom_structure_objs_gmors, hom_structure_on_objs_bases_elms, hom_structure_gmors_objs, hom_structure_on_bases_elms_objs, eager, name, o_string, gm_string, with_or_without_s, cat, p;
    
    data := [];
    
    # coefficient ring
    
    data[1] := input_data.coefficients_ring;
    
    # objects
    
    data[2] := input_data.nr_objs;
    data[3] := input_data.labels_objs;
    
    if IsBound( input_data.latex_strings_objs ) then
        data[4] := input_data.latex_strings_objs;
    else
        data[4] := input_data.labels_objs;
    fi;
    
    data[5] := input_data.indices_objs;
    
    # generating morphisms
    
    data[6] := input_data.nr_gmors;
    data[7] := input_data.labels_gmors;
    
    if IsBound( input_data.latex_strings_gmors ) then
        data[8] := input_data.latex_strings_gmors;
    else
        data[8] := input_data.labels_gmors;
    fi;
    
    data[9] := input_data.indices_gmors;
    data[10] := input_data.sources_gmors;
    data[11] := input_data.ranges_gmors;
    
    # all bases elements
    
    data[12] := input_data.nr_bases_elms;
    data[13] := input_data.bases_elms_comps;
    
    if IsBound( input_data.labels_of_bases_elms ) then
          data[14] := input_data.labels_of_bases_elms;
    else
          data[14] :=
              LazyHList( data[13],
                 m -> JoinStringsWithSeparator(
                        List( CollectEntries( List( m,
                          function ( g )
                            if g < 0 then
                                return Concatenation( "id(", data[3][-g], ")" );
                            else
                                return data[7][g];
                            fi;
                          end ) ),
                          function ( pair )
                            if pair[2] = 1 then
                                return pair[1];
                            else
                                return Concatenation( pair[1], "^", String( pair[2] ) );
                            fi;
                          end ) , "•" ) );
    fi;
    
    if IsBound( input_data.latex_strings_of_bases_elms ) then
          data[15] := input_data.latex_strings_of_bases_elms;
    else
          data[15] :=
              LazyHList( data[13],
                 m -> JoinStringsWithSeparator(
                        List( CollectEntries( List( m,
                          function ( g )
                            if g < 0 then
                                return Concatenation( "id_{", data[4][-g], "}" );
                            else
                                return data[8][g];
                            fi;
                          end ) ),
                          function ( pair )
                            if pair[2] = 1 then
                                return pair[1];
                            else
                                return Concatenation( pair[1], "^{", String( pair[2] ), "}" );
                            fi;
                          end ) , "" ) );
    fi;
    
    data[16] := input_data.indices_of_bases_elms;
    
    data[17] := input_data.hom_structure_objs_gmors;
    
    data[18] := input_data.hom_structure_gmors_objs;
    
    # homomorphism structure
    
    data[19] := LazyHList( data[16], i -> LazyHList( i, Length ) );
    
    if IsBound( input_data.hom_structure_on_bases_elms ) then
        
        data[20] := input_data.hom_structure_on_bases_elms;
        
    else
        
        hom_structure_objs_gmors := LazyHList( [ 1 .. data[2] ],
                  i -> LazyHList( [ 1 .. data[6] ],
                    j -> [ data[19][data[10][j]][i],
                           data[17][i][j],
                           data[19][data[11][j]][i] ] ) );
        
        hom_structure_on_objs_bases_elms :=
                LazyHList( [ 1 .. data[2] ],
                  i -> List( [ 1 .. data[12] ],
                    function ( j )
                      local m;
                      
                      m := data[13][j];
                      
                      if Length( m ) = 1 and m[1] < 0 then
                          m := data[19][-m[1]][i];
                          return [ m, IdentityMat( m, data[1] ), m ];
                      else
                          return _Product_Matrices_List_( hom_structure_objs_gmors[i]{m}, data[1] );
                      fi;
                      
                    end ) );
        
        hom_structure_gmors_objs := LazyHList( [ 1 .. data[2] ],
                  i -> LazyHList( [ 1 .. data[6] ],
                    j -> [ data[19][i][data[11][j]],
                           data[18][i][j],
                           data[19][i][data[10][j]] ] ) );
        
        hom_structure_on_bases_elms_objs :=
                LazyHList( [ 1 .. data[2] ],
                  i -> List( [ 1 .. data[12] ],
                    function ( j )
                      local m;
                      
                      m := data[13][j];
                      
                      if Length(m) = 1 and m[1] < 0 then
                          m := data[19][i][-m[1]];
                          return [ m, IdentityMat( m, data[1] ), m ];
                      else
                          return _Product_Matrices_List_( hom_structure_gmors_objs[i]{Reversed( m )}, data[1] );
                      fi;
                      
                    end ) );
        
        data[20] :=
          LazyHList( [ 1 .. data[2] ],
            i -> LazyHList( [ 1 .. data[2] ],
              j -> LazyHList( [ 1 .. data[2] ],
                p -> LazyHList( [ 1 .. data[2] ],
                  q -> LazyHList( hom_structure_on_bases_elms_objs[q]{data[16][j][i]},
                    l -> LazyHList( hom_structure_on_objs_bases_elms[j]{data[16][q][p]},
                      r -> _Product_Matrices_( r[1], r[2], r[3], l[1], l[2], l[3], data[1] ) ) ) ) ) ) );
    fi;
    
    # other
    
    data[21] := LazyHList( [ 1 .. data[6] ],
                  i -> Cartesian( [ i ], Filtered( [ 1 .. input_data.nr_gmors ],
                    j -> input_data.ranges_gmors[i] = input_data.sources_gmors[j] ) ) );
    
    if not IsBound( input_data.colors ) then
          
          data[22] := rec( obj := "", coeff := "", basis_elm := "", other := "", reset := "" );
          
    elif input_data.colors = true then
          
          data[22] := rec( obj := TextAttr.4, coeff := TextAttr.5, basis_elm := TextAttr.2, other := TextAttr.1, reset := TextAttr.reset );
          # to avoid line-breaking run SizeScreen([3000,3000]);
    else
          data[22] := input_data.colors;
    fi;
    
    data :=
      NTuple( 22,
         data[1],    # ring
         data[2],    # nr_objs
         data[3],    # labels_objs
         data[4],    # latex_strings_objs
         data[5],    # indices_objs
         data[6],    # nr_gmors
         data[7],    # labels_gmors
         data[8],    # latex_strings_gmors
         data[9],    # indices_gmors
         data[10],   # sources_gmors
         data[11],   # ranges_gmors
         data[12],   # nr_bases_elms
         data[13],   # bases_elms_comps
         data[14],   # labels_of_bases_elms
         data[15],   # latex_strings_of_bases_elms
         data[16],   # indices_of_bases_elms
         data[17],   # hom_structure_objs_gmors
         data[18],   # hom_structure_gmors_objs
         data[19],   # hom_structure_ranks
         data[20],   # hom_structure_on_bases_elms
         data[21],   # indices_composable_gmors
         data[22] ); # colors
    
    eager := CAP_INTERNAL_RETURN_OPTION_OR_DEFAULT( "eager", true );
    
    if eager then
        
        ListOfValues( data[14] );
        
        ListOfValues( data[15] );
        
        List( ListOfValues( data[19] ), ListOfValues );
        
        List( ListOfValues( data[20] ),
          a -> List( ListOfValues( a ),
            b -> List( ListOfValues( b ),
              c -> List( ListOfValues( c ),
                d -> List( ListOfValues( d ),
                  e -> ListOfValues( e ) ) ) ) ) );
        
    fi;
    
    if IsBound( input_data.name ) then
        
        name := input_data.name;
        
    else
        
        if input_data.nr_objs < 10 then
            o_string := JoinStringsWithSeparator( input_data.labels_objs, "," );
        else
            o_string := Concatenation(
                              JoinStringsWithSeparator( input_data.labels_objs{[1..3]}, "," ),
                              ",..,",
                              JoinStringsWithSeparator( input_data.labels_objs{[input_data.nr_objs - 2 .. input_data.nr_objs]}, "," ) );
        fi;
        
        if input_data.nr_gmors < 10 then
            
            gm_string := JoinStringsWithSeparator(
                          ListN( input_data.labels_gmors, input_data.sources_gmors, input_data.ranges_gmors,
                              { l, i, j } -> Concatenation( l, ":", input_data.labels_objs[i], "-≻", input_data.labels_objs[j] ) ), "," );
        else
            
            gm_string := Concatenation(
                              JoinStringsWithSeparator(
                                  ListN( input_data.labels_gmors{[1..3]}, input_data.sources_gmors{[1..3]}, input_data.ranges_gmors{[1..3]},
                                    { l, i, j } -> Concatenation( l, ":", input_data.labels_objs[i], "-≻", input_data.labels_objs[j] ) ), "," ),
                              ",..,",
                              JoinStringsWithSeparator(
                                  ListN( input_data.labels_gmors{[input_data.nr_gmors - 2 .. input_data.nr_gmors]},
                                         input_data.sources_gmors{[input_data.nr_gmors - 2 .. input_data.nr_gmors]},
                                         input_data.ranges_gmors{[input_data.nr_gmors - 2 .. input_data.nr_gmors]},
                                            { l, i, j } -> Concatenation( l, ":", input_data.labels_objs[i], "-≻", input_data.labels_objs[j] ) ), "," ) );
        
        fi;
        
        with_or_without_s := nr -> Concatenation( Concatenation( [ "" ], ListWithIdenticalEntries( Position( [ false, true ], nr <> 1 ) - 1, "s" ) ) );
        
        name := Concatenation(
                      RingName( input_data.coefficients_ring ),
                      "-algebroid( {",
                      o_string,
                      "}[",
                      gm_string,
                      "] ) defined by ",
                      String( input_data.nr_objs ),
                      " object",
                      with_or_without_s( input_data.nr_objs ),
                      " and ",
                      String( input_data.nr_gmors ),
                      " generating morphism",
                      with_or_without_s( input_data.nr_gmors ) );
        
    fi;
    
    cat := CreateCapCategoryWithDataTypes( name,
                   IsAlgebroidFromDataTables,
                   IsObjectInAlgebroidFromDataTables,
                   IsMorphismInAlgebroidFromDataTables,
                   IsCapCategoryTwoCell,
                   IsInt,
                   CapJitDataTypeOfListOf( IsHomalgRingElement ),
                   fail );
    
    # Similar to Algebroids
    DeactivateCachingOfCategory( cat );
    CapCategorySwitchLogicOff( cat );
    DisableSanityChecks( cat );
    
    SetEnhancedDataTables( cat, data );
    
    SetIsAbCategory( cat, true );
    SetIsLinearCategoryOverCommutativeRing( cat, true );
    SetCommutativeRingOfLinearCategory( cat, input_data.coefficients_ring );
    
    range_category_of_hom_structure := CAP_INTERNAL_RETURN_OPTION_OR_DEFAULT( "range_of_HomStructure", CategoryOfRows( data[1] : overhead := false, FinalizeCategory := true ) );
    
    # The following line will never be compiled as it is an attribute to the algebroid.
    # Whenever needed, one can replace <CreateMorphism> by <MorphismConstructor> after dropping the <index> argument.
    SetSetOfBasesOfExternalHomsLazyHList( cat,
                    LazyHList( [ 1 .. data[2] ],
                        i -> LazyHList( [ 1 .. data[2] ],
                          j -> ListN( [ 1 .. data[19][i][j] ], IdentityMat( data[19][i][j], data[1] ),
                            { index, coeff } -> CreateMorphism( cat, SetOfObjects( cat )[j], coeff, [ index ], SetOfObjects( cat )[i] ) ) ) ) );
    
    cat!.compiler_hints :=
      rec( category_attribute_names :=
           [ "SetOfObjects",
             "SetOfGeneratingMorphisms",
             "EnhancedDataTables",
             "SetOfBasesOfExternalHomsLazyHList",
             "CommutativeRingOfLinearCategory",
             "DefiningTripleOfUnderlyingQuiver",
            ],
            precompiled_towers := [
            rec(
                remaining_constructors_in_tower := [ "AdditiveClosure" ],
                precompiled_functions_adder := ADD_FUNCTIONS_FOR_AdditiveClosureOfAlgebroidFromDataTables ),
            ] );
    
    ##
    AddObjectConstructor( cat,
      
      function ( cat, index )
        
        return SetOfObjects( cat )[index];
        
    end );
    
    ##
    AddObjectDatum( cat,
      
      function ( cat, obj )
        
        return ObjectIndex( obj );
        
    end );
    
    ##
    AddMorphismConstructor( cat,
      
      function ( cat, obj_1, datum, obj_2 )
        
        return CreateCapCategoryMorphismWithAttributes( cat,
                                            obj_1, obj_2,
                                            MorphismCoefficients, datum );
        
    end );
    
    ##
    AddMorphismDatum( cat,
      
      function ( cat, alpha )
        
        return MorphismCoefficients( alpha );
        
    end );
    
    ##
    AddIsWellDefinedForObjects( cat,
      
      function ( cat, obj )
        
        return 0 < ObjectIndex( obj ) and ObjectIndex( obj ) <= EnhancedDataTables( cat )[2];
        
    end );
    
    ##
    AddIsEqualForObjects( cat,
      
      function ( cat, obj_1, obj_2 )
        
        return ObjectIndex( obj_1 ) = ObjectIndex( obj_2 );
        
    end );
    
    ##
    AddIsWellDefinedForMorphisms( cat,
      
      function ( cat, mor )
        
        return EnhancedDataTables( cat )[19][ObjectIndex( Range( mor ) )][ObjectIndex( Source( mor ) )] = Length( MorphismCoefficients( mor ) );
        
    end );

    ##
    AddIsEqualForMorphisms( cat,
      
      function ( cat, mor_1, mor_2 )
        
        return MorphismCoefficients( mor_1 ) = MorphismCoefficients( mor_2 );
        
    end );
    
    ##
    AddIsCongruentForMorphisms( cat,
      
      function ( cat, mor_1, mor_2 )
        
        return MorphismCoefficients( mor_1 ) = MorphismCoefficients( mor_2 );
        
    end );
    
    ##
    AddIdentityMorphism( cat,
      
      function ( cat, obj )
        local i;
        
        i := ObjectIndex( obj );
        
        return SetOfBasesOfExternalHomsLazyHList( cat )[i][i][SafePosition( EnhancedDataTables( cat )[16][i][i], EnhancedDataTables( cat )[5][i] )];
        
    end );
    
    ##
    AddZeroMorphism( cat,
      
      function ( cat, obj_1, obj_2 )
        
        return MorphismConstructor( cat,
                    obj_1,
                    ListWithIdenticalEntries(
                      EnhancedDataTables( cat )[19][ObjectIndex( obj_2 )][ObjectIndex( obj_1 )],
                      ZeroImmutable( CommutativeRingOfLinearCategory( cat ) ) ),
                    obj_2 );
        
    end );
    
    ##
    AddMultiplyWithElementOfCommutativeRingForMorphisms( cat,
      
      function ( cat, r, alpha )
        
        return MorphismConstructor( cat, Source( alpha ), List( MorphismCoefficients( alpha ), c -> r * c ), Range( alpha ) );
        
    end );
    
    ##
    AddAdditionForMorphisms( cat,
      
      function ( cat, alpha_1, alpha_2 )
        
        return MorphismConstructor( cat, Source( alpha_1 ), Sum( List( [ alpha_1, alpha_2 ], MorphismCoefficients ) ), Range( alpha_1 ) );
        
    end );
    
    ##
    AddAdditiveInverseForMorphisms( cat,
      
      function ( cat, alpha )
        
        return  MorphismConstructor( cat, Source( alpha ), List( MorphismCoefficients( alpha ), c -> -c ), Range( alpha ) );
        
    end );
    
    #
    AddBasisOfExternalHom( cat,
      
      function ( cat, obj_1, obj_2 )
        
        return SetOfBasesOfExternalHomsLazyHList( cat )[ObjectIndex( obj_2 )][ObjectIndex( obj_1 )];
        
    end );
    
    #
    AddCoefficientsOfMorphism( cat,
      
      function ( cat, alpha )
        
        return MorphismCoefficients( alpha );
        
    end );
    
    ## Hom-Structure
    
    SetIsEquippedWithHomomorphismStructure( cat, true );
    
    SetRangeCategoryOfHomomorphismStructure( cat, range_category_of_hom_structure );
    
    ##
    AddDistinguishedObjectOfHomomorphismStructure( cat,
      
      function ( cat )
        
        return ObjectConstructor( RangeCategoryOfHomomorphismStructure( cat ), 1 );
        
    end );
    
    ##
    AddHomomorphismStructureOnObjects( cat,
      
      function ( cat, obj_1, obj_2 )
        
        return ObjectConstructor( RangeCategoryOfHomomorphismStructure( cat ), EnhancedDataTables( cat )[19][ObjectIndex( obj_2 )][ObjectIndex( obj_1 )] );
        
    end );
    
    ##  H(α:i->j, γ:p->q) = H( α•id_j, γ•id_q ) = H(id_j, γ)•H(α, id_q)
    ##
    AddHomomorphismStructureOnMorphismsWithGivenObjects( cat,
      
      function ( cat, s, alpha, gamma, r )
        local s_alpha, s_gamma, i, j, p, q, hom_ijpq, coeffs_alpha, coeffs_gamma, mat;
        
        if (RankOfObject( s ) = 0 or Length( MorphismSupport( alpha ) ) = 0)  or (RankOfObject( r ) = 0 or Length( MorphismSupport( gamma ) ) = 0) then

            return ZeroMorphism( RangeCategoryOfHomomorphismStructure( cat ), s, r );

        else

            s_alpha := MorphismSupport( alpha );
            s_gamma := MorphismSupport( gamma );

            i := ObjectIndex( Source( alpha ) );
            j := ObjectIndex( Range( alpha ) );

            p := ObjectIndex( Source( gamma ) );
            q := ObjectIndex( Range( gamma ) );

            hom_ijpq := EnhancedDataTables( cat )[20][i][j][p][q];

            coeffs_alpha := MorphismCoefficients( alpha );
            coeffs_gamma := MorphismCoefficients( gamma );

            mat := Sum( List( [ 1 .. Length( s_alpha ) ], l -> Sum( List( [ 1 .. Length( s_gamma ) ], r -> List( hom_ijpq[s_alpha[l]][s_gamma[r]], x -> List( x, y -> (coeffs_alpha[s_alpha[l]] * coeffs_gamma[s_gamma[r]]) * y ) ) ) ) ) );

            return MorphismConstructor( RangeCategoryOfHomomorphismStructure( cat ),
                          s,
                          HomalgMatrixListList( mat, RankOfObject( s ), RankOfObject( r ), CommutativeRingOfLinearCategory( cat ) ),
                          r );

        fi;
        
    end );
    
    ##
    AddInterpretMorphismAsMorphismFromDistinguishedObjectToHomomorphismStructure( cat,
      
      function ( cat, alpha )
        local dim;
        
        dim := EnhancedDataTables( cat )[19][ObjectIndex( Range( alpha ) )][ObjectIndex( Source( alpha ) )];
        
        return MorphismConstructor( RangeCategoryOfHomomorphismStructure( cat ),
                            DistinguishedObjectOfHomomorphismStructure( cat ),
                            HomalgMatrixListList( [ MorphismCoefficients( alpha ) ], 1, dim, CommutativeRingOfLinearCategory( cat ) ),
                            ObjectConstructor( RangeCategoryOfHomomorphismStructure( cat ), dim ) );
    end );
    
    #
    AddInterpretMorphismAsMorphismFromDistinguishedObjectToHomomorphismStructureWithGivenObjects( cat,
      
      function ( cat, distinguished_object, alpha, r )
        
        return MorphismConstructor( RangeCategoryOfHomomorphismStructure( cat ),
                          distinguished_object,
                          HomalgMatrixListList( [ MorphismCoefficients( alpha ) ], 1, RankOfObject( r ), CommutativeRingOfLinearCategory( cat ) ),
                          r );
        
    end );
    
    #
    AddInterpretMorphismFromDistinguishedObjectToHomomorphismStructureAsMorphism( cat,
      
      function ( cat, obj_1, obj_2, eta )
        
        return MorphismConstructor( cat, obj_1, EntriesOfHomalgMatrixAsListList( UnderlyingMatrix( eta ) )[1], obj_2 );
        
    end );
    
    ## α:i->j, β:j->k
    ## α•β = ν⁻¹(ν(α•β)) = ν⁻¹(ν(α•id_j•β)) = ν⁻¹(ν(id_j)•H(α,β))
    ##
    AddPreCompose( cat,
      
      function ( cat, alpha, beta )
        
        return InterpretMorphismFromDistinguishedObjectToHomomorphismStructureAsMorphism( cat, Source( alpha ), Range( beta ),
                                  PreCompose( RangeCategoryOfHomomorphismStructure( cat ),
                                    InterpretMorphismAsMorphismFromDistinguishedObjectToHomomorphismStructure( cat, IdentityMorphism( cat, Range( alpha ) ) ),
                                    HomomorphismStructureOnMorphisms( cat, alpha, beta ) ) );
        
    end );
    
    ## Random Methods
    
    ##
    AddRandomObjectByInteger( cat,
      
      function ( cat, i )
        
        return Random( SetOfObjects( cat ) );
        
    end );
    
    ##
    AddRandomMorphismWithFixedSourceByInteger( cat,
      
      function ( cat, obj, n )
        local ring, s, indices, r, basis;
        
        ring := CommutativeRingOfLinearCategory( cat );
        
        s := ObjectIndex( obj );
        
        indices := Shuffle( [ 1 .. EnhancedDataTables( cat )[2] ] );
        
        r := PositionProperty( indices, r -> EnhancedDataTables( cat )[19][r][s] <> 0 );
        
        basis := SetOfBasesOfExternalHomsLazyHList( cat )[indices[r]][s];
        
        return SumOfMorphisms( cat, obj, List( [ 0 .. AbsInt( n ) ], i -> Random( ring ) * Random( basis ) ), SetOfObjects( cat )[indices[r]] );
        
    end );
    
    ##
    AddRandomMorphismWithFixedRangeByInteger( cat,
      
      function ( cat, obj, n )
        local ring, r, indices, s, basis;
        
        ring := CommutativeRingOfLinearCategory( cat );
        
        r := ObjectIndex( obj );
        
        indices := Shuffle( [ 1 .. EnhancedDataTables( cat )[2] ] );
        
        s := PositionProperty( indices, s -> EnhancedDataTables( cat )[19][r][s] <> 0 );
        
        basis := SetOfBasesOfExternalHomsLazyHList( cat )[r][indices[s]];
        
        return SumOfMorphisms( cat, SetOfObjects( cat )[indices[s]], List( [ 0 .. AbsInt( n ) ], i -> Random( ring ) * Random( basis ) ), obj );
        
    end );
    
    ##
    AddRandomMorphismWithFixedSourceAndRangeByInteger( cat,
      
      function ( cat, s, r, n )
        local ring, morphisms;
        
        ring := CommutativeRingOfLinearCategory( cat );
        
        morphisms := Concatenation( [ ZeroMorphism( cat, s, r ) ], SetOfBasesOfExternalHomsLazyHList( cat )[ObjectIndex( r )][ObjectIndex( s )] );
        
        return SumOfMorphisms( cat, s, List( [ 0 .. AbsInt( n ) ], i -> Random( ring ) * Random( morphisms ) ), r );
        
    end );
    
    if eager then
        List( ListOfValues( SetOfBasesOfExternalHomsLazyHList( cat ) ), ListOfValues );
    fi;
    
    Finalize( cat );
    
    return cat;
    
end );

##
InstallMethod( SetOfObjects,
          [ IsAlgebroidFromDataTables ],
  
  B -> List( [ 1 .. EnhancedDataTables( B )[2] ], index -> CreateCapCategoryObjectWithAttributes( B, ObjectIndex, index ) )
);

##
InstallMethod( SetOfGeneratingMorphisms,
          [ IsAlgebroidFromDataTables ],
  
  B -> ListN( EnhancedDataTables( B )[9], EnhancedDataTables( B )[10], EnhancedDataTables( B )[11],
            { g, i, j } -> SetOfBasesOfExternalHomsLazyHList( B )[j][i][Position( EnhancedDataTables( B )[16][j][i], g )] )
);

##
InstallMethod( SetOfBasesOfExternalHoms,
          [ IsAlgebroidFromDataTables ],
  
  B -> List( ListOfValues( SetOfBasesOfExternalHomsLazyHList( B ) ), ListOfValues )
);

##
InstallMethod( PowerOfArrowIdealOp,
          [ IsAlgebroidFromDataTables, IsInt ],
  function ( B, n )
    
    if n = 0 then
        return Filtered( List( SetOfObjects( B ), o -> IdentityMorphism( B, o ) ), h -> not IsZero( h ) );
    else
        return Filtered( Concatenation( List( PowerOfArrowIdeal( B, n - 1 ),
                f -> List( Filtered( SetOfGeneratingMorphisms( B ), g -> ObjectIndex( Range( f ) ) = ObjectIndex( Source( g ) ) ),
                  g -> PreCompose( B, f, g ) ) ) ),
                    h -> not IsZeroForMorphisms( B, h ) );
    fi;
    
end );

##
InstallMethod( IsAdmissibleAlgebroid,
          [ IsAlgebroidFromDataTables ],
  
  function ( B )
    local dim, i;
    
    if HasOppositeAlgebroid( B ) and HasIsAdmissibleAlgebroid( OppositeAlgebroid( B ) ) then
        
        return IsAdmissibleAlgebroid( OppositeAlgebroid( B ) );
        
    fi;
    
    dim :=
      AsZFunction(
        function ( i )
          local C, objs;
          
          C := QuotientCategory( B, PowerOfArrowIdeal( B, i ) : overhead := false );
          
          objs := List( SetOfObjects( B ), u -> ObjectConstructor( C, u ) );
          
          return Sum( List( objs, u -> Sum( List( objs, v -> RankOfObject( HomomorphismStructureOnObjects( C, u, v ) ) ) ) ) );
          
        end );
    
    i := 2;
    
    if dim[i] <> Sum( EnhancedDataTables( B ){[2,6]} ) then
        return false;
    fi;
    
    repeat i := i + 1; until dim[i] = dim[i-1];
    
    return dim[i] = EnhancedDataTables( B )[12];
    
end );

##############################
#
# Objects & Morphisms
#
##############################

##
InstallMethod( CreateObject,
          [ IsAlgebroidFromDataTables, IsInt ],
  
  { cat, index } -> SetOfObjects( cat )[index]
);

##
InstallOtherMethod( \[\],
          [ IsAlgebroidFromDataTables, IsInt ],
  
  { cat, index } -> SetOfObjects( cat )[index]
);

##
InstallMethod( CreateMorphism,
          [ IsAlgebroidFromDataTables, IsObjectInAlgebroidFromDataTables, IsDenseList, IsObjectInAlgebroidFromDataTables ],
  
  MorphismConstructor
);

##
InstallOtherMethod( CreateMorphism,
          [ IsObjectInAlgebroidFromDataTables, IsDenseList, IsObjectInAlgebroidFromDataTables ],
  
  MorphismConstructor
);

##
InstallOtherMethod( CreateMorphism,
          [ IsAlgebroidFromDataTables, IsObjectInAlgebroidFromDataTables, IsDenseList, IsDenseList, IsObjectInAlgebroidFromDataTables ],
  
  function ( cat, S, coeffs, support, R )
    local mor;
    
    mor := MorphismConstructor( cat, S, coeffs, R );
    
    SetMorphismSupport( mor, support );
    
    return mor;
    
end );

##
InstallMethod( MorphismSupport,
          [ IsMorphismInAlgebroidFromDataTables ],
  
  alpha -> PositionsProperty( MorphismCoefficients( alpha ), c -> not IsZero( c ) )
);

##
InstallMethod( DecompositionOfMorphismInAlgebroid,
          [ IsMorphismInAlgebroidFromDataTables ],
  
  function ( mor )
    local B, indices_objs, indices_gmors, source, range, supp, coeffs, precomps;
    
    B := CapCategory( mor );
    indices_objs := EnhancedDataTables( B )[5];
    indices_gmors := EnhancedDataTables( B )[9];
    
    source := ObjectIndex( Source( mor ) );
    range := ObjectIndex( Range( mor ) );
    
    supp := MorphismSupport( mor );
    coeffs := MorphismCoefficients( mor ){ supp };
    precomps := List( EnhancedDataTables( B )[16][range][source]{supp},
                        function ( j )
                          local m;
                          m := EnhancedDataTables( B )[13][j];
                          if Length( m ) = 1 and m[1] < 0 then
                              return [ IdentityMorphism( SetOfObjects( B )[-m[1]] ) ];
                          else
                              return List( m, index -> SetOfGeneratingMorphisms( B )[index] );
                          fi;
                        end );
    
    return ListN( coeffs, precomps, { c, l } -> [ c, l ] );
    
end );

####################################
#
# Opposite Algebroid
#
####################################

##
InstallOtherMethod( OppositeAlgebroid,
          [ IsAlgebroidFromDataTables ],
  
  function ( cat )
    local data, data_op, cat_op;
    
    data := EnhancedDataTables( cat );
    
    data_op := rec();
    
    data_op!.coefficients_ring := data[1];
    
    data_op!.nr_objs := data[2];
    
    data_op!.nr_bases_elms := data[12];
    
    data_op!.labels_objs := data[3];
    
    data_op!.indices_objs := data[5];
    
    data_op!.nr_gmors := data[6];
    
    data_op!.labels_gmors := data[7];
    
    data_op!.indices_gmors := data[9];
    
    data_op!.sources_gmors := data[11];
    
    data_op!.ranges_gmors := data[10];
    
    data_op!.bases_elms_comps := List( data[13], Reversed );
    
    data_op!.indices_of_bases_elms := TransposedMat( data[16] );
    
    data_op!.hom_structure_objs_gmors := data[18];
    
    data_op!.hom_structure_gmors_objs := data[17];
    
    data_op!.hom_structure_ranks := TransposedMat( data[19] );
    
    data_op!.hom_structure_on_bases_elms :=
        List( [ 1 .. data_op.nr_objs ],
          i -> List( [ 1 .. data_op.nr_objs ],
            j -> List( [ 1 .. data_op.nr_objs ],
              p -> List( [ 1 .. data_op.nr_objs ],
                q -> List( [ 1 .. data_op.hom_structure_ranks[j][i] ],
                  l -> List( [ 1 .. data_op.hom_structure_ranks[q][p] ],
                    r -> data[20][q][p][j][i][r][l] ) ) ) ) ) );
    
    cat_op := AlgebroidFromDataTables( data_op : range_of_HomStructure := RangeCategoryOfHomomorphismStructure( cat ) );
    
    if HasIsAdmissibleAlgebroid( cat ) then
        SetIsAdmissibleAlgebroid( cat_op, IsAdmissibleAlgebroid( cat ) );
    fi;
    
    return cat_op;
    
end );

####################################
#
# Additive Closure Of Algebroids
#
####################################

InstallGlobalFunction( ADD_FUNCTIONS_FOR_AdditiveClosureOfAlgebroidFromDataTables,
    function ( cat )
      
      AddWeakKernelEmbedding( cat,
        
        function ( cat, alpha )
          local objs, tau, D, S;
          
          objs := List( SetOfObjects( UnderlyingCategory( cat ) ), o -> ObjectConstructor( cat, [ o ] ) );
          
          tau := Concatenation( List( objs, o -> Concatenation( BasisOfSolutionsOfHomogeneousLinearSystemInLinearCategory( cat, [ [  IdentityMorphism( cat, o ) ] ], [ [ alpha ] ] ) ) ) );
          
          D := List( tau, Source );
          
          S := DirectSum( cat, D );
          
          return UniversalMorphismFromDirectSumWithGivenDirectSum( cat, D, Source( alpha ), tau, S );
          
      end );
      
      AddWeakCokernelProjection( cat,
        
        function ( cat, alpha )
          local objs, tau, D, S;
          
          objs := List( SetOfObjects( UnderlyingCategory( cat ) ), o -> ObjectConstructor( cat, [ o ] ) );
          
          tau := Concatenation( List( objs, o -> Concatenation( BasisOfSolutionsOfHomogeneousLinearSystemInLinearCategory( cat, [ [ alpha ] ], [ [  IdentityMorphism( cat, o ) ] ]  ) ) ) );
          
          D := List( tau, Range );
          
          S := DirectSum( cat, D );
          
          return UniversalMorphismIntoDirectSumWithGivenDirectSum( cat, D, Range( alpha ), tau, S );
          
      end );
      
      ADD_FUNCTIONS_FOR_AdditiveClosureOfAlgebroidFromDataTablesPrecompiled( cat );
      
end );

####################################
#
# Tensor Product Of Algebroids
#
####################################

##
InstallMethod( \*,
          [ IsAlgebroidFromDataTables, IsAlgebroidFromDataTables ],
  
  { B_1, B_2 } -> TensorProductOfAlgebroids( B_1, B_2 : eager := false )
);

##
InstallMethodWithCache( TensorProductOfAlgebroids,
          [ IsAlgebroidFromDataTables, IsAlgebroidFromDataTables ],
  
  function ( B_1, B_2 )
    local data_1, data_2, data;
    
    data_1 := EnhancedDataTables( B_1 );
    data_2 := EnhancedDataTables( B_2 );
    
    if not IsIdenticalObj( data_1[1], data_2[1] ) then
        Error( "the algebroids must be linear over the same commutative ring!" );
    fi;
    
    data := rec();
    
    data!.coefficients_ring := data_1[1];
    
    data!.nr_objs := data_1[2] * data_2[2];
    
    data!.nr_bases_elms := data_1[12] * data_2[12];
    
    data!.indices_objs := _ConcatenationLazyHLists_( LazyHList( data_1[5], l -> LazyHList( data_2[5], r -> (l-1) * data_2[12] + r ) ) );
    
    data!.labels_objs  := _ConcatenationLazyHLists_( LazyHList( data_1[3], l -> LazyHList( data_2[3], r -> Concatenation( l, "⊗", r ) ) ) );
    
    data!.latex_strings_objs := _ConcatenationLazyHLists_( LazyHList( data_1[4], l -> LazyHList( data_2[4], r -> Concatenation( l, "\\otimes ", r ) ) ) );
    
    data!.nr_gmors := data_1[2] * data_2[6] + data_1[6] * data_2[2];
    
    data!.indices_gmors :=
        _ConcatenationLazyHLists_(
            [ _ConcatenationLazyHLists_( LazyHList( data_1[5], l -> LazyHList( data_2[9], r -> (l-1) * data_2[12] + r ) ) ),
              _ConcatenationLazyHLists_( LazyHList( data_1[9], l -> LazyHList( data_2[5], r -> (l-1) * data_2[12] + r ) ) ) ] );
    
    data!.labels_gmors :=
        _ConcatenationLazyHLists_(
            [ _ConcatenationLazyHLists_( LazyHList( data_1[14]{ListOfValues(data_1[5])}, l -> LazyHList( data_2[7], r -> Concatenation( l, "⊗", r ) ) ) ),
              _ConcatenationLazyHLists_( LazyHList( data_1[7], l -> LazyHList( data_2[14]{ListOfValues(data_2[5])}, r -> Concatenation( l, "⊗", r ) ) ) ) ] );
    
    data!.latex_strings_gmors :=
        _ConcatenationLazyHLists_(
            [ _ConcatenationLazyHLists_( LazyHList( data_1[15]{ListOfValues(data_1[5])}, l -> LazyHList( data_2[8], r -> Concatenation( l, "\\otimes ", r ) ) ) ),
              _ConcatenationLazyHLists_( LazyHList( data_1[8], l -> LazyHList( data_2[15]{ListOfValues(data_2[5])}, r -> Concatenation( l, "\\otimes ", r ) ) ) ) ] );

    data!.sources_gmors :=
        _ConcatenationLazyHLists_(
            [ _ConcatenationLazyHLists_( LazyHList( [ 1 .. data_1[2] ], l -> LazyHList( data_2[10], r -> (l-1) * data_2[2] + r ) ) ),
              _ConcatenationLazyHLists_( LazyHList( data_1[10], l -> LazyHList( [ 1 .. data_2[2] ], r -> (l-1) * data_2[2] + r ) ) ) ] );
    
    data!.ranges_gmors :=
        _ConcatenationLazyHLists_(
            [ _ConcatenationLazyHLists_( LazyHList( [ 1 .. data_1[2] ], l -> LazyHList( data_2[11], r -> (l-1) * data_2[2] + r ) ) ),
              _ConcatenationLazyHLists_( LazyHList( data_1[11], l -> LazyHList( [ 1 .. data_2[2] ], r -> (l-1) * data_2[2] + r ) ) ) ] );
    
    data!.hom_structure_objs_gmors :=
        _ConcatenationLazyHLists_(
            LazyHList( [ 1 .. data_1[2] ],
                i -> LazyHList( [ 1 .. data_2[2] ],
                    p -> _ConcatenationLazyHLists_(
                              [ _ConcatenationLazyHLists_(
                                  LazyHList( [ 1 .. data_1[2] ],
                                    j -> LazyHList( [ 1 .. Length( data_2[9] ) ],
                                        index_2 -> _KroneckerProduct_(
                                                        data_1[19][j][i],
                                                        IdentityMat( data_1[19][j][i], data.coefficients_ring ),
                                                        data_1[19][j][i],
                                                        data_2[19][data_2[10][index_2]][p],
                                                        data_2[17][p][index_2],
                                                        data_2[19][data_2[11][index_2]][p] ) ) ) ),
                              _ConcatenationLazyHLists_(
                                  LazyHList( [ 1 .. Length( data_1[9] ) ],
                                    index_1 -> LazyHList( [ 1 .. data_2[2] ],
                                              q -> _KroneckerProduct_(
                                                        data_1[19][data_1[10][index_1]][i],
                                                        data_1[17][i][index_1],
                                                        data_1[19][data_1[11][index_1]][i],
                                                        data_2[19][q][p],
                                                        IdentityMat( data_2[19][q][p], data.coefficients_ring ),
                                                        data_2[19][q][p] ) ) ) ) ] ) ) ) );
    
    data!.hom_structure_gmors_objs :=
        _ConcatenationLazyHLists_(
            LazyHList( [ 1 .. data_1[2] ],
                i -> LazyHList( [ 1 .. data_2[2] ],
                    p -> _ConcatenationLazyHLists_(
                              [ _ConcatenationLazyHLists_(
                                  LazyHList( [ 1 .. data_1[2] ],
                                    j -> LazyHList( [ 1 .. Length( data_2[9] ) ],
                                        index_2 -> _KroneckerProduct_(
                                                        data_1[19][i][j],
                                                        IdentityMat( data_1[19][i][j], data.coefficients_ring ),
                                                        data_1[19][i][j],
                                                        data_2[19][p][data_2[11][index_2]],
                                                        data_2[18][p][index_2],
                                                        data_2[19][p][data_2[10][index_2]] ) ) ) ),
                                _ConcatenationLazyHLists_(
                                  LazyHList( [ 1 .. Length( data_1[9] ) ],
                                    index_1 -> LazyHList( [ 1 .. data_2[2] ],
                                              q -> _KroneckerProduct_(
                                                        data_1[19][i][data_1[11][index_1]],
                                                        data_1[18][i][index_1],
                                                        data_1[19][i][data_1[10][index_1]],
                                                        data_2[19][p][q],
                                                        IdentityMat( data_2[19][p][q], data.coefficients_ring ),
                                                        data_2[19][p][q] ) ) ) ) ] ) ) ) );
    
    data!.bases_elms_comps :=
        _ConcatenationLazyHLists_(
            LazyHList( data_1[13],
              l -> LazyHList( data_2[13],
                      function ( r )
                        local index_l, index_r, l_is_object, r_is_object;
                        
                        if Length( l ) = 1 and l[1] < 0 then
                          index_l := -l[1];
                          l_is_object := true;
                        else
                          index_l := data_1[11][l[Length( l )]];
                          l_is_object := false;
                        fi;
                        
                        if Length( r ) = 1 and r[1] < 0 then
                          index_r := -r[1];
                          r_is_object := true;
                        else
                          index_r := data_2[10][r[1]];
                          r_is_object := false;
                        fi;
                        
                        if l_is_object and r_is_object then
                          return [ -((index_l-1) * data_2[2] + index_r) ];
                        elif r_is_object then
                          return List( l, i -> data_1[2] * data_2[6] + (i-1) * data_2[2] + index_r );
                        elif l_is_object then
                          return List( r, j -> (index_l-1) * data_2[6] + j );
                        else
                          return Concatenation(
                                    List( l, i -> data_1[2] * data_2[6] + (i-1) * data_2[2] + index_r ),
                                    List( r, j -> (index_l-1) * data_2[6] + j ) );
                        fi;
                        
                      end ) ) );
    
    data.labels_of_bases_elms :=
        _ConcatenationLazyHLists_( LazyHList( data_1[14], l -> LazyHList( data_2[14], r -> Concatenation( l, "⊗", r ) ) ) );
    
    data.latex_strings_of_bases_elms :=
        _ConcatenationLazyHLists_( LazyHList( data_1[15], l -> LazyHList( data_2[15], r -> Concatenation( l, "\\otimes ", r ) ) ) );
    
    data!.indices_of_bases_elms :=
        _ConcatenationLazyHLists_( LazyHList( [ 1 .. data_1[2] ], i -> LazyHList( [ 1 .. data_2[2] ],
            function ( p )
                return Concatenation( List( [ 1 .. data_1[2] ], j -> List( [ 1 .. data_2[2] ],
                    function ( q )
                        return Concatenation( List( data_1[16][i][j], l -> List( data_2[16][p][q],
                                  r -> (l-1) * data_2[12] + r ) ) );
                    end ) ) );
            end ) ) );
    
    data!.colors := data_1[22];
    
    return AlgebroidFromDataTables( data : range_of_HomStructure := RangeCategoryOfHomomorphismStructure( B_1 ) );
    
end );

##
InstallMethod( ElementaryTensor,
        [ IsObjectInAlgebroidFromDataTables, IsObjectInAlgebroidFromDataTables, IsAlgebroidFromDataTables ],
  
  { obj_1, obj_2, B1_x_B2 } -> SetOfObjects( B1_x_B2 )[( ObjectIndex( obj_1 ) - 1 ) * Length( SetOfObjects( CapCategory( obj_2 ) ) ) + ObjectIndex( obj_2 )]
);

##
InstallMethod( ElementaryTensor,
        [ IsMorphismInAlgebroidFromDataTables, IsMorphismInAlgebroidFromDataTables, IsAlgebroidFromDataTables ],
  
  { mor_1, mor_2, B1_x_B2 } -> CreateMorphism( B1_x_B2,
                                    ElementaryTensor( Source( mor_1 ), Source( mor_2 ), B1_x_B2 ),
                                    Concatenation( List( MorphismCoefficients( mor_1 ), c_1 -> List( MorphismCoefficients( mor_2 ), c_2 -> c_1 * c_2 ) ) ),
                                    Concatenation( List( MorphismSupport( mor_1 ), l -> List( MorphismSupport( mor_2 ), r -> (l-1) * Length( MorphismCoefficients( mor_2 ) ) + r ) ) ),
                                    ElementaryTensor( Range( mor_1 ), Range( mor_2 ), B1_x_B2 ) )
);

##
InstallOtherMethod( ElementaryTensor,
        [ IsObjectInAlgebroidFromDataTables, IsObjectInAlgebroidFromDataTables ],
  
  { obj_1, obj_2 } -> ElementaryTensor( obj_1, obj_2, TensorProductOfAlgebroids( CapCategory( obj_1 ), CapCategory( obj_2 ) ) )
);

##
InstallOtherMethod( ElementaryTensor,
        [ IsMorphismInAlgebroidFromDataTables, IsMorphismInAlgebroidFromDataTables ],
  
  { mor_1, mor_2 } -> ElementaryTensor( mor_1, mor_2, TensorProductOfAlgebroids( CapCategory( mor_1 ), CapCategory( mor_2 ) ) )
);

##
InstallOtherMethod( ElementaryTensor,
        [ IsObjectInAlgebroidFromDataTables, IsMorphismInAlgebroidFromDataTables ],
  
  { obj_1, mor_2 } -> ElementaryTensor( IdentityMorphism( obj_1 ), mor_2 )
);

##
InstallOtherMethod( ElementaryTensor,
        [ IsMorphismInAlgebroidFromDataTables, IsObjectInAlgebroidFromDataTables ],
  
  { mor_1, obj_2 } -> ElementaryTensor( mor_1, IdentityMorphism( obj_2 ) )
);

####################################
#
# Methods For Attributes:
#
####################################

##
InstallMethod( AssignSetOfObjects,
        [ IsAlgebroidFromDataTables, IsString ],
  
  function ( B, label )
    local names, func;
    
    names := EnhancedDataTables( B )[3];
    
    if label = "" and ForAny( names, name -> Int( name ) <> fail ) then
        Error( "the <label> passed to 'AssignSetOfObjects' must be a non-empty string!\n" );
    fi;
    
    func :=
      function ( name, o )
        
        name := Concatenation( label, ReplacedString( name, "-", "m" ) );
        MakeReadWriteGlobal( name );
        DeclareSynonym( name, o );
        return true;
        
    end;
    
    ListN( names, SetOfObjects( B ), func );
    
end );

##
InstallOtherMethod( AssignSetOfObjects,
        [ IsAlgebroidFromDataTables ],
  
  function ( B )
    
    AssignSetOfObjects( B, "" );
    
end );

##
InstallMethod( AssignSetOfGeneratingMorphisms,
        [ IsAlgebroidFromDataTables, IsString ],
  
  function ( B, label )
    local names, morphisms, func;
    
    names := EnhancedDataTables( B )[7];
    
    if label = "" and ForAny( names, name -> Int( name ) <> fail ) then
        Error( "the <label> passed to 'AssignSetOfGeneratingMorphisms' must be a non-empty string!\n" );
    fi;
    
    morphisms := SetOfGeneratingMorphisms( B );
    
    func :=
      function ( name, m )
        
        name := Concatenation( label, ReplacedString( name, "-", "m" ) );
        MakeReadWriteGlobal( name );
        DeclareSynonym( name, m );
        return true;
        
    end;
    
    ListN( names, morphisms, func );
    
end );

##
InstallOtherMethod( AssignSetOfGeneratingMorphisms,
        [ IsAlgebroidFromDataTables ],
  
  function ( B )
    
    AssignSetOfGeneratingMorphisms( B, "" );
    
end );

##
InstallMethod( \.,
        "for an algebroid from data table and a positive integer",
        [ IsAlgebroidFromDataTables, IsPosInt ],
  
  function ( B, string_as_int )
    local name, p, comp, source, range;
    
    name := NameRNam( string_as_int );
    
    p := Position( EnhancedDataTables( B )[3], name );
    
    if p <> fail then
        return SetOfObjects( B )[p];
    fi;
    
    p := PositionProperty( EnhancedDataTables( B )[14], m -> ReplacedString( m, "•", "" ) = ReplacedString( name, "•", "" ) );
    
    if p <> fail then
        
        comp := EnhancedDataTables(B)[13][p];
        
        if Length( comp ) = 1 and comp[1] < 0 then
            source := -comp[1];
            range := -comp[1];
        else
            source := EnhancedDataTables(B)[10][comp[1]];
            range := EnhancedDataTables(B)[11][comp[Length(comp)]];
        fi;
        
        p := Position( EnhancedDataTables(B)[16][range][source], p );
        
        return SetOfBasesOfExternalHomsLazyHList( B )[range][source][p];
        
    fi;
    
    Error( "the given string ", name, " is not a label of an object or morphism in the category ", Name( B ), "\n" );
    
end );

##
InstallOtherMethod( CapFunctor,
        "for an algebroid from data tables, two lists, a CAP Category",
        [ IsAlgebroidFromDataTables, IsList, IsList, IsCapCategory ],

  function( B, images_of_objects, images_of_generating_morphisms, C )
    local F;
    
    F := CapFunctor( Concatenation( "Functor from ", Name( B ), " -> ", Name( C ) ), B, C );
    
    AddObjectFunction( F,
      function ( obj )
        
        return images_of_objects[ObjectIndex( obj )];
        
    end );
    
    AddMorphismFunction( F,
      function ( s, mor, r )
        
        return SumOfMorphisms( C,
                  s,
                  List( DecompositionOfMorphismInAlgebroid( mor ),
                            p -> p[1] * PreComposeList( C,
                                            s,
                                            List( p[2],
                                              function ( w )
                                                if IsEqualToIdentityMorphism( w ) then
                                                      return IdentityMorphism( C, images_of_objects[ObjectIndex( Source( w ) )] );
                                                else
                                                      return images_of_generating_morphisms[Position( SetOfGeneratingMorphisms( B ), w )];
                                                fi;
                                              end ),
                                            r ) ),
                  r );
        
    end );
    
    return F;
    
end );

##
InstallOtherMethod( DefiningTripleOfUnderlyingQuiver,
        [ IsAlgebroidFromDataTables ],

  function ( B )
    local nr_objs, nr_gmors, sources, ranges;

    nr_objs := EnhancedDataTables( B )[2];
    nr_gmors := EnhancedDataTables( B )[6];
    sources := EnhancedDataTables( B )[10];
    ranges := EnhancedDataTables( B )[11];

    return NTuple( 3, nr_objs, nr_gmors, List( [ 1 .. nr_gmors ], i -> Pair( sources[i]-1, ranges[i]-1 ) ) );

end );

########################################
#
# Enhancing PreSheaves( B )
#
#######################################

##
InstallMethod( PreSheaves,
          [ IsAlgebroidFromDataTables ],
  
  function ( B )
    local bool, PSh;
    
    bool := CAP_INTERNAL_RETURN_OPTION_OR_DEFAULT( "enhance_presheaves_category_of_linear_algebroid_from_data", true );
    
    if bool then
        
        PSh := PreSheaves( B : enhance_presheaves_category_of_linear_algebroid_from_data := false, FinalizeCategory := false );
        
        if not IsFinalized( PSh ) then
          
          AddIsEqualForMorphisms( PSh,
            function ( PSh, eta1, eta2 )
              local B, C;
              
              B := Source( PSh );
              C := Range( PSh );
              
              return ForAll( SetOfObjects( B ), o -> IsEqualForMorphisms( C, eta1( o ), eta2( o ) ) );
              
          end );
          
          PSh!.is_computable := true;
          
          AddIsCongruentForMorphisms( PSh,
            function ( PSh, eta1, eta2 )
              local B, C;
              
              B := Source( PSh );
              C := Range( PSh );
              
              return ForAll( SetOfObjects( B ), o -> IsCongruentForMorphisms( C, eta1( o ), eta2( o ) ) );
              
          end );
          
          AddIsEqualForObjects( PSh,
            function ( PSh, obj1, obj2 )
              local B, C;
              
              B := Source( PSh );
              C := Range( PSh );
              
              return ForAll( SetOfObjects( B ), o -> IsEqualForObjects( C, obj1( o ), obj2( o ) ) )
                        and ForAll( SetOfGeneratingMorphisms( B ), m -> IsEqualForMorphisms( C, obj1( m ), obj2( m ) ) );
              
          end );
          
          AddIsWellDefinedForObjects( PSh,
            function ( PSh, obj )
              local B, C, gmors, pairs;
              
              B := Source( PSh );
              C := Range( PSh );
              
              gmors := SetOfGeneratingMorphisms( B );
              pairs := Concatenation( ListOfValues( EnhancedDataTables( B )[21] ) );
              
              return ForAll( pairs, p -> IsCongruentForMorphisms( C, obj( PreCompose( B, gmors[p[1]], gmors[p[2]] ) ), PostCompose( C, obj( gmors[p[1]] ), obj( gmors[p[2]] ) ) ) );
              
          end );
          
          AddIsWellDefinedForMorphisms( PSh,
            function ( PSh, mor )
              local B, C, gmors;
              
              B := Source( PSh );
              C := Range( PSh );
              
              gmors := SetOfGeneratingMorphisms( B );
              
              return IsWellDefinedForObjects( PSh, Source( mor ) )
                    and IsWellDefinedForObjects( PSh, Range( mor ) )
                    and ForAll( gmors, g -> IsCongruentForMorphisms( C, PreCompose( C,  Source( mor )( g ), mor( Source( g ) ) ), PreCompose( C, mor( Range( g ) ), Range( mor )( g ) ) ) );
              
          end );
          
          Finalize( PSh );
          
        fi;
        
        return PSh;
        
    else
        
        TryNextMethod( );
        
    fi;
    
end );

#
# Let k be a commutative ring
# Let B a k-algebroid defined by data-tables, k-rows and PSh := PreSheaves(B, k-rows).
# Let Y: B -> PSh be the Yoneda embedding functor.
# For two objects obj ∈ B and F ∈ PSh we have Hom_{k-rows}(1,F(obj)) ≃ F(obj) ≃ Hom_PSh(Y(obj), F).
#
InstallOtherMethod( MorphismFromRepresentableFunctor,
          [ IsPreSheafCategory, IsObjectInAlgebroidFromDataTables, IsObjectInPreSheafCategory, IsObjectInPreSheafCategory, IsCategoryOfRowsMorphism ],
  
  function ( PSh, obj, Y_obj, F, ell )
    local B, C, func_of_presheaf_morphism;
    
    B := Source( PSh );
    C := Range( PSh );
    
    if not IsIdenticalObj( B, CapCategory( obj ) ) then
        Error( "the argument <obj> passed to 'MorphismFromRepresentableFunctor' must be an object in ", Name( B ) );
    fi;
    
    if not IsIdenticalObj( C, CapCategory( ell ) ) then
        Error( "the argument <ell> passed to 'MorphismFromRepresentableFunctor' must be a morphism in ", Name( C ) );
    fi;
    
    func_of_presheaf_morphism :=
      function ( Y_obj_o, o, F_o )
        local tau, summands;
        
        tau := List( BasisOfExternalHom( B, o, obj ), m -> PreCompose( C, ell, F(m) ) );
        
        Assert( 0, RankOfObject( Y_obj_o ) = Length( tau ) );
        
        summands := ListWithIdenticalEntries( RankOfObject( Y_obj_o ), Source( ell ) );
        
        return UniversalMorphismFromDirectSumWithGivenDirectSum( C, summands, F_o, tau, Y_obj_o );
        
  end;
  
  return MorphismConstructor( PSh, Y_obj, func_of_presheaf_morphism, F );
  
end );

#                                                       op
#  Interpret an algebroid B as an object in PreSheaves(B ⊗ B, k-rows).
#                    _  _     _     op
#  For two morphims: g: X --> Y in B   &  f: U --> V in B
#                                    op
#  we send the following diagram in B ⊗ B
#                     _
#          _          X⊗f         _
#          X⊗U  ---------------≻  X⊗V
#      _    |                      |  _
#      g⊗U  |                      |  g⊗V
#           |         _            |
#          _⋎         Y⊗f         _⋎
#          Y⊗U  ---------------≻  Y⊗V
#
#  to the diagram in k-rows:
#
#                     hom(f,X)
#         hom(U,X)  ≺----------  hom(V,X)
#           ⋏                      ⋏
#           |                      |
# hom(U,g)  |                      |  hom(V,g)
#           |         hom(f,Y)     |
#         hom(U,Y)  ≺----------  hom(V,Y)
#
##
InstallMethod( AlgebroidAsObjectInPreSheavesCategoryData,
          [ IsAlgebroidFromDataTables ],
  
  function ( B )
    local nr_objs, nr_gmors, images_of_objs, images_of_gmorphisms;
    
    nr_objs := EnhancedDataTables( B )[2];
    nr_gmors := EnhancedDataTables( B )[6];
    
    images_of_objs :=
      _ConcatenationLazyHLists_( LazyHList( [ 1 .. nr_objs ],
          l -> LazyHList( [ 1 .. nr_objs ],
            r -> HomomorphismStructureOnObjects( B, SetOfObjects( B )[r], SetOfObjects( B )[l] ) ) ) );
    
    images_of_gmorphisms :=
                _ConcatenationLazyHLists_(
                     [ _ConcatenationLazyHLists_( LazyHList( [ 1 .. nr_objs ], l -> LazyHList( [ 1 .. nr_gmors ],
                        r -> HomomorphismStructureOnMorphisms( B, SetOfGeneratingMorphisms( B )[r], IdentityMorphism( SetOfObjects( B )[l] ) ) ) ) ),
                       _ConcatenationLazyHLists_( LazyHList( [ 1 .. nr_gmors ], l -> LazyHList( [ 1 .. nr_objs ],
                        r -> HomomorphismStructureOnMorphisms( B, IdentityMorphism( SetOfObjects( B )[r] ), SetOfGeneratingMorphisms( B )[l] ) ) ) ) ] );
    
    return Pair( images_of_objs, images_of_gmorphisms );
    
end );

##
InstallMethod( AlgebroidAsObjectInPreSheavesCategory,
          [ IsAlgebroidFromDataTables ],
  
  function ( B )
    local nr_objs, nr_gmors, B_op, B_op_x_B, PSh, range_cat, presheaf_on_objs, presheaf_on_id_or_gmor, presheaf_on_mors;
    
    nr_objs := EnhancedDataTables( B )[2];
    nr_gmors := EnhancedDataTables( B )[6];
    
    B_op := OppositeAlgebroid( B );
    B_op_x_B := TensorProductOfAlgebroids( B_op, B );
    
    PSh := PreSheaves( B_op_x_B );
    range_cat := RangeCategoryOfHomomorphismStructure( B );
    
    Assert( 0, IsIdenticalObj( range_cat, Range( PSh ) ) );
    
    presheaf_on_objs := obj -> AlgebroidAsObjectInPreSheavesCategoryData( B )[1][ObjectIndex( obj )];
    
    presheaf_on_id_or_gmor :=
      function ( w )
        local index, datum, l, r;
        
        if IsEqualToIdentityMorphism( w ) then
              
              datum := ObjectIndex( Source( w ) );
              
              l := QuoInt( datum - 1, nr_objs ) + 1;
              r := RemInt( datum - 1, nr_objs ) + 1;
              
              return IdentityMorphism( HomomorphismStructureOnObjects( B, SetOfObjects( B )[r], SetOfObjects( B )[l] ) );
              
        else
              
              index := Position( SetOfGeneratingMorphisms( B_op_x_B ), w );
              
              return AlgebroidAsObjectInPreSheavesCategoryData( B )[2][index];
              
        fi;
        
    end;
    
    presheaf_on_mors :=
      {s, mor, r} -> SumOfMorphisms( range_cat,
                        s,
                        List( DecompositionOfMorphismInAlgebroid( mor ),
                                  p -> p[1] * PostComposeList( range_cat, List( p[2], presheaf_on_id_or_gmor ) ) ),
                        r );
    
    return ObjectConstructor( PSh, Pair( presheaf_on_objs, presheaf_on_mors ) );
    
end );

##
InstallMethod( AssociatedMorphismIntoAlgebroidAsObjectInPreSheavesCategory,
          [ IsMorphismInAlgebroidFromDataTables ],
  
  function ( m )
    local B, B_op, B_op_x_B, F, PSh, obj, Y_obj;
    
    B := CapCategory( m );
    B_op := OppositeAlgebroid( B );
    B_op_x_B := TensorProductOfAlgebroids( B_op, B );
    
    F := AlgebroidAsObjectInPreSheavesCategory( B );
    PSh := CapCategory( F );
    
    obj := ElementaryTensor( SetOfObjects( B_op )[ObjectIndex( Range( m ) )], Source( m ), B_op_x_B );
    
    Y_obj := YonedaEmbeddingOfSourceCategory( PSh )( obj );
    
    return MorphismFromRepresentableFunctor(
                        PSh,
                        obj,
                        Y_obj,
                        F,
                        InterpretMorphismAsMorphismFromDistinguishedObjectToHomomorphismStructure( B, m ) );
    
end );

##################################
#
# Algebroids By Two-Sided Ideals
#
##################################

##
InstallOtherMethod( QuotientCategory,
        [ IsAlgebroidFromDataTables, IsDenseList ],
  
  function ( B, ideal )
    local B_op, B_op_x_B, F, PSh, C, tau, pi, congruence_function, name, quotient_category, FinalizeCategory, range_of_HomStructure, ring;
    
    B_op := OppositeAlgebroid( B );
    B_op_x_B := TensorProductOfAlgebroids( B_op, B : eager := false );
    
    F := AlgebroidAsObjectInPreSheavesCategory( B );
    
    PSh := CapCategory( F );
    C := Range( PSh );
    
    tau := UniversalMorphismFromDirectSum( PSh, F, List( ideal, AssociatedMorphismIntoAlgebroidAsObjectInPreSheavesCategory ) );
    
    if HasIsAbelianCategory( C ) and IsAbelianCategory( C ) then
        
        pi := CokernelProjection( PSh, tau );
        
        congruence_function :=
          function ( m )
            local obj;
            
            obj := ElementaryTensor( SetOfObjects( B_op )[ObjectIndex( Range( m ) )], Source( m ), B_op_x_B );
            
            return IsZeroForMorphisms( C, PreCompose( C, AssociatedMorphismIntoAlgebroidAsObjectInPreSheavesCategory( m )( obj ), pi( obj ) ) );
            
        end;
        
    elif CanCompute( C, "IsLiftable" ) then
        
        congruence_function :=
          function ( m )
            local obj;
            
            obj := ElementaryTensor( SetOfObjects( B_op )[ObjectIndex( Range( m ) )], Source( m ), B_op_x_B );
            
            return IsLiftable( C, AssociatedMorphismIntoAlgebroidAsObjectInPreSheavesCategory( m )( obj ), tau( obj ) );
            
        end;
        
    else
        
        Error( "the operation 'IsLiftable' must be added to the range category of Hom-Structure!" );
        
    fi;
    
    name := Concatenation( "QuotientCategory( ", Name( B ), ", 2-sided ideal generated by ", String( Length( ideal ) ), " morphisms )" );
    
    if Length( ideal ) = 1 then
        name := ReplacedString( name, "morphisms )", "morphism )" );
    fi;
    
    quotient_category := QuotientCategory( rec(
                                      underlying_category := B,
                                      name := name,
                                      congruence_function := congruence_function,
                                      nr_arguments_of_congruence_function := 1 ) : FinalizeCategory := false );
    ##
    ## Adding the Hom-Structure
    ##
    
    range_of_HomStructure := RangeCategoryOfHomomorphismStructure( B );
    
    ring := UnderlyingRing( range_of_HomStructure );
    
    if IsFieldForHomalg( ring ) then
        
        SetRangeCategoryOfHomomorphismStructure( quotient_category, range_of_HomStructure );
        
        AddDistinguishedObjectOfHomomorphismStructure( quotient_category,
          function ( quotient_category )
            
            return DistinguishedObjectOfHomomorphismStructure( B );
            
        end );
        
        AddHomomorphismStructureOnObjects( quotient_category,
          function ( quotient_category, obj1, obj2 )
            local obj2_op;
            
            obj1 := UnderlyingCell( obj1 );
            obj2 := UnderlyingCell( obj2 );
            
            obj2_op := SetOfObjects( B_op )[ObjectIndex( obj2 )];
            
            return Range( pi )( ElementaryTensor( obj2_op, obj1, B_op_x_B ) );
            
        end );
        
        AddHomomorphismStructureOnMorphismsWithGivenObjects( quotient_category,
          function ( quotient_category, s, f, g, r )
            local g_op, g_op_x_f;
            
            f := UnderlyingCell( f );
            
            g_op := CreateMorphism(
                      B_op,
                      SetOfObjects( B_op )[ObjectIndex( UnderlyingCell( Range( g ) ) )],
                      CoefficientsOfMorphism( UnderlyingCell( g ) ),
                      MorphismSupport( UnderlyingCell( g ) ),
                      SetOfObjects( B_op )[ObjectIndex( UnderlyingCell( Source( g ) ) )] );
            
            g_op_x_f := ElementaryTensor( g_op, f, B_op_x_B );
            
            return CokernelObjectFunctorialWithGivenCokernelObjects( range_of_HomStructure,
                        s,
                        tau( Range( g_op_x_f ) ),
                        F( g_op_x_f ),
                        tau( Source( g_op_x_f ) ),
                        r );
            
        end );
        
        AddInterpretMorphismAsMorphismFromDistinguishedObjectToHomomorphismStructure( quotient_category,
          function ( quotient_category, mor )
            local distinguished_object, obj1, obj2, obj2_op, obj2_op_x_obj1;
            
            distinguished_object := DistinguishedObjectOfHomomorphismStructure( quotient_category );
            
            mor := UnderlyingCell( mor );
            
            obj1 := Source( mor );
            obj2 := Range( mor );
            
            obj2_op := SetOfObjects( B_op )[ObjectIndex( obj2 )];
            
            obj2_op_x_obj1 := ElementaryTensor( obj2_op, obj1, B_op_x_B );
            
            return PreCompose(
                      range_of_HomStructure,
                      InterpretMorphismAsMorphismFromDistinguishedObjectToHomomorphismStructureWithGivenObjects( B, distinguished_object, mor, F( obj2_op_x_obj1 ) ),
                      pi( obj2_op_x_obj1 ) );
            
        end );
        
        AddInterpretMorphismFromDistinguishedObjectToHomomorphismStructureAsMorphism( quotient_category,
          function ( quotient_category, obj1, obj2, eta )
            local obj2_op, obj2_op_x_obj1, ell, mor;
            
            obj1 := UnderlyingCell( obj1 );
            obj2 := UnderlyingCell( obj2 );
            
            obj2_op := SetOfObjects( B_op )[ObjectIndex( obj2 )];
            obj2_op_x_obj1 := ElementaryTensor( obj2_op, obj1, B_op_x_B );
            
            ell := ProjectiveLift( range_of_HomStructure, eta, pi( obj2_op_x_obj1 ) );
            
            mor := InterpretMorphismFromDistinguishedObjectToHomomorphismStructureAsMorphism( B, obj1, obj2, ell );
            
            return mor / quotient_category;
            
        end );
         
    else
        
        range_of_HomStructure := FreydCategory( range_of_HomStructure );
        
        SetRangeCategoryOfHomomorphismStructure( quotient_category, range_of_HomStructure );
        
        AddDistinguishedObjectOfHomomorphismStructure( quotient_category,
          function ( quotient_category )
            
            return AsFreydCategoryObject( range_of_HomStructure, DistinguishedObjectOfHomomorphismStructure( B ) );
            
        end );
        
        AddHomomorphismStructureOnObjects( quotient_category,
          function ( quotient_category, obj1, obj2 )
            local obj2_op;
            
            obj1 := UnderlyingCell( obj1 );
            obj2 := UnderlyingCell( obj2 );
            
            obj2_op := SetOfObjects( B_op )[ObjectIndex( obj2 )];
            
            return FreydCategoryObject( range_of_HomStructure, tau( ElementaryTensor( obj2_op, obj1, B_op_x_B ) ) );
            
        end );
        
        AddHomomorphismStructureOnMorphismsWithGivenObjects( quotient_category,
          function ( quotient_category, s, f, g, r )
            local g_op, g_op_x_f;
            
            f := UnderlyingCell( f );
            
            g_op := CreateMorphism(
                      B_op,
                      SetOfObjects( B_op )[ObjectIndex( UnderlyingCell( Range( g ) ) )],
                      CoefficientsOfMorphism( UnderlyingCell( g ) ),
                      MorphismSupport( UnderlyingCell( g ) ),
                      SetOfObjects( B_op )[ObjectIndex( UnderlyingCell( Source( g ) ) )] );
            
            g_op_x_f := ElementaryTensor( g_op, f, B_op_x_B );
            
            return FreydCategoryMorphism( range_of_HomStructure,
                        s,
                        F( g_op_x_f ),
                        r );
            
        end );
        
        AddInterpretMorphismAsMorphismFromDistinguishedObjectToHomomorphismStructureWithGivenObjects( quotient_category,
          function ( quotient_category, distinguished_object, mor, r )
            
            return FreydCategoryMorphism( range_of_HomStructure,
                      distinguished_object,
                      InterpretMorphismAsMorphismFromDistinguishedObjectToHomomorphismStructureWithGivenObjects( B,
                                        Range( RelationMorphism( distinguished_object ) ),
                                        UnderlyingCell( mor ),
                                        Range( RelationMorphism( r ) ) ),
                      r );
            
        end );
        
        AddInterpretMorphismFromDistinguishedObjectToHomomorphismStructureAsMorphism( quotient_category,
          function ( quotient_category, obj1, obj2, eta )
            local mor;
            
            mor := InterpretMorphismFromDistinguishedObjectToHomomorphismStructureAsMorphism( B,
                                    UnderlyingCell( obj1 ),
                                    UnderlyingCell( obj2 ),
                                    UnderlyingMorphism( eta ) );
            
            return mor / quotient_category;
            
        end );
    
    fi;
    
    InstallMethod( DisplayString,
              [ ObjectFilter( quotient_category ) ],
    
     o -> Concatenation( ViewString( o ), "\n" ) );
    
    InstallMethod( ViewString,
              [ ObjectFilter( quotient_category ) ],
      function ( obj )
        
        return ViewString( UnderlyingCell( obj ) );
        
    end );
    
    InstallMethod( DisplayString,
              [ MorphismFilter( quotient_category ) ],
    
    m -> Concatenation( ViewString( m ), "\n" ) );
    
    InstallMethod( ViewString,
              [ MorphismFilter( quotient_category ) ],
      function ( mor )
        local string;
        
        string := ViewString( UnderlyingCell( mor ) );
        string := ReplacedString( string, "<", "<[ " );
        string := ReplacedString( string, ">", " ]>" );
        
        return string;
        
    end );
    
    Finalize( quotient_category );
    
    return quotient_category;
    
end );

##
InstallOtherMethod( \/,
        [ IsAlgebroidFromDataTables, IsDenseList ],
  
  QuotientCategory );

###################
#
# View Methods
#
###################

##
InstallMethod( ViewString,
          [ IsObjectInAlgebroidFromDataTables ],
  
  function ( obj )
    
    return Concatenation( "<(", EnhancedDataTables( CapCategory( obj ) )[3][ObjectIndex( obj )], ")>" );
    
end );

##
InstallMethod( DisplayString,
          [ IsObjectInAlgebroidFromDataTables ],
  
  o -> Concatenation( ViewString( o ), "\n" ) );


##
InstallMethod( LaTeXOutput,
          [ IsObjectInAlgebroidFromDataTables ],
  
  function ( obj )
    
    return EnhancedDataTables( CapCategory( obj ) )[4][ObjectIndex(obj)];
    
end );

##
InstallMethod( ViewString,
          [ IsMorphismInAlgebroidFromDataTables ],
  
  function ( alpha )
    local B, i, j, coeffs, support, colors, datum_string, labels;
    
    B := CapCategory( alpha );
    
    i := ObjectIndex( Source( alpha ) );
    j := ObjectIndex( Range( alpha ) );
    
    coeffs := MorphismCoefficients( alpha );
    support := MorphismSupport( alpha );
    
    colors := EnhancedDataTables( B )[22];
    
    if IsEmpty( support ) then
        datum_string := Concatenation( colors.coeff, "0", colors.reset );
    else
        coeffs := List( coeffs{support}, String );
        coeffs := List( coeffs, c -> Concatenation( colors.coeff, c, colors.reset ) );
        
        labels := (EnhancedDataTables( B )[14]{EnhancedDataTables( B )[16][j][i]}){support};
        labels := List( labels, l -> Concatenation( colors.basis_elm, l, colors.reset ) );
        
        datum_string := JoinStringsWithSeparator( ListN( coeffs, labels, { c, l } -> Concatenation( c, "*", l ) ), " + " );
        datum_string := ReplacedString( datum_string, Concatenation( "+ ", colors.coeff, "-" ), Concatenation( "- ", colors.coeff ) );
    fi;
    
    return
      Concatenation(
          "<",
          datum_string,
          colors.other,
          ":",
          colors.reset,
          "(",
          colors.obj,
          EnhancedDataTables( B )[3][i],
          colors.reset,
          ") ",
          colors.other,
          "-≻",
          colors.reset,
          " (",
          colors.obj,
          EnhancedDataTables( B )[3][j],
          colors.reset,
          ")>" );
    
end );

##
InstallMethod( DisplayString,
          [ IsMorphismInAlgebroidFromDataTables ],
  
  m -> Concatenation( ViewString( m ), "\n" ) );

##
InstallMethod( LaTeXOutput,
          [ IsMorphismInAlgebroidFromDataTables ],
  
  function ( alpha )
    local B, i, j, coeffs, support, string;
    
    B := CapCategory( alpha );
    
    i := ObjectIndex( Source( alpha ) );
    j := ObjectIndex( Range( alpha ) );
    
    coeffs := MorphismCoefficients( alpha );
    support := MorphismSupport( alpha );
    
    if IsEmpty( support ) then
        string := "0";
    else
        coeffs := List( coeffs{support},  function (c)
                                            
                                            if c in [ 1, -1 ] then
                                                  return ReplacedString( LaTeXOutput( c ), "1", "" );
                                            else
                                                  return Concatenation( LaTeXOutput( c ), "\\cdot " );
                                            fi;
                                            
                                          end );
        
        string := (EnhancedDataTables( B )[15]{EnhancedDataTables( B )[16][j][i]}){support};
        string := ReplacedString( JoinStringsWithSeparator( ListN( coeffs, string, { c, l } -> Concatenation( c, l ) ), " + " ), "+ -", "- " );
    fi;
    
    if ValueOption( "OnlyDatum" ) = true then
      
      return string;
      
    else
      
      return Concatenation(
                "{", LaTeXOutput( Source( alpha ) ), "}-\\left(",
                "{", string, "}\\right)\\rightarrow",
                "{", LaTeXOutput( Range( alpha ) ), "}" );
    
    fi;
    
end );
